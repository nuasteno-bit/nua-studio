<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Jua&family=Do+Hyeon&family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gothic+A1&family=IBM+Plex+Sans+KR&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* ê¸°ë³¸ ë°°ê²½ - íˆ¬ëª…ì°½ì„ ìœ„í•´ rgba ì‚¬ìš© */
        html {
            background: rgba(0, 0, 0, 1);
        }
        
        body {
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0;
            background: rgba(0, 0, 0, 1); 
            color: #fff; 
            overflow: hidden;
        }
        
        /* ì—°ê²° ìƒíƒœ í‘œì‹œ */
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-family: 'Noto Sans KR', sans-serif;
            z-index: 10001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #connection-status.connecting {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }
        
        #connection-status.connected {
            background: rgba(40, 167, 69, 0.9);
            color: #fff;
        }
        
        #connection-status.disconnected {
            background: rgba(220, 53, 69, 0.9);
            color: #fff;
        }
        
        #connection-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* ë“œë˜ê·¸ í—¤ë” - ìƒë‹¨ 20pxë§Œ ë“œë˜ê·¸ ê°€ëŠ¥ */
        .drag-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: transparent;
            -webkit-app-region: drag;
            z-index: 9999;
            transition: background 0.3s ease;
        }
        
        /* í…Œë‘ë¦¬ í‘œì‹œ ì‹œ ë“œë˜ê·¸ í—¤ë” ë³´ì´ê¸° */
        body.show-border .drag-header {
            background: rgba(0, 212, 255, 0.2);
            border-bottom: 1px solid rgba(0, 212, 255, 0.5);
        }
        
        /* íˆ¬ëª… ëª¨ë“œ + í…Œë‘ë¦¬ í‘œì‹œ ì‹œ */
        body.transparent-mode.show-border .drag-header {
            background: rgba(0, 212, 255, 0.15);
            border-bottom: 1px solid rgba(0, 212, 255, 0.4);
        }
        
        /* íˆ¬ëª… ëª¨ë“œ */
        html.transparent-mode,
        body.transparent-mode {
            background: rgba(0, 0, 0, 0.01) !important;
        }
        
        body.transparent-mode #viewer {
            background: rgba(0, 0, 0, 0.01) !important;
            box-shadow: 0 0 1px rgba(0,0,0,0.01);
        }
        
        body.transparent-mode #viewer-text {
            color: white !important;
            text-shadow: 
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 2px rgba(0,0,0,1);
            -webkit-text-stroke: 0.5px black;
        }
        
        /* í…Œë‘ë¦¬ - box-sizingìœ¼ë¡œ ë‚´ë¶€ í¬ê¸° ìœ ì§€ */
        body.show-border {
            border: 4px solid #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            box-sizing: border-box;
        }
        
        body.transparent-mode.show-border {
            border: 4px solid #00d4ff;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);
            box-sizing: border-box;
        }
        
        #viewer {
            position: relative;
            width: 100vw; 
            height: 100vh;
            font-size: 32px; 
            line-height: 1.5; 
            text-align: left;
            transition: background 0.3s;
            z-index: 1;
            padding: 40px 30px;
            box-sizing: border-box;
        }
        
        #viewer-text {
            position: absolute;
            top: 40px; 
            left: 30px; 
            right: 30px; 
            bottom: 40px;
            width: calc(100% - 60px);
            height: calc(100% - 80px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #8884 #0000;
            background: none;
            word-break: break-all;
            white-space: pre-wrap;
            padding: 0;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            text-align: inherit;
            line-height: inherit;
            transition: color 0.2s, background 0.2s;
            box-sizing: border-box;
        }
        
        #viewer-text::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        
        /* ìŠ¤í¬ë¡¤ë°” ìˆ¨ê¹€ í´ë˜ìŠ¤ */
        #viewer-text.hide-scrollbar {
            scrollbar-width: none;
        }
        
        #viewer-text.hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        
        /* ì„¤ì • ì•„ì´ì½˜ */
        #setting-icon {
            position: fixed;
            top: 18px; 
            left: 50%; 
            transform: translateX(-50%);
            width: 44px; 
            height: 44px;
            background: rgba(45,45,45,0.9);
            border: 1px solid #444;
            border-radius: 8px;
            z-index: 1000;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'Consolas', 'Courier New', monospace;
        }
        
        #setting-icon.visible {
            opacity: 1;
        }
        
        #setting-icon:hover {
            background: rgba(58,58,58,0.95);
            border-color: #5a78ff;
            box-shadow: 0 4px 16px rgba(90,120,255,0.2);
        }
        
        #setting-icon svg { 
            width: 24px; 
            height: 24px; 
            fill: #a2c1ff; 
            transition: fill 0.2s ease;
        }
        
        #setting-icon:hover svg { 
            fill: #fff; 
        }
        
        /* ì•Œë¦¼ */
        .notification {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 10000;
            display: none;
            pointer-events: none;
        }
        
        /* ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼ CSS */
        .shake { animation: shake 0.5s ease-in-out 3; }
        @keyframes shake { 0%,100%{transform:translateX(0);} 25%{transform:translateX(-5px);} 75%{transform:translateX(5px);} }
        .fade-in { animation: fadeIn 2s ease-in-out; }
        @keyframes fadeIn { 0%{opacity:0;transform:translateY(20px);} 100%{opacity:1;transform:translateY(0);} }
        .zoom { animation: zoom 1.5s ease-in-out; }
        @keyframes zoom { 0%{transform:scale(0.8);} 50%{transform:scale(1.1);} 100%{transform:scale(1);} }
        .gradient-text { background:linear-gradient(45deg,#ff6b6b,#4ecdc4,#45b7d1,#96ceb4);background-size:300% 300%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:gradient-flow 3s ease infinite; }
        @keyframes gradient-flow { 0%{background-position:0% 50%;} 50%{background-position:100% 50%;} 100%{background-position:0% 50%;} }
        .neon { color:#fff;text-shadow:0 0 5px #00ffff,0 0 10px #00ffff,0 0 15px #00ffff,0 0 20px #00ffff;animation:neon-flicker 2s infinite alternate; }
        @keyframes neon-flicker { 0%,100%{text-shadow:0 0 5px #00ffff,0 0 10px #00ffff,0 0 15px #00ffff,0 0 20px #00ffff;} 50%{text-shadow:0 0 2px #00ffff,0 0 5px #00ffff,0 0 8px #00ffff,0 0 12px #00ffff;} }
        .typewriter { border-right:3px solid #fff;animation:typewriter-blink 1s infinite; }
        @keyframes typewriter-blink { 0%,50%{border-color:#fff;} 51%,100%{border-color:transparent;} }
        .rotate { animation: rotate-360 2s ease-in-out; }
        @keyframes rotate-360 { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
        .slide-left { animation: slideLeft 1s ease-out; }
        @keyframes slideLeft { 0%{transform:translateX(100%);opacity:0;} 100%{transform:translateX(0);opacity:1;} }
        .slide-right { animation: slideRight 1s ease-out; }
        @keyframes slideRight { 0%{transform:translateX(-100%);opacity:0;} 100%{transform:translateX(0);opacity:1;} }
        .bg-party { background:linear-gradient(45deg,#ff6b6b,#4ecdc4,#45b7d1,#96ceb4);background-size:400% 400%;animation:bg-party 3s ease infinite; }
        @keyframes bg-party { 0%{background-position:0% 50%;} 50%{background-position:100% 50%;} 100%{background-position:0% 50%;} }
    </style>
</head>
<body class="show-border">
    <div class="drag-header"></div>
    <div id="connection-status" class="connecting">
        <div class="status-dot"></div>
        <span>ì—°ê²° ì¤‘...</span>
    </div>
    <div id="viewer">
        <div id="viewer-text">ìë§‰ ëŒ€ê¸° ì¤‘...</div>
        <div id="setting-icon" title="ì„¤ì •">
            <svg viewBox="0 0 24 24"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7zm7.43-2.9l1.77-1.02a1 1 0 0 0 .37-1.36l-1.68-2.92a1 1 0 0 0-1.28-.46l-1.77 1.02a7.03 7.03 0 0 0-1.52-.88l-.27-2A1 1 0 0 0 13.5 3h-3a1 1 0 0 0-1 .88l-.27 2a7.03 7.03 0 0 0-1.52.88l-1.77-1.02a1 1 0 0 0-1.36.37l-1.68 2.92a1 1 0 0 0 .37 1.36l1.77 1.02c-.09.32-.16.65-.22.99l-2 .27A1 1 0 0 0 3 10.5v3a1 1 0 0 0 .88 1l2 .27c.06.34.13.67.22.99l-1.77 1.02a1 1 0 0 0-.37 1.36l1.68 2.92a1 1 0 0 0 1.28.46l1.77-1.02c.47.34.97.64 1.52.88l.27 2A1 1 0 0 0 10.5 21h3a1 1 0 0 0 1-.88l.27-2c.55-.24 1.05-.54 1.52-.88l1.77 1.02a1 1 0 0 0 1.36-.37l1.68-2.92a1 1 0 0 0-.37-1.36l-1.77-1.02c.09-.32.16-.65.22-.99l2-.27A1 1 0 0 0 21 13.5v-3a1 1 0 0 0-.88-1l-2-.27a7.03 7.03 0 0 0-.22-.99zM12 17a5 5 0 1 1 0-10 5 5 0 0 1 0 10z"/></svg>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>

    <script>
        // ElectronAPI ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
        const isElectron = window.electronAPI !== undefined;
        
        let channelCode = null;
        let socket = null;
        let isTransparent = false;
        let borderVisible = true;
        let lastClickTime = 0;
        
        const viewerText = document.getElementById('viewer-text');
        const settingIcon = document.getElementById('setting-icon');
        const connectionStatus = document.getElementById('connection-status');
        
        // ëˆ„ì  í…ìŠ¤íŠ¸ ê´€ë¦¬
        let accumulatedText = '';
        let activeStenographer = '1';
        let currentActiveInput = '';
        let lastProcessedText = '';
        
        // ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateConnectionStatus(status, message) {
            connectionStatus.className = status;
            connectionStatus.querySelector('span').textContent = message;
            
            if (status === 'connected') {
                setTimeout(() => {
                    connectionStatus.style.opacity = '0';
                }, 3000);
            } else {
                connectionStatus.style.opacity = '1';
            }
        }
        
        // Socket.IO ë™ì  ë¡œë“œ í•¨ìˆ˜
        function loadSocketIO() {
            return new Promise((resolve, reject) => {
                if (typeof io !== 'undefined') {
                    console.log('[Socket.IO] ì´ë¯¸ ë¡œë“œë¨');
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://cdn.socket.io/4.5.4/socket.io.min.js';
                script.onload = () => {
                    console.log('[Socket.IO] ë¡œë“œ ì„±ê³µ');
                    resolve();
                };
                script.onerror = () => {
                    console.error('[Socket.IO] ë¡œë“œ ì‹¤íŒ¨');
                    reject(new Error('Socket.IO ë¡œë“œ ì‹¤íŒ¨'));
                };
                document.head.appendChild(script);
            });
        }
        
        // ì±„ë„ ê²€ì¦ ë° ì ‘ì†
        async function verifyAndConnect(code) {
            channelCode = code;
            console.log('[Channel] ê²€ì¦ ë° ì ‘ì† ì‹œë„:', code);
            
            try {
                // ì±„ë„ ê²€ì¦ API í˜¸ì¶œ
                const response = await fetch(`https://81b5c4d8eea5.ngrok-free.app/api/channel/${code}/verify`, {
                    headers: {
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                const data = await response.json();
                
                if (data.exists) {
                    console.log('[Channel] ì±„ë„ í™•ì¸ë¨, Socket.IO ë¡œë“œ ì¤‘...');
                    await loadSocketIO();
                    connectToSocket();
                } else {
                    console.error('[Channel] ì±„ë„ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ');
                    updateConnectionStatus('disconnected', 'ì±„ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ');
                    showNotification('ì±„ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }
            } catch (error) {
                console.error('[Channel] ê²€ì¦ ì‹¤íŒ¨:', error);
                updateConnectionStatus('disconnected', 'ì—°ê²° ì‹¤íŒ¨');
                showNotification('ì±„ë„ í™•ì¸ ì‹¤íŒ¨');
            }
        }
        
        // ë”¥ë§í¬ë¡œ ì±„ë„ ì°¸ê°€ (Electronì—ì„œ ì „ë‹¬)
        if (isElectron) {
            window.electronAPI.on('deep-link-join', async (data) => {
                console.log('[DeepLink] ì±„ë„ ì°¸ê°€ ìš”ì²­:', data);
                const { channel, token } = data;
                
                if (channel) {
                    // ê¸°ì¡´ ì—°ê²°ì´ ìˆìœ¼ë©´ ëŠê¸°
                    if (socket) {
                        socket.disconnect();
                        socket = null;
                    }
                    
                    // ìƒˆ ì±„ë„ë¡œ ì ‘ì†
                    await verifyAndConnect(channel);
                }
            });
            
            // Legacy: ì±„ë„ ì½”ë“œ ìˆ˜ì‹  (ê¸°ì¡´ ë°©ì‹ í˜¸í™˜)
            window.electronAPI.on('channel-code', async (code) => {
                console.log('[Legacy] ì±„ë„ ì½”ë“œ ìˆ˜ì‹ :', code);
                await verifyAndConnect(code);
            });
        }
        
        // Socket.io ì—°ê²°
        function connectToSocket() {
            try {
                const socketUrl = 'https://81b5c4d8eea5.ngrok-free.app';
                
                const socketOptions = {
                    transports: ['websocket', 'polling'],
                    upgrade: true,
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    reconnectionAttempts: 10,
                    timeout: 20000,
                    forceNew: true
                };
                
                console.log('[Socket] ì—°ê²° ì‹œë„:', socketUrl);
                socket = io(socketUrl, socketOptions);
                
                socket.on('connect', () => {
                    console.log('[Socket] ì—°ê²° ì„±ê³µ!');
                    console.log('[Socket] Socket ID:', socket.id);
                    updateConnectionStatus('connected', 'ì—°ê²°ë¨');
                    showNotification('ì„œë²„ ì—°ê²° ì„±ê³µ');
                    
                    console.log('[Socket] ì±„ë„ ì°¸ê°€:', channelCode);
                    socket.emit('join_channel', { 
                        channel: channelCode, 
                        role: 'viewer'
                    });
                });
                
                socket.on('connect_error', (error) => {
                    console.error('[Socket] ì—°ê²° ì—ëŸ¬:', error.message);
                    updateConnectionStatus('disconnected', 'ì—°ê²° ì‹¤íŒ¨');
                });
                
                socket.on('disconnect', (reason) => {
                    console.log('[Socket] ì—°ê²° ëŠê¹€:', reason);
                    updateConnectionStatus('disconnected', 'ì—°ê²° ëŠê¹€');
                });
                
                socket.on('reconnect_attempt', (attemptNumber) => {
                    console.log('[Socket] ì¬ì—°ê²° ì‹œë„:', attemptNumber);
                    updateConnectionStatus('connecting', `ì¬ì—°ê²° ì‹œë„ ì¤‘... (${attemptNumber})`);
                });
                
                socket.on('reconnect', () => {
                    console.log('[Socket] ì¬ì—°ê²° ì„±ê³µ');
                    updateConnectionStatus('connected', 'ì¬ì—°ê²°ë¨');
                    socket.emit('join_channel', { 
                        channel: channelCode, 
                        role: 'viewer'
                    });
                });
                
                socket.on('joined_channel', (data) => {
                    console.log('[Socket] ì±„ë„ ì°¸ê°€ ì„±ê³µ:', data);
                    showNotification(`ì±„ë„ ${channelCode} ì°¸ê°€ ì™„ë£Œ`);
                    socket.emit('request_sync', { channel: channelCode });
                });
                
                socket.on('error', (error) => {
                    console.error('[Socket] ì—ëŸ¬:', error);
                    if (error.message && error.message.includes('Channel not found')) {
                        showNotification('ì±„ë„ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                        updateConnectionStatus('disconnected', 'ì±„ë„ ì—†ìŒ');
                    }
                });
                
                socket.on('sync_accumulated', (data) => {
                    console.log('[Socket] ëˆ„ì  í…ìŠ¤íŠ¸ ë™ê¸°í™”:', data);
                    
                    if (data.accumulatedText !== undefined) {
                        accumulatedText = data.accumulatedText;
                        currentActiveInput = '';
                        updateViewerDisplay(accumulatedText, true);
                        console.log('[ë™ê¸°í™”] ëˆ„ì  í…ìŠ¤íŠ¸ ì„¤ì •:', accumulatedText);
                    }
                    
                    if (!data.activeStenographer) {
                        console.log('[ë™ê¸°í™”] í™œì„± ì†ê¸°ì‚¬ ì •ë³´ ì—†ìŒ, ìƒíƒœ ìš”ì²­');
                        socket.emit('get_channel_state', { channel: channelCode });
                    } else {
                        activeStenographer = data.activeStenographer === 'steno1' ? '1' : '2';
                        console.log('[ë™ê¸°í™”] í™œì„± ì†ê¸°ì‚¬:', activeStenographer);
                    }
                });
                
                socket.on('channel_state', (data) => {
                    console.log('[Socket] ì±„ë„ ìƒíƒœ:', data);
                    if (data.state) {
                        if (data.state.activeStenographer) {
                            activeStenographer = data.state.activeStenographer === 'steno1' ? '1' : '2';
                            console.log('[ìƒíƒœ] í™œì„± ì†ê¸°ì‚¬:', activeStenographer);
                        }
                        if (data.state.accumulatedText !== undefined) {
                            accumulatedText = data.state.accumulatedText;
                            currentActiveInput = '';
                            updateViewerDisplay(accumulatedText, true);
                        }
                    }
                });
                
                socket.on('steno_input', (data) => {
                    console.log('[Socket] ì‹¤ì‹œê°„ ì…ë ¥:', {
                        role: data.role,
                        text: data.text,
                        activeStenographer: activeStenographer,
                        dataLength: data.text ? data.text.length : 0
                    });
                    
                    let inputRole;
                    if (data.role === 'steno1' || data.role === '1') {
                        inputRole = '1';
                    } else if (data.role === 'steno2' || data.role === '2') {
                        inputRole = '2';
                    } else {
                        inputRole = data.role;
                    }
                    
                    console.log('[ì…ë ¥] ë§¤í•‘ëœ ì—­í• :', inputRole, 'í˜„ì¬ í™œì„±:', activeStenographer);
                    
                    if (inputRole === activeStenographer) {
                        currentActiveInput = data.text || '';
                        const fullText = accumulatedText + currentActiveInput;
                        updateViewerDisplay(fullText, false);
                        console.log('[í‘œì‹œ] í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸:', fullText.length, 'ì');
                    }
                });
                
                socket.on('switch_role', (data) => {
                    console.log('[Socket] ì—­í•  ì „í™˜:', data);
                    
                    if (data.newActive === 'steno1' || data.newActive === '1') {
                        activeStenographer = '1';
                    } else if (data.newActive === 'steno2' || data.newActive === '2') {
                        activeStenographer = '2';
                    }
                    
                    if (data.accumulatedText !== undefined) {
                        accumulatedText = data.accumulatedText;
                        currentActiveInput = '';
                        updateViewerDisplay(accumulatedText, true);
                    }
                    
                    showNotification(`ì†ê¸°ì‚¬ ${activeStenographer} í™œì„±í™”`);
                });
                
                socket.on('clear_text', () => {
                    console.log('[Socket] í…ìŠ¤íŠ¸ í´ë¦¬ì–´');
                    accumulatedText = '';
                    currentActiveInput = '';
                    updateViewerDisplay('', true);
                    showNotification('í…ìŠ¤íŠ¸ ì´ˆê¸°í™”ë¨');
                });
                
                socket.on('viewer_text_update', (data) => {
                    console.log('[Socket] viewer_text_update ì´ë²¤íŠ¸:', data);
                    if (data.text !== undefined) {
                        viewerText.textContent = data.text || 'ìë§‰ ëŒ€ê¸° ì¤‘...';
                        viewerText.scrollTop = viewerText.scrollHeight;
                    }
                });
                
                socket.onAny((eventName, ...args) => {
                    console.log('[Socket Event]', eventName, JSON.stringify(args, null, 2));
                });
                
            } catch (error) {
                console.error('[Socket] ì—°ê²° ì—ëŸ¬:', error);
                updateConnectionStatus('disconnected', 'ì—°ê²° ì‹¤íŒ¨: ' + error.message);
            }
        }
        
        // ì• ë‹ˆë©”ì´ì…˜ íŠ¸ë¦¬ê±° ë³€í™˜ í•¨ìˆ˜
        function processRealisticEmotions(text) {
            let processedText = text;
            let effectClass = '';
            
            if (text.includes('(ì§„ë™)')) {
                processedText = text.replace(/\(ì§„ë™\)/g, 'ğŸ“³');
                effectClass = 'shake';
            } else if (text.includes('(í˜ì´ë“œ)')) {
                processedText = text.replace(/\(í˜ì´ë“œ\)/g, 'âœ¨');
                effectClass = 'fade-in';
            } else if (text.includes('(í™•ëŒ€)')) {
                processedText = text.replace(/\(í™•ëŒ€\)/g, 'ğŸ”');
                effectClass = 'zoom';
            } else if (text.includes('(ë¬´ì§€ê°œ)')) {
                processedText = text.replace(/\(ë¬´ì§€ê°œ\)/g, 'ğŸŒˆ');
                effectClass = 'gradient-text';
            } else if (text.includes('(ë„¤ì˜¨)')) {
                processedText = text.replace(/\(ë„¤ì˜¨\)/g, 'ğŸ’¡');
                effectClass = 'neon';
            } else if (text.includes('(íƒ€ìê¸°)')) {
                processedText = text.replace(/\(íƒ€ìê¸°\)/g, 'âŒ¨ï¸');
                effectClass = 'typewriter';
            } else if (text.includes('(íšŒì „)')) {
                processedText = text.replace(/\(íšŒì „\)/g, 'ğŸ”„');
                effectClass = 'rotate';
            } else if (text.includes('(ì™¼ìŠ¬ë¼ì´ë“œ)')) {
                processedText = text.replace(/\(ì™¼ìŠ¬ë¼ì´ë“œ\)/g, 'â†');
                effectClass = 'slide-left';
            } else if (text.includes('(ì˜¤ë¥¸ìŠ¬ë¼ì´ë“œ)')) {
                processedText = text.replace(/\(ì˜¤ë¥¸ìŠ¬ë¼ì´ë“œ\)/g, 'â†’');
                effectClass = 'slide-right';
            } else if (text.includes('(íŒŒí‹°)')) {
                processedText = text.replace(/\(íŒŒí‹°\)/g, 'ğŸ‰');
                effectClass = 'bg-party';
            }
            
            return { text: processedText, effect: effectClass };
        }
        
        // 1ë‹¨ì–´ ì§€ì—° ì²˜ë¦¬ í•¨ìˆ˜
        function updateViewerDisplay(fullText, isImmediate = false) {
            let displayText = '';
            if (isImmediate) {
                displayText = fullText;
            } else {
                if (fullText.endsWith(' ')) {
                    displayText = fullText;
                } else {
                    const words = fullText.split(' ');
                    if (words.length > 1) {
                        displayText = words.slice(0, -1).join(' ') + ' ';
                    } else {
                        displayText = '';
                    }
                }
            }
            
            const { text, effect } = processRealisticEmotions(displayText);
            viewerText.textContent = text || 'ìë§‰ ëŒ€ê¸° ì¤‘...';
            viewerText.className = effect || '';
            viewerText.scrollTop = viewerText.scrollHeight;
        }
        
        // ì„¤ì • ì•„ì´ì½˜ í‘œì‹œ
        let isMouseInTopArea = false;
        let isMouseOnIcon = false;
        
        function updateIconVisibility() {
            if (isMouseInTopArea || isMouseOnIcon) {
                settingIcon.classList.add('visible');
            } else {
                settingIcon.classList.remove('visible');
            }
        }
        
        document.addEventListener('mousemove', e => {
            isMouseInTopArea = e.clientY < 100;
            updateIconVisibility();
        });
        
        settingIcon.addEventListener('mouseenter', () => {
            isMouseOnIcon = true;
            updateIconVisibility();
        });
        
        settingIcon.addEventListener('mouseleave', () => {
            isMouseOnIcon = false;
            updateIconVisibility();
        });
        
        // ì˜µì…˜ íŒ¨ë„ í† ê¸€
        settingIcon.addEventListener('click', e => {
            e.stopPropagation();
            
            if (!isElectron) return;
            
            const currentSettings = {
                bgColor: '#000000',
                bgAlpha: '100',
                fontColor: '#ffffff',
                fontSize: '32',
                fontFamily: 'sans-serif',
                outlineOn: false,
                outlineColor: '#000000',
                outlineWidth: '2',
                shadowOn: false,
                shadowColor: '#000000',
                shadowBlur: '3',
                shadowDistance: '2',
                isTransparent: isTransparent
            };
            
            window.electronAPI.openOptions(currentSettings);
        });
        
        // ë”ë¸”í´ë¦­ ê°ì§€
        document.addEventListener('mousedown', (e) => {
            if (e.target.closest('#setting-icon')) return;
            
            const now = Date.now();
            if (now - lastClickTime < 300) {
                e.preventDefault();
                toggleBorder();
            }
            lastClickTime = now;
        });
        
        // í…Œë‘ë¦¬ í† ê¸€
        function toggleBorder() {
            borderVisible = !borderVisible;
            
            if (borderVisible) {
                document.body.classList.add('show-border');
                showNotification('í…Œë‘ë¦¬ í‘œì‹œ');
            } else {
                document.body.classList.remove('show-border');
                showNotification('í…Œë‘ë¦¬ ìˆ¨ê¹€');
            }
        }
        
        // ìš°í´ë¦­ ë©”ë‰´
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            if (!isElectron) return;
            
            const isScrollbarHidden = viewerText.classList.contains('hide-scrollbar');
            
            window.electronAPI.showContextMenu({
                isTransparent: isTransparent,
                isScrollbarHidden: isScrollbarHidden,
                x: e.clientX,
                y: e.clientY
            });
        });
        
        // Electron IPC ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (Electron í™˜ê²½ì—ì„œë§Œ)
        if (isElectron) {
            // íˆ¬ëª… ë°°ê²½ í† ê¸€
            window.electronAPI.on('toggle-transparent', () => {
                isTransparent = !isTransparent;
                
                if (isTransparent) {
                    document.documentElement.classList.add('transparent-mode');
                    document.body.classList.add('transparent-mode');
                    document.documentElement.style.backgroundColor = 'rgba(0,0,0,0.01)';
                    document.body.style.backgroundColor = 'rgba(0,0,0,0.01)';
                    document.getElementById('viewer').style.backgroundColor = 'rgba(0,0,0,0.01)';
                    document.body.classList.add('show-border');
                    borderVisible = true;
                    showNotification('íˆ¬ëª… ë°°ê²½ í™œì„±í™”');
                    window.electronAPI.toggleTransparent(true);
                } else {
                    document.documentElement.classList.remove('transparent-mode');
                    document.body.classList.remove('transparent-mode');
                    document.documentElement.style.backgroundColor = '';
                    document.body.style.backgroundColor = '';
                    document.getElementById('viewer').style.backgroundColor = '';
                    showNotification('ê¸°ë³¸ ë°°ê²½ í™œì„±í™”');
                    window.electronAPI.toggleTransparent(false);
                }
            });
            
            // í•­ìƒ ìœ„ ìƒíƒœ ë³€ê²½
            window.electronAPI.on('always-on-top-changed', (enabled) => {
                showNotification(enabled ? 'í•­ìƒ ìœ„ í™œì„±í™”' : 'í•­ìƒ ìœ„ ë¹„í™œì„±í™”');
            });
            
            // ì„¤ì • ì—…ë°ì´íŠ¸
            window.electronAPI.on('update-settings', (settings) => {
                // ì„¤ì • ì ìš© ë¡œì§
                console.log('[Settings] ì—…ë°ì´íŠ¸:', settings);
            });
            
            // ìŠ¤í¬ë¡¤ë°” í† ê¸€
            window.electronAPI.on('toggle-scrollbar', () => {
                viewerText.classList.toggle('hide-scrollbar');
                const isHidden = viewerText.classList.contains('hide-scrollbar');
                showNotification(isHidden ? 'ìŠ¤í¬ë¡¤ë°” ìˆ¨ê¹€' : 'ìŠ¤í¬ë¡¤ë°” í‘œì‹œ');
            });
        }
        
        // ì•Œë¦¼ í‘œì‹œ
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }
        
        // ESC í‚¤
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isElectron) {
                window.electronAPI.exitFullscreen();
            }
        });
        
        // ê°œë°œ ëª¨ë“œ í…ŒìŠ¤íŠ¸ìš© (localhostì—ì„œë§Œ)
        if (!isElectron && window.location.hostname === 'localhost') {
            setTimeout(() => {
                console.log('[ê°œë°œëª¨ë“œ] í…ŒìŠ¤íŠ¸ ì±„ë„ ìë™ ì—°ê²°');
                verifyAndConnect('AAAAAA');
            }, 1000);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>NUA ÏûêÎßâ Î∑∞Ïñ¥</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=Jua&family=Do+Hyeon&family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gothic+A1&family=IBM+Plex+Sans+KR&family=Pretendard:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            background: transparent;
        }
        
        body {
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0;
            background: transparent;
            color: #fff; 
            overflow: hidden;
            min-width: 400px;   
            min-height: 0;
            font-family: 'Noto Sans KR', sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            position: relative;
        }
        
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-family: 'Pretendard', sans-serif;
            z-index: 10001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #connection-status.connecting {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }
        
        #connection-status.connected {
            background: rgba(40, 167, 69, 0.9);
            color: #fff;
        }
        
        #connection-status.disconnected {
            background: rgba(220, 53, 69, 0.9);
            color: #fff;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }
        
        #always-on-top-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-family: 'Pretendard', sans-serif;
            background: rgba(0, 240, 255, 0.9);
            color: #000;
            z-index: 10001;
            display: none;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #always-on-top-indicator.active {
            display: flex;
            opacity: 1;
        }
        
        .drag-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: transparent;
            -webkit-app-region: drag;
            z-index: 9999;
            transition: background 0.3s ease;
            cursor: move;
        }
        
        .drag-header:hover {
            background: rgba(0, 240, 255, 0.05);
        }
        
        body.show-border .drag-header {
            background: rgba(0, 240, 255, 0.1);
        }
        
        body.show-border {
            position: relative;
        }
        
        body.show-border::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 8px solid;
            border-image: linear-gradient(90deg, 
                #00f0ff 0%, 
                #00c4d4 25%, 
                #0099ff 50%, 
                #00c4d4 75%, 
                #00f0ff 100%
            ) 1;
            box-shadow: 
                inset 0 0 40px rgba(0, 240, 255, 0.8),
                0 0 40px rgba(0, 240, 255, 0.6),
                inset 0 0 20px rgba(0, 196, 212, 0.5),
                0 0 20px rgba(0, 196, 212, 0.4);
            pointer-events: none;
            z-index: 9998;
            animation: borderGlow 2s linear infinite;
        }
        
        @keyframes borderGlow {
            0% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
            25% {
                border-image: linear-gradient(180deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            50% {
                border-image: linear-gradient(270deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 153, 255, 0.8),
                    0 0 40px rgba(0, 153, 255, 0.6),
                    inset 0 0 20px rgba(0, 240, 255, 0.5),
                    0 0 20px rgba(0, 240, 255, 0.4);
            }
            75% {
                border-image: linear-gradient(360deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            100% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
        }
        
        #viewer {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            font-size: 32px; 
            line-height: 1.5; 
            text-align: left;
            transition: none;
            z-index: 1;
            box-sizing: border-box;
            background: transparent;
            overflow: hidden;
        }
        
        /* üî• ÌôîÏûê Í≥†Ï†ï Ìó§Îçî - ÏùºÎ∞ò ÌôîÏûêÏôÄ ÎèôÏùºÌïú ÌÅ¨Í∏∞ */
        #speaker-fixed-header {
            position: absolute;
            left: 10px;
            top: 10px;
            display: inline-block;
            width: fit-content;
            max-width: calc(100% - 20px);
            
            /* üî• ÏùºÎ∞ò .speaker-nameÍ≥º ÎèôÏùºÌïú padding */
            padding: 3px 15px;
            border-radius: 4px;
            
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            pointer-events: none;
            
            /* Î∂ÄÎìúÎü¨Ïö¥ Ï†ÑÌôò */
            transition: opacity 0.2s ease, transform 0.2s ease;
            
            /* üî• ÏÑ∏Î°ú Ï†ïÎ†¨ ÌÜµÏùº */
            vertical-align: baseline;
        }
        
        body.speaker-fixed-mode #speaker-fixed-header {
            display: inline-block;
        }
        
        #viewer-text {
            position: absolute;
            top: 10px;
            bottom: 10px;
            left: 10px;
            right: 10px;
            width: auto;
            height: auto;
            
            overflow-y: auto;
            overflow-x: hidden;
            overflow-anchor: none;
            scrollbar-gutter: stable both-edges;
            scrollbar-width: thin;
            scrollbar-color: #8884 #0000;
            background: none;
            word-break: break-all;
            white-space: pre-wrap;
            padding: 0;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            text-align: inherit;
            line-height: inherit;
            letter-spacing: 0;
            transition: color 0.2s, opacity 0.5s ease, top 0.2s ease;
            box-sizing: border-box;
            display: block;
            scroll-behavior: auto;
        }
        
        #viewer-text.hidden {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #viewer-text.scroll-disabled {
            overflow-y: hidden !important;
        }
        
        #viewer-text::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        
        #viewer-text::-webkit-scrollbar-thumb {
            background: rgba(180,180,180,0.18);
            border-radius: 4px;
        }
        
        .notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #000, #333);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 13px;
            font-family: 'Pretendard', sans-serif;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10002;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }
        .speaker-line {
            display: block;
            padding: 0;
            margin: 0;
            min-height: auto;
            box-sizing: border-box;
            line-height: inherit;
        }
        
        .speaker-name {
            background: rgba(255, 255, 255, 0.08);
            padding: 3px 15px;
            border-radius: 4px;
            font-weight: 700;
            margin-right: 20px;
            white-space: nowrap;
            line-height: inherit;
            display: inline;
            vertical-align: baseline;
        }
        
        .speaker-divider {
            width: 2px;
            height: 1em;
            background: rgba(255, 255, 255, 0.3);
            margin: 0 20px;
            display: inline-block;
            vertical-align: middle;
        }
        
        .speaker-pipe {
            color: rgba(255, 255, 255, 0.4);
            margin: 0 20px;
            font-weight: 300;
            line-height: inherit;
            display: inline;
        }
        
        .speaker-content {
            display: inline;
            line-height: inherit;
            word-break: break-word;
        }
        
        .speaker-line.no-speaker {
            display: flex;
            align-items: baseline;
        }
        
        .word-bg {
            display: inline-block;
            padding: 2px 6px;
            margin: 0 2px 2px 0;
            border-radius: 4px;
            word-break: inherit;
            transition: background-color 0.2s ease;
            vertical-align: baseline;
        }
        
        .word-bg.minimal {
            padding: 1px 4px;
            margin: 0 1px;
            border-radius: 2px;
        }
        
        .word-bg.full {
            padding: 3px 8px;
            margin: 0 3px 3px 0;
            border-radius: 6px;
        }
        
        .word-bg.continuous {
            display: inline;
            margin: 0;
        }
        
        #margin-adjuster {
            position: fixed;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.2), rgba(90,120,255,0.5));
            border-top: 2px solid #5a78ff;
            cursor: ns-resize;
            z-index: 9999;
            display: none;
            transition: all 0.2s ease;
            user-select: none;
            touch-action: none;
        }
        
        #margin-adjuster.active {
            display: block;
        }
        
        #margin-adjuster:hover {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.4), rgba(90,120,255,0.7));
            border-top-color: #7b9eff;
        }
        
        #margin-adjuster.dragging {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.6), rgba(90,120,255,0.8));
            border-top-color: #fff;
        }
        
        #margin-adjuster::before {
            content: "‚ãÆ‚ãÆ‚ãÆ";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #5a78ff;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body class="show-border">
    <div class="drag-header"></div>
    
    <div id="connection-status" class="connecting">
        <div class="status-dot"></div>
        <span>Ïó∞Í≤∞ Ï§ë...</span>
    </div>
    
    <div id="always-on-top-indicator">
        <span>üìå</span>
        <span>Ìï≠ÏÉÅ ÏúÑ</span>
    </div>
    
    <div id="viewer">
        <!-- üÜï ÌôîÏûê Í≥†Ï†ï Ìó§Îçî (Ï≤´Ïß∏ Ï§Ñ) -->
        <div id="speaker-fixed-header"></div>
        
        <!-- Î≥∏Î¨∏ (ÎëòÏß∏ Ï§ÑÎ∂ÄÌÑ∞) -->
        <div id="viewer-text">Ï±ÑÎÑê Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë...</div>
    </div>
    
    <div id="margin-adjuster"></div>
    
    <div class="notification" id="notification"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script>
const isElectron = typeof window.electronAPI !== 'undefined';

const CONFIG = {
    SOCKET_URL: 'https://live.nuastudio.co.kr',
    RECONNECT_DELAY: 1000,
    RECONNECT_DELAY_MAX: 5000,
    KEEPALIVE_INTERVAL: 15 * 60 * 1000,
    LONG_PRESS_DURATION: 500,
    DOUBLE_TAP_DELAY: 300
};

let channelCode = null;
let longPressTimer = null;
let lastTapTime = 0;
let touchStartTime = 0;
let touchMoved = false;
let socket = null;
let keepaliveInterval = null;
let accumulatedText = '';
let activeStenographer = '1';
let currentActiveInput = '';
let isInitialConnection = true;
let lastTextSentTime = 0;
let lastAccumulatedLength = 0;
let ignoreInputUntil = 0;
let previousInput = '';
let previousDisplay = '';
let isSubtitleHidden = false;
let wasHiddenBeforeInput = false;
let lastRenderedText = '';
let isScrollManual = false;
let isTransparent = false;
let borderVisible = true;
let currentFontSize = 32;
let resizeObserver = null;
let isAlwaysOnTop = false;
let isScrollEnabled = true;
let alwaysOnTopTimer = null;
let marginAdjusterEnabled = false;
let marginOffset = 0;
let isDragging = false;
let startY = 0;
let startOffset = 0;
let maxMargin = 0;

// üî• ÌôîÏûê ÏÉÅÌÉú ÏïàÏ†ïÌôî Î≥ÄÏàò
let lastKnownSpeaker = '';
let lastDetectedSpeaker = '';
let speakerHeaderStable = true;
let speakerFixedModeEnabled = true;
let lastSpeakerFixedMode = false;

let currentSettings = {
    bgColor: '#000000',
    bgAlpha: '100',
    fontColor: '#ffffff',
    fontSize: '32',
    fontFamily: "'Noto Sans KR', sans-serif",
fontWeight: '400',
    letterSpacing: '0',
    lineHeight: '1.5',
    outlineOn: false,
    outlineColor: '#000000',
    outlineWidth: '2',
    shadowOn: false,
    shadowColor: '#000000',
    shadowBlur: '3',
    shadowX: '2',
    shadowY: '2',
    textAlign: 'left',
    verticalAlign: 'top',
    marginTop: '10',
    marginBottom: '10',
    marginLeft: '10',
    marginRight: '10',
    speakerEnabled: true,
    speakerStyle: 'label',
    speakerBgEnabled: true,
    speakerBgColor: '#ffffff',
    speakerBgAlpha: '8',
    colorDividerEnabled: false,
    dividerColor: '#4A90E2',
    subtitleVisible: true,
    marginAdjusterEnabled: false,
    isTransparent: false,
    borderVisible: true,
    alwaysOnTop: false,
    scrollEnabled: true,
    wordBgEnabled: false,
    wordBgColor: '#ffffff',
    wordBgAlpha: '15',
    wordBgStyle: 'subtle',
    wordBgContinuous: false,
    wordBgPaddingY: '2',
    autoLayoutLines: '3'
};

const viewerText = document.getElementById('viewer-text');
const connectionStatus = document.getElementById('connection-status');
const marginAdjuster = document.getElementById('margin-adjuster');
const alwaysOnTopIndicator = document.getElementById('always-on-top-indicator');
const speakerFixedHeader = document.getElementById('speaker-fixed-header');

function initializeBackground() {
    const defaultBg = 'rgba(0, 0, 0, 1)';
    document.body.style.backgroundColor = defaultBg;
    document.getElementById('viewer').style.backgroundColor = defaultBg;
}

function loadLastSettings() {
    const saved = localStorage.getItem('lastUsedSettings');
    if (saved) {
        currentSettings = JSON.parse(saved);
        applySettings(currentSettings);
    }
    
    if (currentSettings.isTransparent !== undefined) {
        isTransparent = currentSettings.isTransparent;
        
        if (isTransparent) {
            const transparentBg = 'rgba(0, 0, 0, 0.004)';
            document.body.style.backgroundColor = transparentBg;
            document.getElementById('viewer').style.backgroundColor = transparentBg;
            document.documentElement.classList.add('transparent-mode');
            document.body.classList.add('transparent-mode');
        }
    }
    
    if (currentSettings.alwaysOnTop) {
        isAlwaysOnTop = true;
    }
}

function saveCurrentSettings() {
    localStorage.setItem('lastUsedSettings', JSON.stringify(currentSettings));
}

function getCurrentSettings() {
    return { ...currentSettings };
}

function measureActualHeight(lineCount) {
    const container = document.createElement('div');
    container.style.visibility = 'hidden';
    container.style.position = 'absolute';
    container.style.left = '-9999px';
    container.style.width = viewerText.offsetWidth + 'px';
    container.style.fontSize = currentSettings.fontSize + 'px';
    container.style.lineHeight = currentSettings.lineHeight;
    container.style.fontFamily = currentSettings.fontFamily;
    
    for (let i = 0; i < lineCount; i++) {
        const line = document.createElement('div');
        line.className = 'speaker-line';
        line.style.lineHeight = currentSettings.lineHeight;
        
        const content = document.createElement('span');
        content.className = 'speaker-content';
        content.textContent = 'Í∞ÄÎÇòÎã§ÎùºÎßàÎ∞îÏÇ¨ÏïÑÏûêÏ∞®Ïπ¥ÌÉÄÌååÌïò';
        line.appendChild(content);
        container.appendChild(line);
    }
    
    viewerText.appendChild(container);
    const height = container.offsetHeight;
    viewerText.removeChild(container);
    
    return Math.ceil(height);
}

function calculateWindowHeight() {
    const lineCount = parseInt(currentSettings.autoLayoutLines) || 3;
    const textHeight = measureActualHeight(lineCount);
    const dragHeader = 20;
    const marginTop = parseInt(currentSettings.marginTop) || 10;
    const marginBottom = parseInt(currentSettings.marginBottom) || 10;
    
    let speakerHeaderHeight = 0;
    if (speakerFixedModeEnabled && currentSettings.speakerStyle === 'label' && speakerFixedHeader.offsetHeight > 0) {
        speakerHeaderHeight = speakerFixedHeader.offsetHeight + 4;
    }
    
    let extraAdjustment = 0;
    switch(lineCount) {
        case 1: extraAdjustment = -12; break;
        case 2: extraAdjustment = -17; break;
        case 3: extraAdjustment = -18; break;
        case 4: extraAdjustment = -18; break;
        case 5: extraAdjustment = -19; break;
        default: extraAdjustment = -18;
    }
    
    const total = textHeight + marginTop + marginBottom + dragHeader + speakerHeaderHeight + extraAdjustment;
    
    console.log('[AutoPosition] Height calculation:', {
        fontSize: currentSettings.fontSize,
        lineHeight: currentSettings.lineHeight,
        lineCount: lineCount,
        textHeight: textHeight,
        margins: marginTop + marginBottom,
        speakerHeaderHeight: speakerHeaderHeight,
        extraAdjustment: extraAdjustment,
        total: total
    });
    
    return Math.max(80, Math.floor(total));
}

function autoPositionWindow(position) {
    if (!isElectron) return;
    
    try {
        const lineCount = parseInt(currentSettings.autoLayoutLines) || 3;
        const newHeight = calculateWindowHeight();
        
        console.log('[AutoPosition] Positioning window:', {
            height: newHeight,
            position: position,
            lines: lineCount
        });
        
        if (window.electronAPI && window.electronAPI.resizeWindow) {
            window.electronAPI.resizeWindow(0, newHeight, position);
            showNotification(`${position === 'top' ? 'ÏÉÅÎã®' : 'ÌïòÎã®'} ÎßûÏ∂§ (${lineCount}Ï§Ñ)`);
        }
    } catch (error) {
        console.error('[AutoPosition] Error:', error);
    }
}

function applyMargins(smooth = false) {
    const mTop = parseInt(currentSettings.marginTop) || 10;
    const mBottom = parseInt(currentSettings.marginBottom) || 10;
    const mLeft = parseInt(currentSettings.marginLeft) || 10;
    const mRight = parseInt(currentSettings.marginRight) || 10;
    
    let adjustedTop = mTop;
    const isFixedMode = document.body.classList.contains('speaker-fixed-mode');
    
    if (isFixedMode) {
        const headerHeight = speakerFixedHeader.offsetHeight || 0;
        adjustedTop = mTop + headerHeight + 4;
    }
    
    if (smooth && lastSpeakerFixedMode !== isFixedMode) {
        const scrollRatio = viewerText.scrollTop / (viewerText.scrollHeight - viewerText.clientHeight + 0.001);
        
        viewerText.style.top = `${adjustedTop}px`;
        viewerText.style.bottom = `${mBottom}px`;
        viewerText.style.left = `${mLeft}px`;
        viewerText.style.right = `${mRight}px`;
        
        requestAnimationFrame(() => {
            const newScrollTop = scrollRatio * (viewerText.scrollHeight - viewerText.clientHeight);
            viewerText.scrollTop = Math.max(0, newScrollTop);
        });
        
        lastSpeakerFixedMode = isFixedMode;
    } else {
        viewerText.style.top = `${adjustedTop}px`;
        viewerText.style.bottom = `${mBottom}px`;
        viewerText.style.left = `${mLeft}px`;
        viewerText.style.right = `${mRight}px`;
    }
}

function applySettings(settings) {
    // ‚úÖ Í∏∞Ï°¥ Ìà¨Î™Ö ÏÉÅÌÉú Î≥¥Ï°¥
    const preservedTransparent = isTransparent;
    
    currentSettings = { ...currentSettings, ...settings };
    
    // ‚úÖ settingsÏóê isTransparentÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ ÏÉÅÌÉú Ïú†ÏßÄ
    if (settings.isTransparent === undefined) {
        isTransparent = preservedTransparent;
        currentSettings.isTransparent = preservedTransparent;
    } else {
        isTransparent = settings.isTransparent;
    }
    
    if (settings.bgColor && settings.bgAlpha !== undefined) {
        const bgHex = settings.bgColor;
        const alpha = parseInt(settings.bgAlpha) / 100;
        const safeAlpha = Math.max(alpha, 0.01);
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${safeAlpha})`;
        
        // ‚úÖ Ìà¨Î™Ö Î™®Îìú Ï≤¥ÌÅ¨ Ï∂îÍ∞Ä
        if (isTransparent) {
            const transparentBg = 'rgba(0, 0, 0, 0.004)';
            document.body.style.backgroundColor = transparentBg;
            document.getElementById('viewer').style.backgroundColor = transparentBg;
        } else {
            document.getElementById('viewer').style.backgroundColor = bgRgba;
            document.body.style.backgroundColor = bgRgba;
        }
    }
    
    if (settings.fontSize) {
        currentFontSize = parseInt(settings.fontSize);
        viewerText.style.fontSize = settings.fontSize + 'px';
        speakerFixedHeader.style.fontSize = settings.fontSize + 'px';
    }
    
    if (settings.fontColor) {
        viewerText.style.color = settings.fontColor;
    }
    
    if (settings.fontFamily) {
        viewerText.style.fontFamily = settings.fontFamily;
        speakerFixedHeader.style.fontFamily = settings.fontFamily;
    }
  
  if (settings.fontWeight) {
        viewerText.style.fontWeight = settings.fontWeight;
        speakerFixedHeader.style.fontWeight = settings.fontWeight;
    }

    if (settings.letterSpacing !== undefined) {
        viewerText.style.letterSpacing = settings.letterSpacing + 'px';
        speakerFixedHeader.style.letterSpacing = settings.letterSpacing + 'px';
    }
    
    if (settings.lineHeight) {
        viewerText.style.lineHeight = parseFloat(settings.lineHeight) + 'em';
        speakerFixedHeader.style.lineHeight = parseFloat(settings.lineHeight) + 'em';
    }
    
    if (settings.textAlign) {
        viewerText.style.textAlign = settings.textAlign;
    }
    
    if (settings.verticalAlign) {
        scrollToBottom();
    }
    
    if (settings.marginTop !== undefined && settings.marginBottom !== undefined && 
        settings.marginLeft !== undefined && settings.marginRight !== undefined) {
        applyMargins();
        scrollToBottom();
    }
    
    let textShadow = '';
    if (settings.outlineOn && parseFloat(settings.outlineWidth) > 0) {
        const outline = `-${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, -${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}`;
        textShadow = outline;
    }
    if (settings.shadowOn && parseFloat(settings.shadowBlur) > 0) {
        const dropShadow = `${settings.shadowX}px ${settings.shadowY}px ${settings.shadowBlur}px ${settings.shadowColor}`;
        textShadow = textShadow ? textShadow + ', ' + dropShadow : dropShadow;
    }
    viewerText.style.textShadow = textShadow;
    
    if (settings.subtitleVisible !== undefined) {
        isSubtitleHidden = !settings.subtitleVisible;
        if (isSubtitleHidden) {
            viewerText.classList.add('hidden');
        } else {
            viewerText.classList.remove('hidden');
        }
    }
    
    if (settings.marginAdjusterEnabled !== undefined) {
        marginAdjusterEnabled = settings.marginAdjusterEnabled;
        if (marginAdjusterEnabled) {
            marginAdjuster.classList.add('active');
            marginAdjuster.style.bottom = marginOffset + 'px';
        } else {
            marginAdjuster.classList.remove('active');
        }
    }
    
    if (settings.alwaysOnTop !== undefined) {
        isAlwaysOnTop = settings.alwaysOnTop;
    }
    
    if (settings.scrollEnabled !== undefined) {
        isScrollEnabled = settings.scrollEnabled;
        if (isScrollEnabled) {
            viewerText.classList.remove('scroll-disabled');
        } else {
            viewerText.classList.add('scroll-disabled');
        }
    }
    
    updateSpeakerFixedHeaderStyle();
    
    lastRenderedText = '';
    const currentText = accumulatedText + currentActiveInput;
    updateDisplay(currentText, true);
    
    saveCurrentSettings();
}

function updateSpeakerFixedHeaderStyle() {
    if (!speakerFixedModeEnabled) return;
    
    const speakerBgEnabled = currentSettings.speakerBgEnabled;
    const speakerBgColor = currentSettings.speakerBgColor || '#ffffff';
    const speakerBgAlpha = parseInt(currentSettings.speakerBgAlpha || '8') / 100;
    
    if (speakerBgEnabled) {
        const r = parseInt(speakerBgColor.slice(1, 3), 16);
        const g = parseInt(speakerBgColor.slice(3, 5), 16);
        const b = parseInt(speakerBgColor.slice(5, 7), 16);
        speakerFixedHeader.style.background = `rgba(${r}, ${g}, ${b}, ${speakerBgAlpha})`;
    } else {
        speakerFixedHeader.style.background = 'rgba(255, 255, 255, 0.08)';
    }
}

function scrollToBottom() {
    requestAnimationFrame(() => {
        viewerText.scrollTop = viewerText.scrollHeight;
    });
}

function initSocket() {
    console.log('[Socket] Ï¥àÍ∏∞Ìôî:', CONFIG.SOCKET_URL);
    
    socket = io(CONFIG.SOCKET_URL, {
        transports: ['websocket', 'polling'],
        upgrade: true,
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: CONFIG.RECONNECT_DELAY,
        reconnectionDelayMax: CONFIG.RECONNECT_DELAY_MAX,
        timeout: 20000,
        forceNew: true
    });
    
    socket.on('connect', () => {
        console.log('[Socket] Ïó∞Í≤∞ ÏÑ±Í≥µ');
        updateConnectionStatus('connected', 'Ïó∞Í≤∞Îê®');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('connect_error', (error) => {
        console.error('[Socket] Ïó∞Í≤∞ ÏóêÎü¨:', error.message);
        updateConnectionStatus('disconnected', 'Ïó∞Í≤∞ Ïã§Ìå®');
    });
    
    socket.on('disconnect', (reason) => {
        console.log('[Socket] Ïó∞Í≤∞ ÎÅäÍπÄ:', reason);
        updateConnectionStatus('disconnected', 'Ïó∞Í≤∞ ÎÅäÍπÄ');
        stopKeepalive();
    });
    
    socket.on('reconnect', () => {
        console.log('[Socket] Ïû¨Ïó∞Í≤∞ ÏÑ±Í≥µ');
        updateConnectionStatus('connected', 'Ïû¨Ïó∞Í≤∞Îê®');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('joined_channel', (data) => {
        console.log('[Channel] Ï∞∏Í∞Ä ÏÑ±Í≥µ');
        viewerText.textContent = 'ÏûêÎßâ ÎåÄÍ∏∞ Ï§ë...';
        socket.emit('request_sync', { channel: channelCode });
    });
    
    socket.on('channel_state', (data) => {
        console.log('[State] Ï±ÑÎÑê ÏÉÅÌÉú:', data);
        if (data.state) {
            if (data.state.activeStenographer) {
                activeStenographer = data.state.activeStenographer === 'steno1' ? '1' : '2';
            }
            if (data.state.accumulatedText !== undefined) {
                accumulatedText = data.state.accumulatedText;
                currentActiveInput = '';
                previousInput = '';
                previousDisplay = '';
                updateDisplay(accumulatedText, true);
            }
        }
    });
    
    socket.on('sync_accumulated', (data) => {
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
        
        if (data.activeStenographer) {
            activeStenographer = data.activeStenographer === 'steno1' ? '1' : '2';
        }
    });
    
    socket.on('steno_input', (data) => {
        const roleNumber = data.role === 'steno1' ? '1' : data.role === 'steno2' ? '2' : data.role;
        
        if (roleNumber === activeStenographer) {
            const now = Date.now();
            const inputLength = (data.text || '').length;
            
            if (now < ignoreInputUntil && inputLength < lastAccumulatedLength - 10) {
                return;
            }
            
            currentActiveInput = data.text || '';
            const fullText = accumulatedText + currentActiveInput;
            updateDisplay(fullText, false);
        }
    });
    
    socket.on('switch_role', (data) => {
        activeStenographer = data.newActive === 'steno1' ? '1' : '2';
        
        if (data.accumulatedText !== undefined) {
            accumulatedText = data.accumulatedText;
            currentActiveInput = '';
            previousInput = '';
            previousDisplay = '';
            updateDisplay(accumulatedText, true);
        }
    });
    
    socket.on('text_sent', (data) => {
        lastTextSentTime = Date.now();
        lastAccumulatedLength = (data.accumulatedText || '').length;
        ignoreInputUntil = Date.now() + 1000;
        
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
    });
    
    socket.on('clear_text', () => {
        accumulatedText = '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        lastRenderedText = '';
        lastKnownSpeaker = '';
        lastDetectedSpeaker = '';
        speakerHeaderStable = true;
        updateDisplay('', true);
    });
}

function joinChannel() {
    if (!socket || !socket.connected) return;
    
    console.log('[Channel] Ï∞∏Í∞Ä ÏöîÏ≤≠:', channelCode);
    socket.emit('join_channel', {
        channel: channelCode,
        role: 'viewer',
        requestSync: true
    });
}

function startKeepalive() {
    stopKeepalive();
    keepaliveInterval = setInterval(() => {
        if (socket && socket.connected) {
            socket.emit('keepalive', { channel: channelCode, timestamp: Date.now() });
        }
    }, CONFIG.KEEPALIVE_INTERVAL);
}

function stopKeepalive() {
    if (keepaliveInterval) {
        clearInterval(keepaliveInterval);
        keepaliveInterval = null;
    }
}

function updateConnectionStatus(status, message) {
    connectionStatus.className = status;
    connectionStatus.querySelector('span').textContent = message;
    
    if (status === 'connected' && isInitialConnection) {
        setTimeout(() => {
            connectionStatus.style.opacity = '0';
            isInitialConnection = false;
        }, 3000);
    } else {
        connectionStatus.style.opacity = '1';
    }
}

function updateDisplay(text, isImmediate = false) {
    if (isSubtitleHidden && text && text.trim()) {
        if (wasHiddenBeforeInput || text.length > (previousInput ? previousInput.length : 0)) {
            toggleSubtitleVisibility(true);
            wasHiddenBeforeInput = false;
        }
    }
    
    let displayText = text;
    
    if (isImmediate) {
        previousInput = '';
        previousDisplay = '';
    } else {
        const isBackspace = previousInput.length > text.length;
        const onlySpaceRemoved = isBackspace && previousInput.endsWith(' ') && text === previousInput.slice(0, -1);
        
        if (text.length > 0) {
            if (text.endsWith(' ') || text.endsWith('\n')) {
                displayText = text;
            } else if (onlySpaceRemoved && previousDisplay) {
                displayText = previousDisplay.trimEnd();
            } else {
                const lastSpace = text.lastIndexOf(' ');
                const lastNewline = text.lastIndexOf('\n');
                const lastDelimiter = Math.max(lastSpace, lastNewline);
                
                if (lastDelimiter > -1) {
                    displayText = text.substring(0, lastDelimiter + 1);
                } else {
                    displayText = '';
                }
            }
        }
        
        previousInput = text;
        previousDisplay = displayText;
    }
    
    if (!currentActiveInput || currentActiveInput.trim().length === 0) {
        displayText = displayText.replace(/\n+$/, '');
    }
    
    const lines = displayText.split('\n');
    if (lines.length > 10000) {
        console.log('[Performance] Ï§Ñ Ïàò Ï¥àÍ≥º:', lines.length, '‚Üí 8,000Ï§ÑÎ°ú Ï†ïÎ¶¨');
        displayText = lines.slice(-8000).join('\n');
        if (isImmediate) {
            accumulatedText = displayText;
        }
    }
    
    const finalDisplayText = displayText || (channelCode ? 'ÏûêÎßâ ÎåÄÍ∏∞ Ï§ë...' : 'Ï±ÑÎÑê Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë...');
    if (finalDisplayText === lastRenderedText) return;
    
    renderFormattedText(finalDisplayText);
    lastRenderedText = finalDisplayText;
    
    if (!isScrollManual) {
        scrollToBottom();
    }
}

viewerText.addEventListener('wheel', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

viewerText.addEventListener('touchstart', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

function detectLastSpeaker(text) {
    const lines = text.split('\n');
    for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (line.startsWith('-') && line.includes(': ')) {
            const colonIndex = line.indexOf(': ');
            const speaker = line.substring(1, colonIndex).trim();
            return speaker;
        }
    }
    return '';
}

// üî• ÌôîÏûê ÏÉÅÌÉú ÏïàÏ†ïÌôî
function shouldShowFixedHeader(text) {
    if (!speakerFixedModeEnabled) return false;
    if (currentSettings.speakerStyle !== 'label') return false;
    
    const visibleLines = parseInt(currentSettings.autoLayoutLines) || 3;
    const lines = text.split('\n').slice(-visibleLines);
    
    const speakers = new Set();
    lines.forEach(line => {
        const match = line.match(/^-(.+?):/);
        if (match) speakers.add(match[1].trim());
    });
    
    // ÌôîÏûê 1Î™Ö Í∞êÏßÄ
    if (speakers.size === 1) {
        const newSpeaker = Array.from(speakers)[0];
        if (newSpeaker !== lastDetectedSpeaker) {
            lastDetectedSpeaker = newSpeaker;
        }
        speakerHeaderStable = true;
        return true;
    } 
    // ÌôîÏûê ÏóÜÏùå ‚Üí ÎßàÏßÄÎßâ ÌôîÏûê Ïú†ÏßÄ
    else if (speakers.size === 0) {
        return speakerHeaderStable && lastDetectedSpeaker !== '';
    } 
    // ÌôîÏûê 2Î™Ö Ïù¥ÏÉÅ ‚Üí Ìó§Îçî Ïà®ÍπÄ
    else {
        speakerHeaderStable = false;
        return false;
    }
}

function updateSpeakerFixedHeader(speaker, shouldShow) {
    if (!shouldShow) {
        document.body.classList.remove('speaker-fixed-mode');
        requestAnimationFrame(() => {
            applyMargins(true);
        });
        return;
    }
    
    if (speaker) {
        lastKnownSpeaker = speaker;
    }
    
    if (lastKnownSpeaker) {
        speakerFixedHeader.textContent = lastKnownSpeaker;
        document.body.classList.add('speaker-fixed-mode');
        
        // üî• Í∞ïÏ†ú Î†àÏù¥ÏïÑÏõÉ Î¶¨ÌîåÎ°úÏö∞
        void speakerFixedHeader.offsetHeight;
        
        requestAnimationFrame(() => {
            applyMargins(true);
        });
    } else {
        document.body.classList.remove('speaker-fixed-mode');
        requestAnimationFrame(() => {
            applyMargins(true);
        });
    }
}

function renderFormattedText(text) {
    const lines = text.split('\n');
    const speakerEnabled = currentSettings.speakerEnabled;
    const speakerStyle = currentSettings.speakerStyle || 'divider';
    const useBg = currentSettings.speakerBgEnabled;
    const useColorDivider = currentSettings.colorDividerEnabled;
    const bgAlpha = parseInt(currentSettings.speakerBgAlpha) / 100;
    const currentLineHeight = viewerText.style.lineHeight;
    
    const useWordBg = currentSettings.wordBgEnabled;
    const wordBgColor = currentSettings.wordBgColor;
    const wordBgAlpha = parseInt(currentSettings.wordBgAlpha || '15') / 100;
    const wordBgStyle = currentSettings.wordBgStyle || 'subtle';
    const wordBgContinuous = currentSettings.wordBgContinuous || false;
    const wordBgPaddingY = parseFloat(currentSettings.wordBgPaddingY || '2');
    
    const lastSpeaker = detectLastSpeaker(text);
    const showFixedHeader = shouldShowFixedHeader(text);
    updateSpeakerFixedHeader(lastSpeaker, showFixedHeader);
    
    viewerText.innerHTML = '';
    
    lines.forEach(line => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'speaker-line';
        lineDiv.style.lineHeight = currentLineHeight;
        
        if (speakerEnabled && line.startsWith('-') && line.includes(': ')) {
            const colonIndex = line.indexOf(': ');
            const speaker = line.substring(1, colonIndex).trim();
            const content = line.substring(colonIndex + 2);
            
            if (speakerStyle === 'label' && showFixedHeader) {
                lineDiv.classList.add('no-speaker');
                const contentSpan = document.createElement('span');
                contentSpan.className = 'speaker-content';
                
                if (useWordBg && content.trim()) {
                    applyWordBackground(contentSpan, content, wordBgColor, wordBgAlpha, wordBgStyle, wordBgContinuous, wordBgPaddingY);
                } else {
                    contentSpan.textContent = content || '\u200B';
                }
                
                lineDiv.appendChild(contentSpan);
            } else {
                const speakerSpan = document.createElement('span');
                speakerSpan.className = 'speaker-name';
                speakerSpan.textContent = speaker;
                
                if (useBg) {
                    const bgColor = currentSettings.speakerBgColor;
                    const r = parseInt(bgColor.slice(1, 3), 16);
                    const g = parseInt(bgColor.slice(3, 5), 16);
                    const b = parseInt(bgColor.slice(5, 7), 16);
                    speakerSpan.style.background = `rgba(${r}, ${g}, ${b}, ${bgAlpha})`;
                } else {
                    speakerSpan.style.background = 'transparent';
                }
                
                lineDiv.appendChild(speakerSpan);
                
                if (speakerStyle === 'divider') {
                    const divider = document.createElement('div');
                    divider.className = 'speaker-divider';
                    if (useColorDivider) {
                        divider.style.background = currentSettings.dividerColor;
                    }
                    lineDiv.appendChild(divider);
                } else if (speakerStyle === 'pipe') {
                    const pipe = document.createElement('span');
                    pipe.className = 'speaker-pipe';
                    pipe.textContent = '|';
                    if (useColorDivider) {
                        pipe.style.color = currentSettings.dividerColor;
                    }
                    lineDiv.appendChild(pipe);
                } else if (speakerStyle === 'minimal') {
                    const divider = document.createElement('div');
                    divider.className = 'speaker-divider';
                    divider.style.width = '1px';
                    divider.style.margin = '0 25px';
                    if (useColorDivider) {
                        divider.style.background = currentSettings.dividerColor;
                    } else {
                        divider.style.background = 'rgba(255, 255, 255, 0.2)';
                    }
                    lineDiv.appendChild(divider);
                }
                
                const contentSpan = document.createElement('span');
                contentSpan.className = 'speaker-content';
                
                if (useWordBg && content.trim()) {
                    applyWordBackground(contentSpan, content, wordBgColor, wordBgAlpha, wordBgStyle, wordBgContinuous, wordBgPaddingY);
                } else {
                    contentSpan.textContent = content || '\u200B';
                }
                
                lineDiv.appendChild(contentSpan);
            }
        } else {
            lineDiv.classList.add('no-speaker');
            const contentSpan = document.createElement('span');
            contentSpan.className = 'speaker-content';
            
            if (useWordBg && line.trim()) {
                applyWordBackground(contentSpan, line, wordBgColor, wordBgAlpha, wordBgStyle, wordBgContinuous, wordBgPaddingY);
            } else {
                contentSpan.textContent = line || '\u200B';
            }
            
            lineDiv.appendChild(contentSpan);
        }
        
        viewerText.appendChild(lineDiv);
    });
}

function applyWordBackground(container, text, wordBgColor, wordBgAlpha, wordBgStyle, continuous, paddingY) {
    const r = parseInt(wordBgColor.slice(1, 3), 16);
    const g = parseInt(wordBgColor.slice(3, 5), 16);
    const b = parseInt(wordBgColor.slice(5, 7), 16);
    const bgColorRgba = `rgba(${r}, ${g}, ${b}, ${wordBgAlpha})`;
    
    if (continuous) {
        const span = document.createElement('span');
        span.className = `word-bg ${wordBgStyle} continuous`;
        span.textContent = text;
        span.style.backgroundColor = bgColorRgba;
        span.style.paddingTop = paddingY + 'px';
        span.style.paddingBottom = paddingY + 'px';
        container.appendChild(span);
    } else {
        const words = text.split(/(\s+)/);
        words.forEach(word => {
            if (word.trim()) {
                const wordSpan = document.createElement('span');
                wordSpan.className = `word-bg ${wordBgStyle}`;
                wordSpan.textContent = word;
                wordSpan.style.backgroundColor = bgColorRgba;
                wordSpan.style.paddingTop = paddingY + 'px';
                wordSpan.style.paddingBottom = paddingY + 'px';
                container.appendChild(wordSpan);
            } else if (word) {
                container.appendChild(document.createTextNode(word));
            }
        });
    }
}

function toggleSubtitleVisibility(forceShow = null) {
    if (forceShow !== null) {
        isSubtitleHidden = !forceShow;
    } else {
        isSubtitleHidden = !isSubtitleHidden;
    }
    
    if (isSubtitleHidden) {
        viewerText.classList.add('hidden');
        wasHiddenBeforeInput = true;
        currentSettings.subtitleVisible = false;
        showNotification('ÏûêÎßâ Ïà®ÍπÄ');
    } else {
        viewerText.classList.remove('hidden');
        wasHiddenBeforeInput = false;
        currentSettings.subtitleVisible = true;
        showNotification('ÏûêÎßâ ÌëúÏãú');
    }
    saveCurrentSettings();
}

function toggleScrollEnabled() {
    isScrollEnabled = !isScrollEnabled;
    currentSettings.scrollEnabled = isScrollEnabled;
    
    if (isScrollEnabled) {
        viewerText.classList.remove('scroll-disabled');
        showNotification('Ïä§ÌÅ¨Î°§ ÌôúÏÑ±Ìôî');
    } else {
        viewerText.classList.add('scroll-disabled');
        showNotification('Ïä§ÌÅ¨Î°§ ÎπÑÌôúÏÑ±Ìôî');
    }
    
    saveCurrentSettings();
}

function toggleAlwaysOnTop() {
    if (isElectron) {
        window.electronAPI.toggleAlwaysOnTop();
    }
}

function updateAlwaysOnTopIndicator(state, showTemporary = true) {
    if (alwaysOnTopTimer) {
        clearTimeout(alwaysOnTopTimer);
        alwaysOnTopTimer = null;
    }
    
    if (state) {
        alwaysOnTopIndicator.classList.add('active');
        if (showTemporary) {
            alwaysOnTopTimer = setTimeout(() => {
                alwaysOnTopIndicator.classList.remove('active');
                alwaysOnTopTimer = null;
            }, 3000);
        }
    } else {
        alwaysOnTopIndicator.classList.remove('active');
    }
}

function saveTextToFile() {
    const fullText = accumulatedText || 'Ï†ÄÏû•Ìï† ÌÖçÏä§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `ÏûêÎßâ_${channelCode}_${timestamp}.txt`;
    
    const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showNotification(`ÌÖçÏä§Ìä∏ Ï†ÄÏû•Îê®: ${filename}`);
}

function toggleTransparent() {
    console.log('[Transparent] Toggle called, current:', isTransparent);
    
    isTransparent = !isTransparent;
    currentSettings.isTransparent = isTransparent;
    
    if (isTransparent) {
        document.documentElement.classList.add('transparent-mode');
        document.body.classList.add('transparent-mode');
        
        const transparentBg = 'rgba(0, 0, 0, 0.004)';
        document.body.style.backgroundColor = transparentBg;
        document.getElementById('viewer').style.backgroundColor = transparentBg;
        
        if (isElectron) window.electronAPI.toggleTransparent(true);
        showNotification('Ìà¨Î™Ö Î™®Îìú ÏºúÏßê');
    } else {
        document.documentElement.classList.remove('transparent-mode');
        document.body.classList.remove('transparent-mode');
        
        const bgHex = currentSettings.bgColor || '#000000';
        const alpha = parseInt(currentSettings.bgAlpha || '100') / 100;
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        
        document.body.style.backgroundColor = bgRgba;
        document.getElementById('viewer').style.backgroundColor = bgRgba;
        
        if (isElectron) window.electronAPI.toggleTransparent(false);
        showNotification('Ìà¨Î™Ö Î™®Îìú Í∫ºÏßê');
    }
    
    saveCurrentSettings();
}

function toggleBorder() {
    console.log('[Border] Toggle called, current:', borderVisible);
    
    borderVisible = !borderVisible;
    
    if (borderVisible) {
        document.body.classList.add('show-border');
        showNotification('ÌÖåÎëêÎ¶¨ ÌëúÏãú');
        console.log('[Border] ON');
    } else {
        document.body.classList.remove('show-border');
        showNotification('ÌÖåÎëêÎ¶¨ Ïà®ÍπÄ');
        console.log('[Border] OFF');
    }
    
    currentSettings.borderVisible = borderVisible;
    saveCurrentSettings();
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen?.();
    } else {
        document.exitFullscreen?.();
    }
}

function handleQuickAction(action) {
    console.log('[QuickAction] Received:', action);
    
    switch(action) {
        case 'font-up':
            currentFontSize = Math.min(200, currentFontSize + 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`Í∏ÄÏûê ÌÅ¨Í∏∞: ${currentFontSize}px`);
            break;
        case 'font-down':
            currentFontSize = Math.max(10, currentFontSize - 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`Í∏ÄÏûê ÌÅ¨Í∏∞: ${currentFontSize}px`);
            break;
        case 'transparent':
            toggleTransparent();
            break;
        case 'border':
            console.log('[QuickAction] Border action triggered');
            toggleBorder();
            break;
        case 'subtitle-toggle':
            toggleSubtitleVisibility();
            break;
        case 'scroll-toggle':
            toggleScrollEnabled();
            break;
        case 'always-on-top':
            toggleAlwaysOnTop();
            break;
        case 'save-text':
            saveTextToFile();
            break;
        case 'fullscreen':
            toggleFullscreen();
            break;
        case 'auto-position-top':
            autoPositionWindow('top');
            break;
        case 'auto-position-bottom':
            autoPositionWindow('bottom');
            break;
        case 'exit':
            console.log('[Exit] Exit action triggered');
            if (isElectron) {
                window.electronAPI.confirmExit().then(confirmed => {
                    console.log('[Exit] Confirmation result:', confirmed);
                    if (confirmed) {
                        console.log('[Exit] Closing app...');
                        try {
                            window.electronAPI.closeQuickMenu();
                        } catch (e) {
                            console.log('[Exit] Could not close Quick Menu:', e);
                        }
                        setTimeout(() => {
                            try {
                                window.electronAPI.exitApp();
                            } catch (err) {
                                console.error('[Exit] exitApp failed, using window.close:', err);
                                window.close();
                            }
                        }, 100);
                    } else {
                        console.log('[Exit] User cancelled exit');
                    }
                }).catch(err => {
                    console.error('[Exit] Error during exit confirmation:', err);
                    if (confirm('Ïï±ÏùÑ Ï¢ÖÎ£åÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                        try {
                            window.electronAPI.exitApp();
                        } catch (e) {
                            window.close();
                        }
                    }
                });
            } else {
                if (confirm('Ïï±ÏùÑ Ï¢ÖÎ£åÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                    window.close();
                }
            }
            break;
    }
}

function showNotification(message, duration = 2000) {
    const notif = document.getElementById('notification');
    notif.textContent = message;
    notif.classList.add('show');
    setTimeout(() => notif.classList.remove('show'), duration);
}

document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (isElectron) {
        window.electronAPI.openQuickMenu();
    }
});

document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    switch(e.key) {
        case 'Enter':
            e.preventDefault();
            toggleFullscreen();
            break;
        case 'h':
        case 'H':
            e.preventDefault();
            toggleSubtitleVisibility();
            break;
        case 's':
        case 'S':
            e.preventDefault();
            toggleScrollEnabled();
            break;
        case 't':
        case 'T':
            e.preventDefault();
            toggleAlwaysOnTop();
            break;
        case 'ArrowUp':
            e.preventDefault();
            handleQuickAction('font-up');
            break;
        case 'ArrowDown':
            e.preventDefault();
            handleQuickAction('font-down');
            break;
    }
});

document.body.addEventListener('dblclick', e => {
    console.log('[DblClick] Double click detected');
    toggleBorder();
});

function setupTouchEvents() {
    viewerText.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchMoved = false;
        
        longPressTimer = setTimeout(() => {
            if (!touchMoved && isElectron) {
                window.electronAPI.openQuickMenu();
            }
        }, CONFIG.LONG_PRESS_DURATION);
    }, { passive: true });
    
    viewerText.addEventListener('touchmove', () => {
        touchMoved = true;
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }, { passive: true });
    
    viewerText.addEventListener('touchend', (e) => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        
        if (!touchMoved) {
            const now = Date.now();
            if (now - lastTapTime < CONFIG.DOUBLE_TAP_DELAY) {
                toggleFullscreen();
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: true });
}

function setupMarginAdjusterTouch() {
    marginAdjuster.addEventListener('mousedown', startDrag);
    marginAdjuster.addEventListener('touchstart', startDrag, { passive: false });
    
    function startDrag(e) {
        if (e.type === 'touchstart') {
            e.preventDefault();
            startY = e.touches[0].clientY;
        } else {
            startY = e.clientY;
        }
        
        startOffset = marginOffset;
        isDragging = true;
        marginAdjuster.classList.add('dragging');
        
        const viewerHeight = document.getElementById('viewer').offsetHeight;
        maxMargin = viewerHeight - 100;
        
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('touchend', stopDrag);
    }
    
    function onDrag(e) {
        if (!isDragging) return;
        
        let currentY;
        if (e.type === 'touchmove') {
            e.preventDefault();
            currentY = e.touches[0].clientY;
        } else {
            currentY = e.clientY;
        }
        
        const deltaY = startY - currentY;
        marginOffset = Math.max(0, Math.min(maxMargin, startOffset + deltaY));
        
        marginAdjuster.style.bottom = marginOffset + 'px';
        
        const currentMarginBottom = parseInt(currentSettings.marginBottom) || 10;
        const newMarginBottom = currentMarginBottom + marginOffset;
        
        const mTop = parseInt(currentSettings.marginTop) || 10;
        const mLeft = parseInt(currentSettings.marginLeft) || 10;
        const mRight = parseInt(currentSettings.marginRight) || 10;
        
        viewerText.style.top = `${mTop}px`;
        viewerText.style.bottom = `${newMarginBottom}px`;
        viewerText.style.left = `${mLeft}px`;
        viewerText.style.right = `${mRight}px`;
        
        viewerText.scrollTop = viewerText.scrollHeight;
        
        currentSettings.marginBottom = newMarginBottom.toString();
    }
    
    function stopDrag() {
        if (!isDragging) return;
        
        isDragging = false;
        marginAdjuster.classList.remove('dragging');
        
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', stopDrag);
        
        saveCurrentSettings();
        
        marginOffset = 0;
        marginAdjuster.style.bottom = '0px';
        
        scrollToBottom();
    }
}

function handleFullscreenChange() {
    if (document.fullscreenElement) {
        showNotification('Ï†ÑÏ≤¥ÌôîÎ©¥ Î™®Îìú');
    } else {
        showNotification('Ï†ÑÏ≤¥ÌôîÎ©¥ Ìï¥Ï†ú');
    }
}

if (isElectron) {
    window.electronAPI.on('deep-link-join', (data) => {
        const { channel, token } = data;
        console.log('[DeepLink] Ï±ÑÎÑê Ï∞∏Í∞Ä ÏöîÏ≤≠:', channel);
        
        if (channel) {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            channelCode = channel;
            initSocket();
        }
    });
    
    window.electronAPI.on('channel-code', (code) => {
        console.log('[Legacy] Ï±ÑÎÑê ÏΩîÎìú ÏàòÏã†:', code);
        
        if (socket) {
            socket.disconnect();
            socket = null;
        }
        channelCode = code;
        initSocket();
    });
    
    window.electronAPI.on('update-settings', (settings) => {
        applySettings(settings);
    });
    
    window.electronAPI.on('send-current-settings-to-menu', () => {
        window.electronAPI.sendSettingsToMenu(getCurrentSettings());
    });
    
    window.electronAPI.on('quick-action', (action) => {
        handleQuickAction(action);
    });
    
    window.electronAPI.on('always-on-top-changed', (newState) => {
        isAlwaysOnTop = newState;
        currentSettings.alwaysOnTop = newState;
        
        if (newState) {
            showNotification('Ìï≠ÏÉÅ ÏúÑ ÌôúÏÑ±Ìôî');
            updateAlwaysOnTopIndicator(true, true);
        } else {
            showNotification('Ìï≠ÏÉÅ ÏúÑ ÎπÑÌôúÏÑ±Ìôî');
            updateAlwaysOnTopIndicator(false, false);
        }
        
        saveCurrentSettings();
    });
}

window.addEventListener('load', () => {
    initializeBackground();
    
    setupTouchEvents();
    
    setupMarginAdjusterTouch();
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    
    resizeObserver = new ResizeObserver(() => {
        if (!isScrollManual) {
            scrollToBottom();
        }
    });
    resizeObserver.observe(viewerText);
    
    loadLastSettings();
    
    console.log('[Electron] Ï±ÑÎÑê Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë...');
    updateConnectionStatus('connecting', 'Ï±ÑÎÑê Ïó∞Í≤∞ ÎåÄÍ∏∞ Ï§ë...');
    
    setTimeout(() => {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            showNotification('Íæπ ÌÑ∞Ïπò: ÏÑ§Ï†ï, ÎçîÎ∏î ÌÑ∞Ïπò: Ï†ÑÏ≤¥ÌôîÎ©¥, HÌÇ§: ÏûêÎßâ Ïà®ÍπÄ', 5000);
        } else {
            showNotification('Îã®Ï∂ïÌÇ§: Enter(Ï†ÑÏ≤¥ÌôîÎ©¥), ‚Üë‚Üì(Í∏ÄÏûêÌÅ¨Í∏∞), H(ÏûêÎßâ), S(Ïä§ÌÅ¨Î°§), T(Ìï≠ÏÉÅÏúÑ)', 5000);
        }
    }, 3000);
});

window.addEventListener('beforeunload', () => {
    stopKeepalive();
    if (socket) socket.disconnect();
    if (resizeObserver) resizeObserver.disconnect();
    if (alwaysOnTopTimer) clearTimeout(alwaysOnTopTimer);
});
    </script>
</body>
</html>

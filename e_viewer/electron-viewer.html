<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>NUA ìë§‰ ë·°ì–´</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=Jua&family=Do+Hyeon&family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gothic+A1&family=IBM+Plex+Sans+KR&family=Pretendard:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            background: transparent;
        }
        
        body {
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0;
            background: transparent;
            color: #fff; 
            overflow: hidden;
            min-width: 400px;   
            min-height: 0;
            font-family: 'Noto Sans KR', sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            position: relative;
        }
        
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-family: 'Pretendard', sans-serif;
            z-index: 10001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #connection-status.connecting {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }
        
        #connection-status.connected {
            background: rgba(40, 167, 69, 0.9);
            color: #fff;
        }
        
        #connection-status.disconnected {
            background: rgba(220, 53, 69, 0.9);
            color: #fff;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }
        
        #always-on-top-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-family: 'Pretendard', sans-serif;
            background: rgba(0, 240, 255, 0.9);
            color: #000;
            z-index: 10001;
            display: none;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #always-on-top-indicator.active {
            display: flex;
            opacity: 1;
        }
        
        .drag-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: transparent;
            -webkit-app-region: drag;
            z-index: 9999;
            transition: background 0.3s ease;
            cursor: move;
        }
        
        .drag-header:hover {
            background: rgba(0, 240, 255, 0.05);
        }
        
        body.show-border .drag-header {
            background: rgba(0, 240, 255, 0.1);
        }
        
        body.show-border {
            position: relative;
        }
        
        body.show-border::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 8px solid;
            border-image: linear-gradient(90deg, 
                #00f0ff 0%, 
                #00c4d4 25%, 
                #0099ff 50%, 
                #00c4d4 75%, 
                #00f0ff 100%
            ) 1;
            box-shadow: 
                inset 0 0 40px rgba(0, 240, 255, 0.8),
                0 0 40px rgba(0, 240, 255, 0.6),
                inset 0 0 20px rgba(0, 196, 212, 0.5),
                0 0 20px rgba(0, 196, 212, 0.4);
            pointer-events: none;
            z-index: 9998;
            animation: borderGlow 2s linear infinite;
        }
        
        @keyframes borderGlow {
            0% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
            25% {
                border-image: linear-gradient(180deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            50% {
                border-image: linear-gradient(270deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 153, 255, 0.8),
                    0 0 40px rgba(0, 153, 255, 0.6),
                    inset 0 0 20px rgba(0, 240, 255, 0.5),
                    0 0 20px rgba(0, 240, 255, 0.4);
            }
            75% {
                border-image: linear-gradient(360deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            100% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
        }
        
        #viewer {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            font-size: 32px; 
            line-height: 1.5; 
            text-align: left;
            transition: none;
            z-index: 1;
            box-sizing: border-box;
            background: transparent;
            overflow: hidden;
        }
        
        /* ğŸ”¥ í™”ì ê³ ì • í—¤ë” - ì¼ë°˜ í™”ìì™€ ë™ì¼í•œ í¬ê¸° */
        #speaker-fixed-header {
            position: absolute;
            left: 10px;
            top: 10px;
            display: inline-block;
            width: fit-content;
            max-width: calc(100% - 20px);
            
            /* ğŸ”¥ ì¼ë°˜ .speaker-nameê³¼ ë™ì¼í•œ padding */
            padding: 3px 15px;
            border-radius: 4px;
            
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            pointer-events: none;
            
            /* ë¶€ë“œëŸ¬ìš´ ì „í™˜ */
            transition: opacity 0.2s ease, transform 0.2s ease;
            
            /* ğŸ”¥ ì„¸ë¡œ ì •ë ¬ í†µì¼ */
            vertical-align: baseline;
        }
        
        body.speaker-fixed-mode #speaker-fixed-header {
            display: inline-block;
        }

        /* ğŸ”¥ ì´ì „ í™”ì êµ¬ë¶„ - í˜¼ë™ ë°©ì§€ */
        .previous-speaker {
            opacity: 0.45;
            transition: opacity 0.3s ease;
        }
        
        .previous-speaker .speaker-content {
            color: rgba(255, 255, 255, 0.6);
        }

        /* ğŸ”¥ ì¸ë¼ì¸ í™”ì í‘œì‹œ (ì„ íƒì ) */
        .inline-speaker-indicator {
            display: inline-block;
            font-size: 0.7em;
            padding: 1px 6px;
            margin-right: 8px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.15);
            opacity: 0.7;
            font-weight: 600;
            vertical-align: baseline;
        }
        
        .previous-speaker .inline-speaker-indicator {
            opacity: 0.5;
        }
        
        
        
        #viewer-text {
            position: absolute;
            top: 10px;
            bottom: 10px;
            left: 10px;
            right: 10px;
            width: auto;
            height: auto;
            
            overflow-y: auto;
            overflow-x: hidden;
            overflow-anchor: none;
            scrollbar-gutter: stable both-edges;
            scrollbar-width: thin;
            scrollbar-color: #8884 #0000;
            background: none;
            /* word-break: break-all; - í•œê¸€ ì–´ì ˆ ë‹¨ìœ„ ì¤„ë°”ê¿ˆì„ ìœ„í•´ ì œê±° */
                  white-space: pre-wrap;          /* ê¸°ì¡´ ìœ ì§€ */
  word-break: keep-all;           /* ë‹¨ì–´(ì–´ì ˆ) ë‹¨ìœ„ë¡œ ì¤„ë°”ê¿ˆ */
  overflow-wrap: break-word;      /* ê¸´ ì˜ì–´ ë‹¨ì–´ëŠ” ë‹¤ìŒ ì¤„ë¡œ */
            line-break: auto;           /* ìì—°ìŠ¤ëŸ¬ìš´ ì¤„ë°”ê¿ˆ */
            padding: 0;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            text-align: inherit;
            line-height: inherit;
            letter-spacing: 0;
            transition: color 0.2s, opacity 0.5s ease, top 0.2s ease;
            box-sizing: border-box;
            display: block;
            scroll-behavior: auto;
        }
        
        #viewer-text.hidden {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #viewer-text.scroll-disabled {
            overflow-y: hidden !important;
        }
        
        #viewer-text::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        
        #viewer-text::-webkit-scrollbar-thumb {
            background: rgba(180,180,180,0.18);
            border-radius: 4px;
        }
        
        .notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #000, #333);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 13px;
            font-family: 'Pretendard', sans-serif;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10002;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }
        .speaker-line {
            display: block;
            padding: 0;
            margin: 0;
            min-height: auto;
            box-sizing: border-box;
            line-height: inherit;
        }
        
        .speaker-name {
            background: rgba(255, 255, 255, 0.08);
            padding: 3px 15px;
            border-radius: 4px;
            /* font-weightëŠ” ë™ì ìœ¼ë¡œ ì„¤ì •ë¨ */
            margin-right: 13px;
            white-space: nowrap;
            line-height: inherit;
            display: inline;
            vertical-align: baseline;
        }
        
        .speaker-divider {
            display: inline-block;
            width: 2px;
            height: 1.6em;
            margin: 0 14px 0 10px;
            background: rgba(255,255,255,0.35);
            border-radius: 1px;
            vertical-align: -0.4em;
        }
        .speaker-pipe {
            color: rgba(255, 255, 255, 0.4);
            margin: 0 20px;
            font-weight: 300;
            line-height: inherit;
            display: inline;
        }
        
        .speaker-content {
            display: inline;
            line-height: inherit;
            white-space: pre-wrap;
            word-break: keep-all;
            overflow-wrap: break-word;
        }
        
        .speaker-line.no-speaker {
            display: flex;
            align-items: baseline;
        }
        
        .word-bg {
            display: inline-block;
            padding: 2px 6px;
            margin: 0 2px 2px 0;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: keep-all;
            overflow-wrap: break-word;
            transition: background-color 0.2s ease;
            vertical-align: baseline;
        }
        
        .word-bg.minimal {
            padding: 1px 4px;
            margin: 0 1px;
            border-radius: 2px;
        }
        
        .word-bg.full {
            padding: 3px 8px;
            margin: 0 3px 3px 0;
            border-radius: 6px;
        }
        
        .word-bg.continuous {
            display: inline;
            margin: 0;
        }
        
        #margin-adjuster {
            position: fixed;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.2), rgba(90,120,255,0.5));
            border-top: 2px solid #5a78ff;
            cursor: ns-resize;
            z-index: 9999;
            display: none;
            transition: all 0.2s ease;
            user-select: none;
            touch-action: none;
        }
        
        #margin-adjuster.active {
            display: block;
        }
        
        #margin-adjuster:hover {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.4), rgba(90,120,255,0.7));
            border-top-color: #7b9eff;
        }
        
        #margin-adjuster.dragging {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.6), rgba(90,120,255,0.8));
            border-top-color: #fff;
        }
        
        #margin-adjuster::before {
            content: "â‹®â‹®â‹®";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #5a78ff;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body class="show-border">
    <div class="drag-header"></div>
    
    <div id="connection-status" class="connecting">
        <div class="status-dot"></div>
        <span>ì—°ê²° ì¤‘...</span>
    </div>
    
    <div id="always-on-top-indicator">
        <span>ğŸ“Œ</span>
        <span>í•­ìƒ ìœ„</span>
    </div>
    
    <div id="viewer">
        <!-- ğŸ†• í™”ì ê³ ì • í—¤ë” (ì²«ì§¸ ì¤„) -->
        <div id="speaker-fixed-header"></div>
        
        <!-- ë³¸ë¬¸ (ë‘˜ì§¸ ì¤„ë¶€í„°) -->
        <div id="viewer-text">ì±„ë„ ì—°ê²° ëŒ€ê¸° ì¤‘...</div>
    </div>
    
    <div id="margin-adjuster"></div>
    
    <div class="notification" id="notification"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script>
const isElectron = typeof window.electronAPI !== 'undefined';

const CONFIG = {
      SOCKET_URL: 'https://live.nuastudio.co.kr', 
  CHANNEL_API: '/api/channel',
    RECONNECT_DELAY: 1000,
    RECONNECT_DELAY_MAX: 5000,
    KEEPALIVE_INTERVAL: 15 * 60 * 1000,
    LONG_PRESS_DURATION: 500,
    DOUBLE_TAP_DELAY: 300
};

let channelCode = null;
let longPressTimer = null;
let lastTapTime = 0;
let touchStartTime = 0;
let touchMoved = false;
let socket = null;
let keepaliveInterval = null;
let accumulatedText = '';
let activeStenographer = '1';
let currentActiveInput = '';
let isInitialConnection = true;
let lastTextSentTime = 0;
let lastAccumulatedLength = 0;
let ignoreInputUntil = 0;
let previousInput = '';
let previousDisplay = '';
let isSubtitleHidden = false;
let wasHiddenBeforeInput = false;
let lastRenderedText = '';
let isScrollManual = false;
let isTransparent = false;
let borderVisible = true;
let currentFontSize = 32;
let resizeObserver = null;
let isAlwaysOnTop = false;
let isScrollEnabled = true;
let alwaysOnTopTimer = null;
let marginAdjusterEnabled = false;
let marginOffset = 0;
let isDragging = false;
let startY = 0;
let startOffset = 0;
let maxMargin = 0;

// ğŸ”¥ í™”ì ìƒíƒœ ì•ˆì •í™” ë³€ìˆ˜
let lastKnownSpeaker = '';
let lastDetectedSpeaker = '';
let speakerHeaderStable = true;
let speakerFixedModeEnabled = true;
let lastSpeakerFixedMode = false;

// ğŸ”¥ ê³ ì •ëª¨ë“œ ì „í™˜ íŠœë‹ ê°’
const FIXED_SWITCH_LINES = 2;  // ìƒˆ í™”ì ë¼ë²¨ ì´í›„ ìµœì†Œ ëª‡ ì¤„ì´ ë” ìŒ“ì—¬ì•¼ ê³ ì • ì „í™˜í• ì§€

let currentSettings = {
    bgColor: '#000000',
    bgAlpha: '100',
    fontColor: '#ffffff',
    fontSize: '32',
    fontFamily: "'Noto Sans KR', sans-serif",
fontWeight: '400',
    letterSpacing: '0',
    lineHeight: '1.5',
    outlineOn: false,
    outlineColor: '#000000',
    outlineWidth: '2',
    shadowOn: false,
    shadowColor: '#000000',
    shadowBlur: '3',
    shadowX: '2',
    shadowY: '2',
    textAlign: 'left',
    verticalAlign: 'top',
    marginTop: '10',
    marginBottom: '10',
    marginLeft: '10',
    marginRight: '10',
    speakerEnabled: true,
    speakerStyle: 'label',
    speakerBgEnabled: true,
    speakerBgColor: '#ffffff',
    speakerBgAlpha: '8',
    speakerHeaderColor: '#ffffff',
    speakerHeaderWeight: '700',
    speakerHeaderOpacity: '100',
    speakerHeaderLetterSpacing: '0',
    speakerHeaderOutlineOn: false,
    speakerHeaderOutlineColor: '#000000',
    speakerHeaderOutlineWidth: '2',
    speakerHeaderShadowOn: true,
    speakerHeaderShadowColor: '#000000',
    speakerHeaderShadowBlur: '4',
    speakerHeaderShadowX: '2',
    speakerHeaderShadowY: '2',
    colorDividerEnabled: false,
    dividerColor: '#4A90E2',
    subtitleVisible: true,
    marginAdjusterEnabled: false,
    isTransparent: false,
    borderVisible: true,
    alwaysOnTop: false,
    scrollEnabled: true,
    wordBgEnabled: false,
    wordBgColor: '#ffffff',
    wordBgAlpha: '15',
    wordBgStyle: 'subtle',
    wordBgContinuous: false,
    wordBgPaddingY: '2',
    autoLayoutLines: '3'
};

const viewerText = document.getElementById('viewer-text');
const connectionStatus = document.getElementById('connection-status');
const marginAdjuster = document.getElementById('margin-adjuster');
const alwaysOnTopIndicator = document.getElementById('always-on-top-indicator');
const speakerFixedHeader = document.getElementById('speaker-fixed-header');

function initializeBackground() {
    const defaultBg = 'rgba(0, 0, 0, 1)';
    document.body.style.backgroundColor = defaultBg;
    document.getElementById('viewer').style.backgroundColor = defaultBg;
}

function loadLastSettings() {
    const saved = localStorage.getItem('lastUsedSettings');
    if (saved) {
        currentSettings = JSON.parse(saved);
        applySettings(currentSettings);
    }
    
    if (currentSettings.isTransparent !== undefined) {
        isTransparent = currentSettings.isTransparent;
        
        if (isTransparent) {
            const transparentBg = 'rgba(0, 0, 0, 0.004)';
            document.body.style.backgroundColor = transparentBg;
            document.getElementById('viewer').style.backgroundColor = transparentBg;
            document.documentElement.classList.add('transparent-mode');
            document.body.classList.add('transparent-mode');
        }
    }
    
    if (currentSettings.alwaysOnTop) {
        isAlwaysOnTop = true;
    }
}

function saveCurrentSettings() {
    localStorage.setItem('lastUsedSettings', JSON.stringify(currentSettings));
}

function getCurrentSettings() {
    return { ...currentSettings };
}

function measureActualHeight(lineCount) {
    const container = document.createElement('div');
    container.style.visibility = 'hidden';
    container.style.position = 'absolute';
    container.style.left = '-9999px';
    container.style.width = viewerText.offsetWidth + 'px';
    container.style.fontSize = currentSettings.fontSize + 'px';
    container.style.lineHeight = currentSettings.lineHeight;
    container.style.fontFamily = currentSettings.fontFamily;
    
    for (let i = 0; i < lineCount; i++) {
        const line = document.createElement('div');
        line.className = 'speaker-line';
        line.style.lineHeight = currentSettings.lineHeight;
        
        const content = document.createElement('span');
        content.className = 'speaker-content';
        content.textContent = 'ê°€ë‚˜ë‹¤ë¼ë§ˆë°”ì‚¬ì•„ìì°¨ì¹´íƒ€íŒŒí•˜';
        line.appendChild(content);
        container.appendChild(line);
    }
    
    viewerText.appendChild(container);
    const height = container.offsetHeight;
    viewerText.removeChild(container);
    
    return Math.ceil(height);
}

function calculateWindowHeight() {
    const lineCount = parseInt(currentSettings.autoLayoutLines) || 3;
    const textHeight = measureActualHeight(lineCount);
    const dragHeader = 20;
    const marginTop = parseInt(currentSettings.marginTop) || 10;
    const marginBottom = parseInt(currentSettings.marginBottom) || 10;
    
    let speakerHeaderHeight = 0;
    if (speakerFixedModeEnabled && currentSettings.speakerStyle === 'label' && speakerFixedHeader.offsetHeight > 0) {
        speakerHeaderHeight = speakerFixedHeader.offsetHeight + 4;
    }
    
    let extraAdjustment = 0;
    switch(lineCount) {
        case 1: extraAdjustment = -12; break;
        case 2: extraAdjustment = -17; break;
        case 3: extraAdjustment = -18; break;
        case 4: extraAdjustment = -18; break;
        case 5: extraAdjustment = -19; break;
        default: extraAdjustment = -18;
    }
    
    const total = textHeight + marginTop + marginBottom + dragHeader + speakerHeaderHeight + extraAdjustment;
    
    console.log('[AutoPosition] Height calculation:', {
        fontSize: currentSettings.fontSize,
        lineHeight: currentSettings.lineHeight,
        lineCount: lineCount,
        textHeight: textHeight,
        margins: marginTop + marginBottom,
        speakerHeaderHeight: speakerHeaderHeight,
        extraAdjustment: extraAdjustment,
        total: total
    });
    
    return Math.max(80, Math.floor(total));
}

function autoPositionWindow(position) {
    if (!isElectron) return;
    
    try {
        const lineCount = parseInt(currentSettings.autoLayoutLines) || 3;
        const newHeight = calculateWindowHeight();
        
        console.log('[AutoPosition] Positioning window:', {
            height: newHeight,
            position: position,
            lines: lineCount
        });
        
        if (window.electronAPI && window.electronAPI.resizeWindow) {
            window.electronAPI.resizeWindow(0, newHeight, position);
            showNotification(`${position === 'top' ? 'ìƒë‹¨' : 'í•˜ë‹¨'} ë§ì¶¤ (${lineCount}ì¤„)`);
        }
    } catch (error) {
        console.error('[AutoPosition] Error:', error);
    }
}

function applyMargins(smooth = false) {
    const mTop = parseInt(currentSettings.marginTop) || 10;
    const mBottom = parseInt(currentSettings.marginBottom) || 10;
    const mLeft = parseInt(currentSettings.marginLeft) || 10;
    const mRight = parseInt(currentSettings.marginRight) || 10;
    
    let adjustedTop = mTop;
    const isFixedMode = document.body.classList.contains('speaker-fixed-mode');
    
    if (isFixedMode) {
        const headerHeight = speakerFixedHeader.offsetHeight || 0;
        adjustedTop = mTop + headerHeight + 4;
    }
    
    if (smooth && lastSpeakerFixedMode !== isFixedMode) {
        const scrollRatio = viewerText.scrollTop / (viewerText.scrollHeight - viewerText.clientHeight + 0.001);
        
        viewerText.style.top = `${adjustedTop}px`;
        viewerText.style.bottom = `${mBottom}px`;
        viewerText.style.left = `${mLeft}px`;
        viewerText.style.right = `${mRight}px`;
        
        requestAnimationFrame(() => {
            const newScrollTop = scrollRatio * (viewerText.scrollHeight - viewerText.clientHeight);
            viewerText.scrollTop = Math.max(0, newScrollTop);
        });
        
        lastSpeakerFixedMode = isFixedMode;
    } else {
        viewerText.style.top = `${adjustedTop}px`;
        viewerText.style.bottom = `${mBottom}px`;
        viewerText.style.left = `${mLeft}px`;
        viewerText.style.right = `${mRight}px`;
    }
}

function applySettings(settings) {
    // âœ… ê¸°ì¡´ íˆ¬ëª… ìƒíƒœ ë³´ì¡´
    const preservedTransparent = isTransparent;
    
    currentSettings = { ...currentSettings, ...settings };
    
    // âœ… settingsì— isTransparentê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ ìƒíƒœ ìœ ì§€
    if (settings.isTransparent === undefined) {
        isTransparent = preservedTransparent;
        currentSettings.isTransparent = preservedTransparent;
    } else {
        isTransparent = settings.isTransparent;
    }
    
    if (settings.bgColor && settings.bgAlpha !== undefined) {
        const bgHex = settings.bgColor;
        const alpha = parseInt(settings.bgAlpha) / 100;
        const safeAlpha = Math.max(alpha, 0.01);
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${safeAlpha})`;
        
        // âœ… íˆ¬ëª… ëª¨ë“œ ì²´í¬ ì¶”ê°€
        if (isTransparent) {
            const transparentBg = 'rgba(0, 0, 0, 0.004)';
            document.body.style.backgroundColor = transparentBg;
            document.getElementById('viewer').style.backgroundColor = transparentBg;
        } else {
            document.getElementById('viewer').style.backgroundColor = bgRgba;
            document.body.style.backgroundColor = bgRgba;
        }
    }
    
    if (settings.fontSize) {
        currentFontSize = parseInt(settings.fontSize);
        viewerText.style.fontSize = settings.fontSize + 'px';
        speakerFixedHeader.style.fontSize = settings.fontSize + 'px';
    }
    
    if (settings.fontColor) {
        viewerText.style.color = settings.fontColor;
    }
    
    if (settings.fontFamily) {
        viewerText.style.fontFamily = settings.fontFamily;
        speakerFixedHeader.style.fontFamily = settings.fontFamily;
    }
  
  if (settings.fontWeight) {
        viewerText.style.fontWeight = settings.fontWeight;
        // ğŸ”¥ í™”ì í—¤ë”ëŠ” ë…ë¦½ì ì¸ fontWeight ì‚¬ìš© (updateSpeakerFixedHeaderStyleì—ì„œ ì²˜ë¦¬)
    }

    if (settings.letterSpacing !== undefined) {
        viewerText.style.letterSpacing = settings.letterSpacing + 'px';
        // ğŸ”¥ í™”ì í—¤ë”ëŠ” ë…ë¦½ì ì¸ letterSpacing ì‚¬ìš©
    }
    
    if (settings.lineHeight) {
        viewerText.style.lineHeight = parseFloat(settings.lineHeight) + 'em';
        speakerFixedHeader.style.lineHeight = parseFloat(settings.lineHeight) + 'em';
    }
    
    if (settings.textAlign) {
        viewerText.style.textAlign = settings.textAlign;
    }
    
    if (settings.verticalAlign) {
        scrollToBottom();
    }
    
    if (settings.marginTop !== undefined && settings.marginBottom !== undefined && 
        settings.marginLeft !== undefined && settings.marginRight !== undefined) {
        applyMargins();
        scrollToBottom();
    }
    
    let textShadow = '';
    if (settings.outlineOn && parseFloat(settings.outlineWidth) > 0) {
        const outline = `-${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, -${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}`;
        textShadow = outline;
    }
    if (settings.shadowOn && parseFloat(settings.shadowBlur) > 0) {
        const dropShadow = `${settings.shadowX}px ${settings.shadowY}px ${settings.shadowBlur}px ${settings.shadowColor}`;
        textShadow = textShadow ? textShadow + ', ' + dropShadow : dropShadow;
    }
    viewerText.style.textShadow = textShadow;
    
    if (settings.subtitleVisible !== undefined) {
        isSubtitleHidden = !settings.subtitleVisible;
        if (isSubtitleHidden) {
            viewerText.classList.add('hidden');
        } else {
            viewerText.classList.remove('hidden');
        }
    }
    
    if (settings.marginAdjusterEnabled !== undefined) {
        marginAdjusterEnabled = settings.marginAdjusterEnabled;
        if (marginAdjusterEnabled) {
            marginAdjuster.classList.add('active');
            marginAdjuster.style.bottom = marginOffset + 'px';
        } else {
            marginAdjuster.classList.remove('active');
        }
    }
    
    if (settings.alwaysOnTop !== undefined) {
        isAlwaysOnTop = settings.alwaysOnTop;
    }
    
    if (settings.scrollEnabled !== undefined) {
        isScrollEnabled = settings.scrollEnabled;
        if (isScrollEnabled) {
            viewerText.classList.remove('scroll-disabled');
        } else {
            viewerText.classList.add('scroll-disabled');
        }
    }
    
    updateSpeakerFixedHeaderStyle();
    
    lastRenderedText = '';
    const currentText = accumulatedText + currentActiveInput;
    updateDisplay(currentText, true);
    
    saveCurrentSettings();
}

function updateSpeakerFixedHeaderStyle() {
    if (!speakerFixedModeEnabled) return;
    
    // ë°°ê²½ ì„¤ì •
    const speakerBgEnabled = currentSettings.speakerBgEnabled;
    const speakerBgColor = currentSettings.speakerBgColor || '#ffffff';
    const speakerBgAlpha = parseInt(currentSettings.speakerBgAlpha || '8') / 100;
    
    if (speakerBgEnabled) {
        const r = parseInt(speakerBgColor.slice(1, 3), 16);
        const g = parseInt(speakerBgColor.slice(3, 5), 16);
        const b = parseInt(speakerBgColor.slice(5, 7), 16);
        speakerFixedHeader.style.background = `rgba(${r}, ${g}, ${b}, ${speakerBgAlpha})`;
    } else {
        speakerFixedHeader.style.background = 'rgba(255, 255, 255, 0.08)';
    }
    
    // ğŸ†• í™”ì í—¤ë” ê¸€ì ìŠ¤íƒ€ì¼ ì„¤ì •
    // ê¸°ë³¸ ìŠ¤íƒ€ì¼
    speakerFixedHeader.style.color = currentSettings.speakerHeaderColor || '#ffffff';
    speakerFixedHeader.style.fontWeight = currentSettings.speakerHeaderWeight || '700';
    
    // íˆ¬ëª…ë„
    const headerOpacity = parseInt(currentSettings.speakerHeaderOpacity || '100') / 100;
    speakerFixedHeader.style.opacity = headerOpacity;
    
    // ìê°„
    const headerLetterSpacing = parseFloat(currentSettings.speakerHeaderLetterSpacing || '0');
    speakerFixedHeader.style.letterSpacing = `${headerLetterSpacing}px`;
    
    // ì™¸ê³½ì„ 
    let textStroke = '';
    if (currentSettings.speakerHeaderOutlineOn) {
        const outlineColor = currentSettings.speakerHeaderOutlineColor || '#000000';
        const outlineWidth = parseFloat(currentSettings.speakerHeaderOutlineWidth || '2');
        textStroke = `-webkit-text-stroke: ${outlineWidth}px ${outlineColor};`;
        speakerFixedHeader.style.webkitTextStroke = `${outlineWidth}px ${outlineColor}`;
    } else {
        speakerFixedHeader.style.webkitTextStroke = '';
    }
    
    // ê·¸ë¦¼ì
    let textShadow = '';
    if (currentSettings.speakerHeaderShadowOn) {
        const shadowColor = currentSettings.speakerHeaderShadowColor || '#000000';
        const shadowBlur = parseFloat(currentSettings.speakerHeaderShadowBlur || '4');
        const shadowX = parseFloat(currentSettings.speakerHeaderShadowX || '2');
        const shadowY = parseFloat(currentSettings.speakerHeaderShadowY || '2');
        textShadow = `${shadowX}px ${shadowY}px ${shadowBlur}px ${shadowColor}`;
        speakerFixedHeader.style.textShadow = textShadow;
    } else {
        speakerFixedHeader.style.textShadow = '';
    }
    
    console.log('[SpeakerHeader] Style updated:', {
        color: speakerFixedHeader.style.color,
        fontWeight: speakerFixedHeader.style.fontWeight,
        opacity: speakerFixedHeader.style.opacity,
        letterSpacing: speakerFixedHeader.style.letterSpacing,
        outline: currentSettings.speakerHeaderOutlineOn,
        shadow: currentSettings.speakerHeaderShadowOn
    });
}

function scrollToBottom() {
    requestAnimationFrame(() => {
        viewerText.scrollTop = viewerText.scrollHeight;
    });
}

function initSocket() {
    console.log('[Socket] ì´ˆê¸°í™”:', CONFIG.SOCKET_URL);
    
    socket = io(CONFIG.SOCKET_URL, {
        transports: ['websocket', 'polling'],
        upgrade: true,
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: CONFIG.RECONNECT_DELAY,
        reconnectionDelayMax: CONFIG.RECONNECT_DELAY_MAX,
        timeout: 20000,
        forceNew: true
    });
    
    socket.on('connect', () => {
        console.log('[Socket] ì—°ê²° ì„±ê³µ');
        updateConnectionStatus('connected', 'ì—°ê²°ë¨');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('connect_error', (error) => {
        console.error('[Socket] ì—°ê²° ì—ëŸ¬:', error.message);
        updateConnectionStatus('disconnected', 'ì—°ê²° ì‹¤íŒ¨');
    });
    
    socket.on('disconnect', (reason) => {
        console.log('[Socket] ì—°ê²° ëŠê¹€:', reason);
        updateConnectionStatus('disconnected', 'ì—°ê²° ëŠê¹€');
        stopKeepalive();
    });
    
    socket.on('reconnect', () => {
        console.log('[Socket] ì¬ì—°ê²° ì„±ê³µ');
        updateConnectionStatus('connected', 'ì¬ì—°ê²°ë¨');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('joined_channel', (data) => {
        console.log('[Channel] ì°¸ê°€ ì„±ê³µ');
        viewerText.textContent = 'ìë§‰ ëŒ€ê¸° ì¤‘...';
        socket.emit('request_sync', { channel: channelCode });
    });
    
    socket.on('channel_state', (data) => {
        console.log('[State] ì±„ë„ ìƒíƒœ:', data);
        if (data.state) {
            if (data.state.activeStenographer) {
                activeStenographer = data.state.activeStenographer === 'steno1' ? '1' : '2';
            }
            if (data.state.accumulatedText !== undefined) {
                accumulatedText = data.state.accumulatedText;
                currentActiveInput = '';
                previousInput = '';
                previousDisplay = '';
                updateDisplay(accumulatedText, true);
            }
        }
    });
    
    socket.on('sync_accumulated', (data) => {
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
        
        if (data.activeStenographer) {
            activeStenographer = data.activeStenographer === 'steno1' ? '1' : '2';
        }
    });
    
    socket.on('steno_input', (data) => {
        const roleNumber = data.role === 'steno1' ? '1' : data.role === 'steno2' ? '2' : data.role;
        
        if (roleNumber === activeStenographer) {
            const now = Date.now();
            const inputLength = (data.text || '').length;
            
            if (now < ignoreInputUntil && inputLength < lastAccumulatedLength - 10) {
                return;
            }
            
            currentActiveInput = data.text || '';
            const fullText = accumulatedText + currentActiveInput;
            updateDisplay(fullText, false);
        }
    });
    
    socket.on('switch_role', (data) => {
        activeStenographer = data.newActive === 'steno1' ? '1' : '2';
        
        if (data.accumulatedText !== undefined) {
            accumulatedText = data.accumulatedText;
            currentActiveInput = '';
            previousInput = '';
            previousDisplay = '';
            updateDisplay(accumulatedText, true);
        }
    });
    
    socket.on('text_sent', (data) => {
        lastTextSentTime = Date.now();
        lastAccumulatedLength = (data.accumulatedText || '').length;
        ignoreInputUntil = Date.now() + 250;
        
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
    });
    
    socket.on('clear_text', () => {
        accumulatedText = '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        lastRenderedText = '';
        lastKnownSpeaker = '';
        lastDetectedSpeaker = '';
        speakerHeaderStable = true;
        updateDisplay('', true);
    });
}

function joinChannel() {
    if (!socket || !socket.connected) return;
    
    console.log('[Channel] ì°¸ê°€ ìš”ì²­:', channelCode);
    socket.emit('join_channel', {
        channel: channelCode,
        role: 'viewer',
        requestSync: true
    });
}

function startKeepalive() {
    stopKeepalive();
    keepaliveInterval = setInterval(() => {
        if (socket && socket.connected) {
            socket.emit('keepalive', { channel: channelCode, timestamp: Date.now() });
        }
    }, CONFIG.KEEPALIVE_INTERVAL);
}

function stopKeepalive() {
    if (keepaliveInterval) {
        clearInterval(keepaliveInterval);
        keepaliveInterval = null;
    }
}

function updateConnectionStatus(status, message) {
    connectionStatus.className = status;
    connectionStatus.querySelector('span').textContent = message;
    
    if (status === 'connected' && isInitialConnection) {
        setTimeout(() => {
            connectionStatus.style.opacity = '0';
            isInitialConnection = false;
        }, 3000);
    } else {
        connectionStatus.style.opacity = '1';
    }
}

function updateDisplay(text, isImmediate = false) {
    if (isSubtitleHidden && text && text.trim()) {
        if (wasHiddenBeforeInput || text.length > (previousInput ? previousInput.length : 0)) {
            toggleSubtitleVisibility(true);
            wasHiddenBeforeInput = false;
        }
    }
    
    let displayText = text;
    
    if (isImmediate) {
        previousInput = '';
        previousDisplay = '';
    } else {
        const isBackspace = previousInput.length > text.length;
        const onlySpaceRemoved = isBackspace && previousInput.endsWith(' ') && text === previousInput.slice(0, -1);
        
        if (text.length > 0) {
            if (text.endsWith(' ') || text.endsWith('\n')) {
                displayText = text;
            } else if (onlySpaceRemoved && previousDisplay) {
                displayText = previousDisplay.trimEnd();
            } else {
                const lastSpace = text.lastIndexOf(' ');
                const lastNewline = text.lastIndexOf('\n');
                const lastDelimiter = Math.max(lastSpace, lastNewline);
                
                if (lastDelimiter > -1) {
                    displayText = text.substring(0, lastDelimiter + 1);
                } else {
                    displayText = '';
                }
            }
        }
        
        previousInput = text;
        previousDisplay = displayText;
    }
    
    if (!currentActiveInput || currentActiveInput.trim().length === 0) {
        displayText = displayText.replace(/\n+$/, '');
    }
    
    const lines = displayText.split('\n');
    if (lines.length > 10000) {
        console.log('[Performance] ì¤„ ìˆ˜ ì´ˆê³¼:', lines.length, 'â†’ 8,000ì¤„ë¡œ ì •ë¦¬');
        displayText = lines.slice(-8000).join('\n');
        if (isImmediate) {
            accumulatedText = displayText;
        }
    }
    
    const finalDisplayText = displayText || (channelCode ? 'ìë§‰ ëŒ€ê¸° ì¤‘...' : 'ì±„ë„ ì—°ê²° ëŒ€ê¸° ì¤‘...');
    if (finalDisplayText === lastRenderedText) return;
    
    renderFormattedText(finalDisplayText);
    lastRenderedText = finalDisplayText;
    
    if (!isScrollManual) {
        scrollToBottom();
    }
}

viewerText.addEventListener('wheel', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

viewerText.addEventListener('touchstart', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

function detectLastSpeaker(text) {
    const lines = text.split('\n');
    for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (line.startsWith('-') && line.includes(': ')) {
            const colonIndex = line.indexOf(': ');
            const speaker = line.substring(1, colonIndex).trim();
            return speaker;
        }
    }
    return '';
}

/* REPLACE: shouldShowFixedHeader */
function shouldShowFixedHeader(text) {
  if (!speakerFixedModeEnabled) return false;
  if (currentSettings.speakerStyle !== 'label') return false;

  const visibleLines = parseInt(currentSettings.autoLayoutLines) || 3;
  const lines = text.split('\n');
  const startIndex = Math.max(0, lines.length - visibleLines);
  const slice = lines.slice(startIndex);

  // ê°€ì‹œì˜ì—­ ë‚´ í™”ì ë¼ë²¨ê³¼ ê·¸ ì¸ë±ìŠ¤ ìˆ˜ì§‘
  const speakersInView = [];
  const speakerIndices = [];
  
  slice.forEach((line, i) => {
    const match = line.match(/^-(.+?):/);
    if (match) {
      const speaker = match[1].trim();
      speakersInView.push(speaker);
      speakerIndices.push(startIndex + i);  // ì „ì²´ í…ìŠ¤íŠ¸ ê¸°ì¤€ ì¸ë±ìŠ¤
    }
  });

  // ê°€ì‹œì˜ì—­ì— í™”ì ë¼ë²¨ì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´: ë§ˆì§€ë§‰ í™”ì ìœ ì§€
  if (speakersInView.length === 0) {
    return (lastDetectedSpeaker !== '' || lastKnownSpeaker !== '');
  }

  // ê°€ì‹œì˜ì—­ì— ì—¬ëŸ¬ í™”ìê°€ ì„ì—¬ ìˆëŠ”ì§€ í™•ì¸
  const uniqueSpeakers = new Set(speakersInView);
  
  if (uniqueSpeakers.size > 1) {
    // ğŸ”¥ ì—¬ëŸ¬ í™”ìê°€ ì„ì—¬ìˆìœ¼ë©´: ê¸°ë³¸ ëª¨ë“œ ìœ ì§€
    // í•˜ì§€ë§Œ ë§ˆì§€ë§‰ í™”ìëŠ” ê¸°ë¡ (ì°¸ê³ ìš©)
    const lastSpeakerInView = speakersInView[speakersInView.length - 1];
    lastDetectedSpeaker = lastSpeakerInView;
    return false;
  }

  // ì—¬ê¸° ì˜¤ë©´ ê°€ì‹œì˜ì—­ì—ëŠ” 'í•œ ëª…ì˜ í™”ì'ë§Œ ì¡´ì¬
  const onlySpeaker = speakersInView[0];
  
  // ğŸ”¥ í•µì‹¬: ê°€ì‹œ ì˜ì—­ ì²« ì¤„ì´ í™”ì ë¼ë²¨ë¡œ ì‹œì‘í•˜ëŠ”ì§€ í™•ì¸
  // ì²« ì¤„ì´ í‰ë¬¸(ë¼ë²¨ ì—†ìŒ)ì´ë©´ = ì´ì „ í™”ìì˜ ì”ì—¬ ë‚´ìš©
  const firstLineIndex = speakerIndices[0];
  const firstVisibleLineIndex = startIndex;
  
  if (firstLineIndex !== firstVisibleLineIndex) {
    // ê°€ì‹œ ì˜ì—­ ì²« ì¤„ì´ í™”ì ë¼ë²¨ì´ ì•„ë‹˜ = ì´ì „ í™”ìì˜ í‰ë¬¸ì´ ë‚¨ì•„ìˆìŒ
    // â†’ ê³ ì • ëª¨ë“œë¡œ ì „í™˜í•˜ì§€ ì•ŠìŒ
    lastDetectedSpeaker = onlySpeaker;
    return false;
  }
  
  // ì•µì»¤(ê°€ì¥ ì•„ë˜ ë¼ë²¨ ì¤„)ì˜ ì¸ë±ìŠ¤
  const anchorIndex = speakerIndices[speakerIndices.length - 1];
  
  // ì•µì»¤ ì´í›„ ì¤„ ìˆ˜ ê³„ì‚° (ì „ì²´ í…ìŠ¤íŠ¸ ê¸°ì¤€)
  const afterAnchorLines = (lines.length - 1) - anchorIndex;
  
  // ğŸ”¥ ë¼ì¸ ê¸°ì¤€ ì§€ì—°: ì•µì»¤ ì´í›„ ìµœì†Œ Nì¤„ ì´ìƒ ìŒ“ì—¬ì•¼ ê³ ì • ì „í™˜
  const enoughLines = afterAnchorLines >= FIXED_SWITCH_LINES;
  
  if (enoughLines) {
    // ì¶©ë¶„í•œ ì¤„ì´ ìŒ“ì˜€ìœ¼ë©´ ê³ ì • ëª¨ë“œ ì „í™˜
    lastDetectedSpeaker = onlySpeaker;
    return true;
  } else {
    // ì•„ì§ ì¶©ë¶„í•œ ì¤„ì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ëª¨ë“œ ìœ ì§€
    lastDetectedSpeaker = onlySpeaker;
    return false;
  }
}


function updateSpeakerFixedHeader(speaker, shouldShow) {
    if (!shouldShow) {
        document.body.classList.remove('speaker-fixed-mode');
        requestAnimationFrame(() => {
            applyMargins(true);
        });
        return;
    }
    
    if (speaker) {
        lastKnownSpeaker = speaker;
    }
    
    if (lastKnownSpeaker) {
        speakerFixedHeader.textContent = lastKnownSpeaker;
        document.body.classList.add('speaker-fixed-mode');
        
        // ğŸ”¥ ê°•ì œ ë ˆì´ì•„ì›ƒ ë¦¬í”Œë¡œìš°
        void speakerFixedHeader.offsetHeight;
        
        requestAnimationFrame(() => {
            applyMargins(true);
        });
    } else {
        document.body.classList.remove('speaker-fixed-mode');
        requestAnimationFrame(() => {
            applyMargins(true);
        });
    }
}

function renderFormattedText(text) {
    const lines = text.split('\n');
    const speakerEnabled = currentSettings.speakerEnabled;
    const speakerStyle = currentSettings.speakerStyle || 'divider';
    const useBg = currentSettings.speakerBgEnabled;
    const useColorDivider = currentSettings.colorDividerEnabled;
    const bgAlpha = parseInt(currentSettings.speakerBgAlpha) / 100;
    const currentLineHeight = viewerText.style.lineHeight;
    
    const useWordBg = currentSettings.wordBgEnabled;
    const wordBgColor = currentSettings.wordBgColor;
    const wordBgAlpha = parseInt(currentSettings.wordBgAlpha || '15') / 100;
    const wordBgStyle = currentSettings.wordBgStyle || 'subtle';
    const wordBgContinuous = currentSettings.wordBgContinuous || false;
    const wordBgPaddingY = parseFloat(currentSettings.wordBgPaddingY || '2');
    
    const lastSpeaker = detectLastSpeaker(text);
    const showFixedHeader = shouldShowFixedHeader(text);
    updateSpeakerFixedHeader(lastSpeaker, showFixedHeader);
    
    viewerText.innerHTML = '';
    
    lines.forEach(line => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'speaker-line';
        lineDiv.style.lineHeight = currentLineHeight;
        
        if (speakerEnabled && line.startsWith('-') && line.includes(': ')) {
            const colonIndex = line.indexOf(': ');
            const speaker = line.substring(1, colonIndex).trim();
            const content = line.substring(colonIndex + 2);
            
            if (speakerStyle === 'label' && showFixedHeader) {
                lineDiv.classList.add('no-speaker');
                
                const contentSpan = document.createElement('span');
                contentSpan.className = 'speaker-content';
                
                if (useWordBg && content.trim()) {
                    applyWordBackground(contentSpan, content, wordBgColor, wordBgAlpha, wordBgStyle, wordBgContinuous, wordBgPaddingY);
                } else {
                    contentSpan.textContent = content || '\u200B';
                }
                
                lineDiv.appendChild(contentSpan);
            } else {
                const speakerSpan = document.createElement('span');
                speakerSpan.className = 'speaker-name';
                speakerSpan.textContent = speaker;
                // ğŸ”¥ í™”ì í—¤ë” ìŠ¤íƒ€ì¼ì„ ì¸ë¼ì¸ ë¼ë²¨ì—ë„ ë™ì¼í•˜ê²Œ ì ìš©
speakerSpan.style.color = currentSettings.speakerHeaderColor || '#ffffff';
speakerSpan.style.fontWeight = currentSettings.speakerHeaderWeight || '700';
speakerSpan.style.opacity = (parseInt(currentSettings.speakerHeaderOpacity || '100') / 100);
speakerSpan.style.letterSpacing = (parseFloat(currentSettings.speakerHeaderLetterSpacing || '0')) + 'px';

// ì„ íƒì ìœ¼ë¡œ ì™¸ê³½ì„ (í…Œë‘ë¦¬) ì ìš©
if (currentSettings.speakerHeaderOutlineOn) {
  const outlineColor = currentSettings.speakerHeaderOutlineColor || '#000000';
  const outlineWidth = parseFloat(currentSettings.speakerHeaderOutlineWidth || '2');
  speakerSpan.style.webkitTextStroke = `${outlineWidth}px ${outlineColor}`;
} else {
  speakerSpan.style.webkitTextStroke = '';
}

// ì„ íƒì ìœ¼ë¡œ ê·¸ë¦¼ì íš¨ê³¼ ì ìš©
if (currentSettings.speakerHeaderShadowOn) {
  const sc = currentSettings.speakerHeaderShadowColor || '#000000';
  const sb = parseFloat(currentSettings.speakerHeaderShadowBlur || '4');
  const sx = parseFloat(currentSettings.speakerHeaderShadowX || '2');
  const sy = parseFloat(currentSettings.speakerHeaderShadowY || '2');
  speakerSpan.style.textShadow = `${sx}px ${sy}px ${sb}px ${sc}`;
} else {
  speakerSpan.style.textShadow = '';
}
                // ğŸ”¥ ì¸ë¼ì¸ ëª¨ë“œì—ì„œë„ í°íŠ¸ ì„¤ì • ì ìš©
                speakerSpan.style.fontSize = currentSettings.fontSize + 'px';
                speakerSpan.style.fontFamily = currentSettings.fontFamily;
                
                
                if (useBg) {
                    const bgColor = currentSettings.speakerBgColor;
                    const r = parseInt(bgColor.slice(1, 3), 16);
                    const g = parseInt(bgColor.slice(3, 5), 16);
                    const b = parseInt(bgColor.slice(5, 7), 16);
                    speakerSpan.style.background = `rgba(${r}, ${g}, ${b}, ${bgAlpha})`;
                } else {
                    speakerSpan.style.background = 'transparent';
                }
                
                lineDiv.appendChild(speakerSpan);
                
                if (speakerStyle === 'divider') {
                    const divider = document.createElement('div');
                    divider.className = 'speaker-divider';
                    if (useColorDivider) {
                        divider.style.background = currentSettings.dividerColor;
                    }
                    lineDiv.appendChild(divider);
                } else if (speakerStyle === 'pipe') {
                    const pipe = document.createElement('span');
                    pipe.className = 'speaker-pipe';
                    pipe.textContent = '|';
                    if (useColorDivider) {
                        pipe.style.color = currentSettings.dividerColor;
                    }
                    lineDiv.appendChild(pipe);
                } else if (speakerStyle === 'minimal') {
                    const divider = document.createElement('div');
                    divider.className = 'speaker-divider';
                    divider.style.width = '1px';
                    divider.style.margin = '0 25px';
                    if (useColorDivider) {
                        divider.style.background = currentSettings.dividerColor;
                    } else {
                        divider.style.background = 'rgba(255, 255, 255, 0.2)';
                    }
                    lineDiv.appendChild(divider);
                }
                
                const contentSpan = document.createElement('span');
                contentSpan.className = 'speaker-content';
                
                if (useWordBg && content.trim()) {
                    applyWordBackground(contentSpan, content, wordBgColor, wordBgAlpha, wordBgStyle, wordBgContinuous, wordBgPaddingY);
                } else {
                    contentSpan.textContent = content || '\u200B';
                }
                
                lineDiv.appendChild(contentSpan);
            }
        } else {
            lineDiv.classList.add('no-speaker');
            const contentSpan = document.createElement('span');
            contentSpan.className = 'speaker-content';
            
            if (useWordBg && line.trim()) {
                applyWordBackground(contentSpan, line, wordBgColor, wordBgAlpha, wordBgStyle, wordBgContinuous, wordBgPaddingY);
            } else {
                contentSpan.textContent = line || '\u200B';
            }
            
            lineDiv.appendChild(contentSpan);
        }
        
        viewerText.appendChild(lineDiv);
    });
}

function applyWordBackground(container, text, wordBgColor, wordBgAlpha, wordBgStyle, continuous, paddingY) {
    const r = parseInt(wordBgColor.slice(1, 3), 16);
    const g = parseInt(wordBgColor.slice(3, 5), 16);
    const b = parseInt(wordBgColor.slice(5, 7), 16);
    const bgColorRgba = `rgba(${r}, ${g}, ${b}, ${wordBgAlpha})`;
    
    if (continuous) {
        const span = document.createElement('span');
        span.className = `word-bg ${wordBgStyle} continuous`;
        span.textContent = text;
        span.style.backgroundColor = bgColorRgba;
        span.style.paddingTop = paddingY + 'px';
        span.style.paddingBottom = paddingY + 'px';
        container.appendChild(span);
    } else {
        const words = text.split(/(\s+)/);
        words.forEach(word => {
            if (word.trim()) {
                const wordSpan = document.createElement('span');
                wordSpan.className = `word-bg ${wordBgStyle}`;
                wordSpan.textContent = word;
                wordSpan.style.backgroundColor = bgColorRgba;
                wordSpan.style.paddingTop = paddingY + 'px';
                wordSpan.style.paddingBottom = paddingY + 'px';
                container.appendChild(wordSpan);
            } else if (word) {
                container.appendChild(document.createTextNode(word));
            }
        });
    }
}

function toggleSubtitleVisibility(forceShow = null) {
    if (forceShow !== null) {
        isSubtitleHidden = !forceShow;
    } else {
        isSubtitleHidden = !isSubtitleHidden;
    }
    
    if (isSubtitleHidden) {
        viewerText.classList.add('hidden');
        wasHiddenBeforeInput = true;
        currentSettings.subtitleVisible = false;
        showNotification('ìë§‰ ìˆ¨ê¹€');
    } else {
        viewerText.classList.remove('hidden');
        wasHiddenBeforeInput = false;
        currentSettings.subtitleVisible = true;
        showNotification('ìë§‰ í‘œì‹œ');
    }
    saveCurrentSettings();
}

function toggleScrollEnabled() {
    isScrollEnabled = !isScrollEnabled;
    currentSettings.scrollEnabled = isScrollEnabled;
    
    if (isScrollEnabled) {
        viewerText.classList.remove('scroll-disabled');
        showNotification('ìŠ¤í¬ë¡¤ í™œì„±í™”');
    } else {
        viewerText.classList.add('scroll-disabled');
        showNotification('ìŠ¤í¬ë¡¤ ë¹„í™œì„±í™”');
    }
    
    saveCurrentSettings();
}

function toggleAlwaysOnTop() {
    if (isElectron) {
        window.electronAPI.toggleAlwaysOnTop();
    }
}

function updateAlwaysOnTopIndicator(state, showTemporary = true) {
    if (alwaysOnTopTimer) {
        clearTimeout(alwaysOnTopTimer);
        alwaysOnTopTimer = null;
    }
    
    if (state) {
        alwaysOnTopIndicator.classList.add('active');
        if (showTemporary) {
            alwaysOnTopTimer = setTimeout(() => {
                alwaysOnTopIndicator.classList.remove('active');
                alwaysOnTopTimer = null;
            }, 3000);
        }
    } else {
        alwaysOnTopIndicator.classList.remove('active');
    }
}

function saveTextToFile() {
    const fullText = accumulatedText || 'ì €ì¥í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `ìë§‰_${channelCode}_${timestamp}.txt`;
    
    const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showNotification(`í…ìŠ¤íŠ¸ ì €ì¥ë¨: ${filename}`);
}

function toggleTransparent() {
    console.log('[Transparent] Toggle called, current:', isTransparent);
    
    isTransparent = !isTransparent;
    currentSettings.isTransparent = isTransparent;
    
    if (isTransparent) {
        document.documentElement.classList.add('transparent-mode');
        document.body.classList.add('transparent-mode');
        
        const transparentBg = 'rgba(0, 0, 0, 0.004)';
        document.body.style.backgroundColor = transparentBg;
        document.getElementById('viewer').style.backgroundColor = transparentBg;
        
        if (isElectron) window.electronAPI.toggleTransparent(true);
        showNotification('íˆ¬ëª… ëª¨ë“œ ì¼œì§');
    } else {
        document.documentElement.classList.remove('transparent-mode');
        document.body.classList.remove('transparent-mode');
        
        const bgHex = currentSettings.bgColor || '#000000';
        const alpha = parseInt(currentSettings.bgAlpha || '100') / 100;
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        
        document.body.style.backgroundColor = bgRgba;
        document.getElementById('viewer').style.backgroundColor = bgRgba;
        
        if (isElectron) window.electronAPI.toggleTransparent(false);
        showNotification('íˆ¬ëª… ëª¨ë“œ êº¼ì§');
    }
    
    saveCurrentSettings();
}

function toggleBorder() {
    console.log('[Border] Toggle called, current:', borderVisible);
    
    borderVisible = !borderVisible;
    
    if (borderVisible) {
        document.body.classList.add('show-border');
        showNotification('í…Œë‘ë¦¬ í‘œì‹œ');
        console.log('[Border] ON');
    } else {
        document.body.classList.remove('show-border');
        showNotification('í…Œë‘ë¦¬ ìˆ¨ê¹€');
        console.log('[Border] OFF');
    }
    
    currentSettings.borderVisible = borderVisible;
    saveCurrentSettings();
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen?.();
    } else {
        document.exitFullscreen?.();
    }
}

function handleQuickAction(action) {
    console.log('[QuickAction] Received:', action);
    
    switch(action) {
        case 'font-up':
            currentFontSize = Math.min(200, currentFontSize + 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`ê¸€ì í¬ê¸°: ${currentFontSize}px`);
            break;
        case 'font-down':
            currentFontSize = Math.max(10, currentFontSize - 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`ê¸€ì í¬ê¸°: ${currentFontSize}px`);
            break;
        case 'transparent':
            toggleTransparent();
            break;
        case 'border':
            console.log('[QuickAction] Border action triggered');
            toggleBorder();
            break;
        case 'subtitle-toggle':
            toggleSubtitleVisibility();
            break;
        case 'scroll-toggle':
            toggleScrollEnabled();
            break;
        case 'always-on-top':
            toggleAlwaysOnTop();
            break;
        case 'save-text':
            saveTextToFile();
            break;
        case 'fullscreen':
            toggleFullscreen();
            break;
        case 'auto-position-top':
            autoPositionWindow('top');
            break;
        case 'auto-position-bottom':
            autoPositionWindow('bottom');
            break;
        case 'exit':
            console.log('[Exit] Exit action triggered');
            if (isElectron) {
                window.electronAPI.confirmExit().then(confirmed => {
                    console.log('[Exit] Confirmation result:', confirmed);
                    if (confirmed) {
                        console.log('[Exit] Closing app...');
                        try {
                            window.electronAPI.closeQuickMenu();
                        } catch (e) {
                            console.log('[Exit] Could not close Quick Menu:', e);
                        }
                        setTimeout(() => {
                            try {
                                window.electronAPI.exitApp();
                            } catch (err) {
                                console.error('[Exit] exitApp failed, using window.close:', err);
                                window.close();
                            }
                        }, 100);
                    } else {
                        console.log('[Exit] User cancelled exit');
                    }
                }).catch(err => {
                    console.error('[Exit] Error during exit confirmation:', err);
                    if (confirm('ì•±ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                        try {
                            window.electronAPI.exitApp();
                        } catch (e) {
                            window.close();
                        }
                    }
                });
            } else {
                if (confirm('ì•±ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    window.close();
                }
            }
            break;
    }
}

function showNotification(message, duration = 2000) {
    const notif = document.getElementById('notification');
    notif.textContent = message;
    notif.classList.add('show');
    setTimeout(() => notif.classList.remove('show'), duration);
}

document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (isElectron) {
        window.electronAPI.openQuickMenu();
    }
});

document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    switch(e.key) {
        case 'Enter':
            e.preventDefault();
            toggleFullscreen();
            break;
        case 'h':
        case 'H':
            e.preventDefault();
            toggleSubtitleVisibility();
            break;
        case 's':
        case 'S':
            e.preventDefault();
            toggleScrollEnabled();
            break;
        case 't':
        case 'T':
            e.preventDefault();
            toggleAlwaysOnTop();
            break;
        case 'ArrowUp':
            e.preventDefault();
            handleQuickAction('font-up');
            break;
        case 'ArrowDown':
            e.preventDefault();
            handleQuickAction('font-down');
            break;
    }
});

document.body.addEventListener('dblclick', e => {
    console.log('[DblClick] Double click detected');
    toggleBorder();
});

function setupTouchEvents() {
    viewerText.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchMoved = false;
        
        longPressTimer = setTimeout(() => {
            if (!touchMoved && isElectron) {
                window.electronAPI.openQuickMenu();
            }
        }, CONFIG.LONG_PRESS_DURATION);
    }, { passive: true });
    
    viewerText.addEventListener('touchmove', () => {
        touchMoved = true;
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }, { passive: true });
    
    viewerText.addEventListener('touchend', (e) => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        
        if (!touchMoved) {
            const now = Date.now();
            if (now - lastTapTime < CONFIG.DOUBLE_TAP_DELAY) {
                toggleFullscreen();
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: true });
}

function setupMarginAdjusterTouch() {
    marginAdjuster.addEventListener('mousedown', startDrag);
    marginAdjuster.addEventListener('touchstart', startDrag, { passive: false });
    
    function startDrag(e) {
        if (e.type === 'touchstart') {
            e.preventDefault();
            startY = e.touches[0].clientY;
        } else {
            startY = e.clientY;
        }
        
        startOffset = marginOffset;
        isDragging = true;
        marginAdjuster.classList.add('dragging');
        
        const viewerHeight = document.getElementById('viewer').offsetHeight;
        maxMargin = viewerHeight - 100;
        
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('touchend', stopDrag);
    }
    
    function onDrag(e) {
        if (!isDragging) return;
        
        let currentY;
        if (e.type === 'touchmove') {
            e.preventDefault();
            currentY = e.touches[0].clientY;
        } else {
            currentY = e.clientY;
        }
        
        const deltaY = startY - currentY;
        marginOffset = Math.max(0, Math.min(maxMargin, startOffset + deltaY));
        
        marginAdjuster.style.bottom = marginOffset + 'px';
        
        const currentMarginBottom = parseInt(currentSettings.marginBottom) || 10;
        const newMarginBottom = currentMarginBottom + marginOffset;
        
        const mTop = parseInt(currentSettings.marginTop) || 10;
        const mLeft = parseInt(currentSettings.marginLeft) || 10;
        const mRight = parseInt(currentSettings.marginRight) || 10;
        
        viewerText.style.top = `${mTop}px`;
        viewerText.style.bottom = `${newMarginBottom}px`;
        viewerText.style.left = `${mLeft}px`;
        viewerText.style.right = `${mRight}px`;
        
        viewerText.scrollTop = viewerText.scrollHeight;
        
        currentSettings.marginBottom = newMarginBottom.toString();
    }
    
    function stopDrag() {
        if (!isDragging) return;
        
        isDragging = false;
        marginAdjuster.classList.remove('dragging');
        
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', stopDrag);
        
        saveCurrentSettings();
        
        marginOffset = 0;
        marginAdjuster.style.bottom = '0px';
        
        scrollToBottom();
    }
}

function handleFullscreenChange() {
    if (document.fullscreenElement) {
        showNotification('ì „ì²´í™”ë©´ ëª¨ë“œ');
    } else {
        showNotification('ì „ì²´í™”ë©´ í•´ì œ');
    }
}

if (isElectron) {
    window.electronAPI.on('deep-link-join', (data) => {
        const { channel, token } = data;
        console.log('[DeepLink] ì±„ë„ ì°¸ê°€ ìš”ì²­:', channel);
        
        if (channel) {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            channelCode = channel;
            initSocket();
        }
    });
    
    window.electronAPI.on('channel-code', (code) => {
        console.log('[Legacy] ì±„ë„ ì½”ë“œ ìˆ˜ì‹ :', code);
        
        if (socket) {
            socket.disconnect();
            socket = null;
        }
        channelCode = code;
        initSocket();
    });
    
    window.electronAPI.on('update-settings', (settings) => {
        applySettings(settings);
    });
    
    window.electronAPI.on('send-current-settings-to-menu', () => {
        window.electronAPI.sendSettingsToMenu(getCurrentSettings());
    });
    
    window.electronAPI.on('quick-action', (action) => {
        handleQuickAction(action);
    });
    
    window.electronAPI.on('always-on-top-changed', (newState) => {
        isAlwaysOnTop = newState;
        currentSettings.alwaysOnTop = newState;
        
        if (newState) {
            showNotification('í•­ìƒ ìœ„ í™œì„±í™”');
            updateAlwaysOnTopIndicator(true, true);
        } else {
            showNotification('í•­ìƒ ìœ„ ë¹„í™œì„±í™”');
            updateAlwaysOnTopIndicator(false, false);
        }
        
        saveCurrentSettings();
    });
}

window.addEventListener('load', () => {
    initializeBackground();
    
    setupTouchEvents();
    
    setupMarginAdjusterTouch();
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    
    resizeObserver = new ResizeObserver(() => {
        if (!isScrollManual) {
            scrollToBottom();
        }
    });
    resizeObserver.observe(viewerText);
    
    loadLastSettings();
    
    console.log('[Electron] ì±„ë„ ì—°ê²° ëŒ€ê¸° ì¤‘...');
    updateConnectionStatus('connecting', 'ì±„ë„ ì—°ê²° ëŒ€ê¸° ì¤‘...');
    
    setTimeout(() => {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            showNotification('ê¾¹ í„°ì¹˜: ì„¤ì •, ë”ë¸” í„°ì¹˜: ì „ì²´í™”ë©´, Hí‚¤: ìë§‰ ìˆ¨ê¹€', 5000);
        } else {
            showNotification('ë‹¨ì¶•í‚¤: Enter(ì „ì²´í™”ë©´), â†‘â†“(ê¸€ìí¬ê¸°), H(ìë§‰), S(ìŠ¤í¬ë¡¤), T(í•­ìƒìœ„)', 5000);
        }
    }, 3000);
});

window.addEventListener('beforeunload', () => {
    stopKeepalive();
    if (socket) socket.disconnect();
    if (resizeObserver) resizeObserver.disconnect();
    if (alwaysOnTopTimer) clearTimeout(alwaysOnTopTimer);
});
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Jua&family=Do+Hyeon&family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gothic+A1&family=IBM+Plex+Sans+KR&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        /* 기본 배경 - 투명창을 위해 rgba 사용 */
        html {
            background: rgba(0, 0, 0, 1);
        }
        
        body {
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0;
            background: rgba(0, 0, 0, 1); 
            color: #fff; 
            overflow: hidden;
        }
        
        /* 연결 상태 표시 */
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-family: 'Noto Sans KR', sans-serif;
            z-index: 10001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #connection-status.connecting {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }
        
        #connection-status.connected {
            background: rgba(40, 167, 69, 0.9);
            color: #fff;
        }
        
        #connection-status.disconnected {
            background: rgba(220, 53, 69, 0.9);
            color: #fff;
        }
        
        #connection-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        /* 드래그 헤더 - 상단 20px만 드래그 가능 */
        .drag-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: transparent;
            -webkit-app-region: drag;
            z-index: 9999;
            transition: background 0.3s ease;
        }
        
        /* 테두리 표시 시 드래그 헤더 보이기 */
        body.show-border .drag-header {
            background: rgba(0, 212, 255, 0.2);
            border-bottom: 1px solid rgba(0, 212, 255, 0.5);
        }
        
        /* 투명 모드 + 테두리 표시 시 */
        body.transparent-mode.show-border .drag-header {
            background: rgba(0, 212, 255, 0.15);
            border-bottom: 1px solid rgba(0, 212, 255, 0.4);
        }
        
        /* 투명 모드 */
        html.transparent-mode,
        body.transparent-mode {
            background: rgba(0, 0, 0, 0.01) !important;
        }
        
        body.transparent-mode #viewer {
            background: rgba(0, 0, 0, 0.01) !important;
            box-shadow: 0 0 1px rgba(0,0,0,0.01);
        }
        
        body.transparent-mode #viewer-text {
            color: white !important;
            text-shadow: 
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 2px rgba(0,0,0,1);
            -webkit-text-stroke: 0.5px black;
        }
        
        /* 테두리 - box-sizing으로 내부 크기 유지 */
        body.show-border {
            border: 4px solid #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);
            box-sizing: border-box;
        }
        
        body.transparent-mode.show-border {
            border: 4px solid #00d4ff;
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.8);
            box-sizing: border-box;
        }
        
        #viewer {
            position: relative;
            width: 100vw; 
            height: 100vh;
            font-size: 32px; 
            line-height: 1.5; 
            text-align: left;
            transition: background 0.3s;
            z-index: 1;
            padding: 40px 30px;
            box-sizing: border-box;
        }
        
        #viewer-text {
            position: absolute;
            top: 40px; 
            left: 30px; 
            right: 30px; 
            bottom: 40px;
            width: calc(100% - 60px);
            height: calc(100% - 80px);
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #8884 #0000;
            background: none;
            word-break: break-all;
            white-space: pre-wrap;
            padding: 0;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            text-align: inherit;
            line-height: inherit;
            transition: color 0.2s, background 0.2s;
            box-sizing: border-box;
        }
        
        #viewer-text::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        
        /* 스크롤바 숨김 클래스 */
        #viewer-text.hide-scrollbar {
            scrollbar-width: none;
        }
        
        #viewer-text.hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        
        /* 설정 아이콘 */
        #setting-icon {
            position: fixed;
            top: 18px; 
            left: 50%; 
            transform: translateX(-50%);
            width: 44px; 
            height: 44px;
            background: rgba(45,45,45,0.9);
            border: 1px solid #444;
            border-radius: 8px;
            z-index: 1000;
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'Consolas', 'Courier New', monospace;
        }
        
        #setting-icon.visible {
            opacity: 1;
        }
        
        #setting-icon:hover {
            background: rgba(58,58,58,0.95);
            border-color: #5a78ff;
            box-shadow: 0 4px 16px rgba(90,120,255,0.2);
        }
        
        #setting-icon svg { 
            width: 24px; 
            height: 24px; 
            fill: #a2c1ff; 
            transition: fill 0.2s ease;
        }
        
        #setting-icon:hover svg { 
            fill: #fff; 
        }
        
        /* 알림 */
        .notification {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 10000;
            display: none;
            pointer-events: none;
        }
        
        /* 애니메이션 효과 CSS */
        .shake { animation: shake 0.5s ease-in-out 3; }
        @keyframes shake { 0%,100%{transform:translateX(0);} 25%{transform:translateX(-5px);} 75%{transform:translateX(5px);} }
        .fade-in { animation: fadeIn 2s ease-in-out; }
        @keyframes fadeIn { 0%{opacity:0;transform:translateY(20px);} 100%{opacity:1;transform:translateY(0);} }
        .zoom { animation: zoom 1.5s ease-in-out; }
        @keyframes zoom { 0%{transform:scale(0.8);} 50%{transform:scale(1.1);} 100%{transform:scale(1);} }
        .gradient-text { background:linear-gradient(45deg,#ff6b6b,#4ecdc4,#45b7d1,#96ceb4);background-size:300% 300%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;animation:gradient-flow 3s ease infinite; }
        @keyframes gradient-flow { 0%{background-position:0% 50%;} 50%{background-position:100% 50%;} 100%{background-position:0% 50%;} }
        .neon { color:#fff;text-shadow:0 0 5px #00ffff,0 0 10px #00ffff,0 0 15px #00ffff,0 0 20px #00ffff;animation:neon-flicker 2s infinite alternate; }
        @keyframes neon-flicker { 0%,100%{text-shadow:0 0 5px #00ffff,0 0 10px #00ffff,0 0 15px #00ffff,0 0 20px #00ffff;} 50%{text-shadow:0 0 2px #00ffff,0 0 5px #00ffff,0 0 8px #00ffff,0 0 12px #00ffff;} }
        .typewriter { border-right:3px solid #fff;animation:typewriter-blink 1s infinite; }
        @keyframes typewriter-blink { 0%,50%{border-color:#fff;} 51%,100%{border-color:transparent;} }
        .rotate { animation: rotate-360 2s ease-in-out; }
        @keyframes rotate-360 { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
        .slide-left { animation: slideLeft 1s ease-out; }
        @keyframes slideLeft { 0%{transform:translateX(100%);opacity:0;} 100%{transform:translateX(0);opacity:1;} }
        .slide-right { animation: slideRight 1s ease-out; }
        @keyframes slideRight { 0%{transform:translateX(-100%);opacity:0;} 100%{transform:translateX(0);opacity:1;} }
        .bg-party { background:linear-gradient(45deg,#ff6b6b,#4ecdc4,#45b7d1,#96ceb4);background-size:400% 400%;animation:bg-party 3s ease infinite; }
        @keyframes bg-party { 0%{background-position:0% 50%;} 50%{background-position:100% 50%;} 100%{background-position:0% 50%;} }
    </style>
</head>
<body class="show-border">
    <div class="drag-header"></div>
    <div id="connection-status" class="connecting">
        <div class="status-dot"></div>
        <span>연결 중...</span>
    </div>
    <div id="viewer">
        <div id="viewer-text">자막 대기 중...</div>
        <div id="setting-icon" title="설정">
            <svg viewBox="0 0 24 24"><path d="M12 15.5A3.5 3.5 0 1 0 12 8.5a3.5 3.5 0 0 0 0 7zm7.43-2.9l1.77-1.02a1 1 0 0 0 .37-1.36l-1.68-2.92a1 1 0 0 0-1.28-.46l-1.77 1.02a7.03 7.03 0 0 0-1.52-.88l-.27-2A1 1 0 0 0 13.5 3h-3a1 1 0 0 0-1 .88l-.27 2a7.03 7.03 0 0 0-1.52.88l-1.77-1.02a1 1 0 0 0-1.36.37l-1.68 2.92a1 1 0 0 0 .37 1.36l1.77 1.02c-.09.32-.16.65-.22.99l-2 .27A1 1 0 0 0 3 10.5v3a1 1 0 0 0 .88 1l2 .27c.06.34.13.67.22.99l-1.77 1.02a1 1 0 0 0-.37 1.36l1.68 2.92a1 1 0 0 0 1.28.46l1.77-1.02c.47.34.97.64 1.52.88l.27 2A1 1 0 0 0 10.5 21h3a1 1 0 0 0 1-.88l.27-2c.55-.24 1.05-.54 1.52-.88l1.77 1.02a1 1 0 0 0 1.36-.37l1.68-2.92a1 1 0 0 0-.37-1.36l-1.77-1.02c.09-.32.16-.65.22-.99l2-.27A1 1 0 0 0 21 13.5v-3a1 1 0 0 0-.88-1l-2-.27a7.03 7.03 0 0 0-.22-.99zM12 17a5 5 0 1 1 0-10 5 5 0 0 1 0 10z"/></svg>
        </div>
    </div>
    
    <div class="notification" id="notification"></div>

    <script>
        // ElectronAPI 사용 가능 여부 확인
        const isElectron = window.electronAPI !== undefined;
        
        let channelCode = null;
        let socket = null;
        let isTransparent = false;
        let borderVisible = true;
        let lastClickTime = 0;
        
        const viewerText = document.getElementById('viewer-text');
        const settingIcon = document.getElementById('setting-icon');
        const connectionStatus = document.getElementById('connection-status');
        
        // 누적 텍스트 관리
        let accumulatedText = '';
        let activeStenographer = '1';
        let currentActiveInput = '';
        let lastProcessedText = '';
        
        // 연결 상태 업데이트 함수
        function updateConnectionStatus(status, message) {
            connectionStatus.className = status;
            connectionStatus.querySelector('span').textContent = message;
            
            if (status === 'connected') {
                setTimeout(() => {
                    connectionStatus.style.opacity = '0';
                }, 3000);
            } else {
                connectionStatus.style.opacity = '1';
            }
        }
        
        // Socket.IO 동적 로드 함수
        function loadSocketIO() {
            return new Promise((resolve, reject) => {
                if (typeof io !== 'undefined') {
                    console.log('[Socket.IO] 이미 로드됨');
                    resolve();
                    return;
                }
                
                const script = document.createElement('script');
                script.src = 'https://cdn.socket.io/4.5.4/socket.io.min.js';
                script.onload = () => {
                    console.log('[Socket.IO] 로드 성공');
                    resolve();
                };
                script.onerror = () => {
                    console.error('[Socket.IO] 로드 실패');
                    reject(new Error('Socket.IO 로드 실패'));
                };
                document.head.appendChild(script);
            });
        }
        
        // 채널 검증 및 접속
        async function verifyAndConnect(code) {
            channelCode = code;
            console.log('[Channel] 검증 및 접속 시도:', code);
            
            try {
                // 채널 검증 API 호출
                const response = await fetch(`https://81b5c4d8eea5.ngrok-free.app/api/channel/${code}/verify`, {
                    headers: {
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                const data = await response.json();
                
                if (data.exists) {
                    console.log('[Channel] 채널 확인됨, Socket.IO 로드 중...');
                    await loadSocketIO();
                    connectToSocket();
                } else {
                    console.error('[Channel] 채널이 존재하지 않음');
                    updateConnectionStatus('disconnected', '채널을 찾을 수 없음');
                    showNotification('채널을 찾을 수 없습니다');
                }
            } catch (error) {
                console.error('[Channel] 검증 실패:', error);
                updateConnectionStatus('disconnected', '연결 실패');
                showNotification('채널 확인 실패');
            }
        }
        
        // 딥링크로 채널 참가 (Electron에서 전달)
        if (isElectron) {
            window.electronAPI.on('deep-link-join', async (data) => {
                console.log('[DeepLink] 채널 참가 요청:', data);
                const { channel, token } = data;
                
                if (channel) {
                    // 기존 연결이 있으면 끊기
                    if (socket) {
                        socket.disconnect();
                        socket = null;
                    }
                    
                    // 새 채널로 접속
                    await verifyAndConnect(channel);
                }
            });
            
            // Legacy: 채널 코드 수신 (기존 방식 호환)
            window.electronAPI.on('channel-code', async (code) => {
                console.log('[Legacy] 채널 코드 수신:', code);
                await verifyAndConnect(code);
            });
        }
        
        // Socket.io 연결
        function connectToSocket() {
            try {
                const socketUrl = 'https://81b5c4d8eea5.ngrok-free.app';
                
                const socketOptions = {
                    transports: ['websocket', 'polling'],
                    upgrade: true,
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    reconnectionAttempts: 10,
                    timeout: 20000,
                    forceNew: true
                };
                
                console.log('[Socket] 연결 시도:', socketUrl);
                socket = io(socketUrl, socketOptions);
                
                socket.on('connect', () => {
                    console.log('[Socket] 연결 성공!');
                    console.log('[Socket] Socket ID:', socket.id);
                    updateConnectionStatus('connected', '연결됨');
                    showNotification('서버 연결 성공');
                    
                    console.log('[Socket] 채널 참가:', channelCode);
                    socket.emit('join_channel', { 
                        channel: channelCode, 
                        role: 'viewer'
                    });
                });
                
                socket.on('connect_error', (error) => {
                    console.error('[Socket] 연결 에러:', error.message);
                    updateConnectionStatus('disconnected', '연결 실패');
                });
                
                socket.on('disconnect', (reason) => {
                    console.log('[Socket] 연결 끊김:', reason);
                    updateConnectionStatus('disconnected', '연결 끊김');
                });
                
                socket.on('reconnect_attempt', (attemptNumber) => {
                    console.log('[Socket] 재연결 시도:', attemptNumber);
                    updateConnectionStatus('connecting', `재연결 시도 중... (${attemptNumber})`);
                });
                
                socket.on('reconnect', () => {
                    console.log('[Socket] 재연결 성공');
                    updateConnectionStatus('connected', '재연결됨');
                    socket.emit('join_channel', { 
                        channel: channelCode, 
                        role: 'viewer'
                    });
                });
                
                socket.on('joined_channel', (data) => {
                    console.log('[Socket] 채널 참가 성공:', data);
                    showNotification(`채널 ${channelCode} 참가 완료`);
                    socket.emit('request_sync', { channel: channelCode });
                });
                
                socket.on('error', (error) => {
                    console.error('[Socket] 에러:', error);
                    if (error.message && error.message.includes('Channel not found')) {
                        showNotification('채널을 찾을 수 없습니다');
                        updateConnectionStatus('disconnected', '채널 없음');
                    }
                });
                
                socket.on('sync_accumulated', (data) => {
                    console.log('[Socket] 누적 텍스트 동기화:', data);
                    
                    if (data.accumulatedText !== undefined) {
                        accumulatedText = data.accumulatedText;
                        currentActiveInput = '';
                        updateViewerDisplay(accumulatedText, true);
                        console.log('[동기화] 누적 텍스트 설정:', accumulatedText);
                    }
                    
                    if (!data.activeStenographer) {
                        console.log('[동기화] 활성 속기사 정보 없음, 상태 요청');
                        socket.emit('get_channel_state', { channel: channelCode });
                    } else {
                        activeStenographer = data.activeStenographer === 'steno1' ? '1' : '2';
                        console.log('[동기화] 활성 속기사:', activeStenographer);
                    }
                });
                
                socket.on('channel_state', (data) => {
                    console.log('[Socket] 채널 상태:', data);
                    if (data.state) {
                        if (data.state.activeStenographer) {
                            activeStenographer = data.state.activeStenographer === 'steno1' ? '1' : '2';
                            console.log('[상태] 활성 속기사:', activeStenographer);
                        }
                        if (data.state.accumulatedText !== undefined) {
                            accumulatedText = data.state.accumulatedText;
                            currentActiveInput = '';
                            updateViewerDisplay(accumulatedText, true);
                        }
                    }
                });
                
                socket.on('steno_input', (data) => {
                    console.log('[Socket] 실시간 입력:', {
                        role: data.role,
                        text: data.text,
                        activeStenographer: activeStenographer,
                        dataLength: data.text ? data.text.length : 0
                    });
                    
                    let inputRole;
                    if (data.role === 'steno1' || data.role === '1') {
                        inputRole = '1';
                    } else if (data.role === 'steno2' || data.role === '2') {
                        inputRole = '2';
                    } else {
                        inputRole = data.role;
                    }
                    
                    console.log('[입력] 매핑된 역할:', inputRole, '현재 활성:', activeStenographer);
                    
                    if (inputRole === activeStenographer) {
                        currentActiveInput = data.text || '';
                        const fullText = accumulatedText + currentActiveInput;
                        updateViewerDisplay(fullText, false);
                        console.log('[표시] 텍스트 업데이트:', fullText.length, '자');
                    }
                });
                
                socket.on('switch_role', (data) => {
                    console.log('[Socket] 역할 전환:', data);
                    
                    if (data.newActive === 'steno1' || data.newActive === '1') {
                        activeStenographer = '1';
                    } else if (data.newActive === 'steno2' || data.newActive === '2') {
                        activeStenographer = '2';
                    }
                    
                    if (data.accumulatedText !== undefined) {
                        accumulatedText = data.accumulatedText;
                        currentActiveInput = '';
                        updateViewerDisplay(accumulatedText, true);
                    }
                    
                    showNotification(`속기사 ${activeStenographer} 활성화`);
                });
                
                socket.on('clear_text', () => {
                    console.log('[Socket] 텍스트 클리어');
                    accumulatedText = '';
                    currentActiveInput = '';
                    updateViewerDisplay('', true);
                    showNotification('텍스트 초기화됨');
                });
                
                socket.on('viewer_text_update', (data) => {
                    console.log('[Socket] viewer_text_update 이벤트:', data);
                    if (data.text !== undefined) {
                        viewerText.textContent = data.text || '자막 대기 중...';
                        viewerText.scrollTop = viewerText.scrollHeight;
                    }
                });
                
                socket.onAny((eventName, ...args) => {
                    console.log('[Socket Event]', eventName, JSON.stringify(args, null, 2));
                });
                
            } catch (error) {
                console.error('[Socket] 연결 에러:', error);
                updateConnectionStatus('disconnected', '연결 실패: ' + error.message);
            }
        }
        
        // 애니메이션 트리거 변환 함수
        function processRealisticEmotions(text) {
            let processedText = text;
            let effectClass = '';
            
            if (text.includes('(진동)')) {
                processedText = text.replace(/\(진동\)/g, '📳');
                effectClass = 'shake';
            } else if (text.includes('(페이드)')) {
                processedText = text.replace(/\(페이드\)/g, '✨');
                effectClass = 'fade-in';
            } else if (text.includes('(확대)')) {
                processedText = text.replace(/\(확대\)/g, '🔍');
                effectClass = 'zoom';
            } else if (text.includes('(무지개)')) {
                processedText = text.replace(/\(무지개\)/g, '🌈');
                effectClass = 'gradient-text';
            } else if (text.includes('(네온)')) {
                processedText = text.replace(/\(네온\)/g, '💡');
                effectClass = 'neon';
            } else if (text.includes('(타자기)')) {
                processedText = text.replace(/\(타자기\)/g, '⌨️');
                effectClass = 'typewriter';
            } else if (text.includes('(회전)')) {
                processedText = text.replace(/\(회전\)/g, '🔄');
                effectClass = 'rotate';
            } else if (text.includes('(왼슬라이드)')) {
                processedText = text.replace(/\(왼슬라이드\)/g, '←');
                effectClass = 'slide-left';
            } else if (text.includes('(오른슬라이드)')) {
                processedText = text.replace(/\(오른슬라이드\)/g, '→');
                effectClass = 'slide-right';
            } else if (text.includes('(파티)')) {
                processedText = text.replace(/\(파티\)/g, '🎉');
                effectClass = 'bg-party';
            }
            
            return { text: processedText, effect: effectClass };
        }
        
        // 1단어 지연 처리 함수
        function updateViewerDisplay(fullText, isImmediate = false) {
            let displayText = '';
            if (isImmediate) {
                displayText = fullText;
            } else {
                if (fullText.endsWith(' ')) {
                    displayText = fullText;
                } else {
                    const words = fullText.split(' ');
                    if (words.length > 1) {
                        displayText = words.slice(0, -1).join(' ') + ' ';
                    } else {
                        displayText = '';
                    }
                }
            }
            
            const { text, effect } = processRealisticEmotions(displayText);
            viewerText.textContent = text || '자막 대기 중...';
            viewerText.className = effect || '';
            viewerText.scrollTop = viewerText.scrollHeight;
        }
        
        // 설정 아이콘 표시
        let isMouseInTopArea = false;
        let isMouseOnIcon = false;
        
        function updateIconVisibility() {
            if (isMouseInTopArea || isMouseOnIcon) {
                settingIcon.classList.add('visible');
            } else {
                settingIcon.classList.remove('visible');
            }
        }
        
        document.addEventListener('mousemove', e => {
            isMouseInTopArea = e.clientY < 100;
            updateIconVisibility();
        });
        
        settingIcon.addEventListener('mouseenter', () => {
            isMouseOnIcon = true;
            updateIconVisibility();
        });
        
        settingIcon.addEventListener('mouseleave', () => {
            isMouseOnIcon = false;
            updateIconVisibility();
        });
        
        // 옵션 패널 토글
        settingIcon.addEventListener('click', e => {
            e.stopPropagation();
            
            if (!isElectron) return;
            
            const currentSettings = {
                bgColor: '#000000',
                bgAlpha: '100',
                fontColor: '#ffffff',
                fontSize: '32',
                fontFamily: 'sans-serif',
                outlineOn: false,
                outlineColor: '#000000',
                outlineWidth: '2',
                shadowOn: false,
                shadowColor: '#000000',
                shadowBlur: '3',
                shadowDistance: '2',
                isTransparent: isTransparent
            };
            
            window.electronAPI.openOptions(currentSettings);
        });
        
        // 더블클릭 감지
        document.addEventListener('mousedown', (e) => {
            if (e.target.closest('#setting-icon')) return;
            
            const now = Date.now();
            if (now - lastClickTime < 300) {
                e.preventDefault();
                toggleBorder();
            }
            lastClickTime = now;
        });
        
        // 테두리 토글
        function toggleBorder() {
            borderVisible = !borderVisible;
            
            if (borderVisible) {
                document.body.classList.add('show-border');
                showNotification('테두리 표시');
            } else {
                document.body.classList.remove('show-border');
                showNotification('테두리 숨김');
            }
        }
        
        // 우클릭 메뉴
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            
            if (!isElectron) return;
            
            const isScrollbarHidden = viewerText.classList.contains('hide-scrollbar');
            
            window.electronAPI.showContextMenu({
                isTransparent: isTransparent,
                isScrollbarHidden: isScrollbarHidden,
                x: e.clientX,
                y: e.clientY
            });
        });
        
        // Electron IPC 이벤트 리스너 (Electron 환경에서만)
        if (isElectron) {
            // 투명 배경 토글
            window.electronAPI.on('toggle-transparent', () => {
                isTransparent = !isTransparent;
                
                if (isTransparent) {
                    document.documentElement.classList.add('transparent-mode');
                    document.body.classList.add('transparent-mode');
                    document.documentElement.style.backgroundColor = 'rgba(0,0,0,0.01)';
                    document.body.style.backgroundColor = 'rgba(0,0,0,0.01)';
                    document.getElementById('viewer').style.backgroundColor = 'rgba(0,0,0,0.01)';
                    document.body.classList.add('show-border');
                    borderVisible = true;
                    showNotification('투명 배경 활성화');
                    window.electronAPI.toggleTransparent(true);
                } else {
                    document.documentElement.classList.remove('transparent-mode');
                    document.body.classList.remove('transparent-mode');
                    document.documentElement.style.backgroundColor = '';
                    document.body.style.backgroundColor = '';
                    document.getElementById('viewer').style.backgroundColor = '';
                    showNotification('기본 배경 활성화');
                    window.electronAPI.toggleTransparent(false);
                }
            });
            
            // 항상 위 상태 변경
            window.electronAPI.on('always-on-top-changed', (enabled) => {
                showNotification(enabled ? '항상 위 활성화' : '항상 위 비활성화');
            });
            
            // 설정 업데이트
            window.electronAPI.on('update-settings', (settings) => {
                // 설정 적용 로직
                console.log('[Settings] 업데이트:', settings);
            });
            
            // 스크롤바 토글
            window.electronAPI.on('toggle-scrollbar', () => {
                viewerText.classList.toggle('hide-scrollbar');
                const isHidden = viewerText.classList.contains('hide-scrollbar');
                showNotification(isHidden ? '스크롤바 숨김' : '스크롤바 표시');
            });
        }
        
        // 알림 표시
        function showNotification(message) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }
        
        // ESC 키
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && isElectron) {
                window.electronAPI.exitFullscreen();
            }
        });
        
        // 개발 모드 테스트용 (localhost에서만)
        if (!isElectron && window.location.hostname === 'localhost') {
            setTimeout(() => {
                console.log('[개발모드] 테스트 채널 자동 연결');
                verifyAndConnect('AAAAAA');
            }, 1000);
        }
    </script>
</body>
</html>

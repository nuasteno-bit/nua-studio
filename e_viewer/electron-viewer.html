<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>NUA 자막 뷰어</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=Jua&family=Do+Hyeon&family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gothic+A1&family=IBM+Plex+Sans+KR&family=Pretendard:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            background: transparent;
        }
        
        body {
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0;
            background: transparent;
            color: #fff; 
            overflow: hidden;
            min-width: 400px;   
            min-height: 300px;
            font-family: 'Noto Sans KR', sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-family: 'Pretendard', sans-serif;
            z-index: 10001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #connection-status.connecting {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }
        
        #connection-status.connected {
            background: rgba(40, 167, 69, 0.9);
            color: #fff;
        }
        
        #connection-status.disconnected {
            background: rgba(220, 53, 69, 0.9);
            color: #fff;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }
        
        .drag-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: transparent;
            -webkit-app-region: drag;
            z-index: 9999;
            transition: background 0.3s ease;
            cursor: move;
        }
        
        .drag-header:hover {
            background: rgba(0, 240, 255, 0.05);
        }
        
        body.show-border .drag-header {
            background: rgba(0, 240, 255, 0.1);
            border-bottom: 1px solid rgba(0, 240, 255, 0.3);
        }
        
        html.transparent-mode,
        body.transparent-mode {
            background: transparent !important;
        }
        
        body.transparent-mode #viewer {
            background: transparent !important;
        }
        
        body.show-border {
            border: 8px solid;
            border-image: linear-gradient(90deg, 
                #00f0ff 0%, 
                #00c4d4 25%, 
                #0099ff 50%, 
                #00c4d4 75%, 
                #00f0ff 100%
            ) 1;
            box-shadow: 
                inset 0 0 40px rgba(0, 240, 255, 0.8),
                0 0 40px rgba(0, 240, 255, 0.6),
                inset 0 0 20px rgba(0, 196, 212, 0.5),
                0 0 20px rgba(0, 196, 212, 0.4);
            box-sizing: border-box;
            animation: borderGlow 2s linear infinite;
        }
        
        @keyframes borderGlow {
            0% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
            25% {
                border-image: linear-gradient(180deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            50% {
                border-image: linear-gradient(270deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 153, 255, 0.8),
                    0 0 40px rgba(0, 153, 255, 0.6),
                    inset 0 0 20px rgba(0, 240, 255, 0.5),
                    0 0 20px rgba(0, 240, 255, 0.4);
            }
            75% {
                border-image: linear-gradient(360deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            100% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
        }
        
        #viewer {
            position: relative;
            width: 100%; 
            height: 100%;
            font-size: 32px; 
            line-height: 1.5; 
            text-align: left;
            transition: none; /* 깜박임 제거 */
            z-index: 1;
            padding: 10px 10px;
            box-sizing: border-box;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            background: transparent;
        }
        
        #viewer-text {
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            overflow-y: auto;
            overflow-anchor: auto;
            scrollbar-gutter: stable both-edges;
            scrollbar-width: thin;
            scrollbar-color: #8884 #0000;
            background: none;
            word-break: break-all;
            white-space: pre-wrap;
            padding: 0;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            text-align: inherit;
            line-height: inherit;
            letter-spacing: 0;
            transition: color 0.2s, opacity 0.5s ease; /* background transition 제거 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 0px;
            scroll-behavior: auto;
        }
        
        #viewer-text.hidden {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #viewer-text.align-middle {
            justify-content: center;
            height: calc(100% - 20px);
        }
        
        #viewer-text.align-bottom {
            justify-content: flex-end;
            height: calc(100% - 20px);
        }
        
        #viewer-text::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        
        #viewer-text::-webkit-scrollbar-thumb {
            background: rgba(180,180,180,0.18);
            border-radius: 4px;
        }
        
        .notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #000, #333);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 13px;
            font-family: 'Pretendard', sans-serif;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10002;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }
        
        .content-wrapper {
            width: 100%;
            min-height: min-content; /* 컨텐츠 최소 높이 */
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 0px;
        }
        
        .speaker-line {
            display: flex;
            align-items: baseline;
            padding: 0;
            margin: 0;
            min-height: auto;
            box-sizing: border-box;
            line-height: inherit;
            flex-shrink: 0;
        }
        
        .speaker-name {
            background: rgba(255, 255, 255, 0.08);
            padding: 3px 15px;
            border-radius: 4px;
            font-weight: 700;
            margin-right: 20px;
            white-space: nowrap;
            flex-shrink: 0;
            line-height: inherit;
            display: inline-flex;
            align-items: baseline;
        }
        
        .speaker-divider {
            width: 2px;
            align-self: stretch;
            background: rgba(255, 255, 255, 0.3);
            margin-right: 20px;
            flex-shrink: 0;
        }
        
        .speaker-pipe {
            color: rgba(255, 255, 255, 0.4);
            margin: 0 20px;
            font-weight: 300;
            line-height: inherit;
        }
        
        .speaker-content {
            flex: 1;
            line-height: inherit;
            min-width: 0;
            word-break: break-word;
        }
        
        .speaker-line.no-speaker {
            display: flex;
            align-items: baseline;
        }
        
        /* 여백 조절기 */
        #margin-adjuster {
            position: fixed;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.2), rgba(90,120,255,0.5));
            border-top: 2px solid #5a78ff;
            cursor: ns-resize;
            z-index: 100;
            display: none;
            transition: all 0.2s ease;
            user-select: none;
            touch-action: none;
        }
        
        #margin-adjuster.active {
            display: block;
        }
        
        #margin-adjuster:hover {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.4), rgba(90,120,255,0.7));
            border-top-color: #7b9eff;
        }
        
        #margin-adjuster.dragging {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.6), rgba(90,120,255,0.8));
            border-top-color: #fff;
        }
        
        #margin-adjuster::before {
            content: "⋮⋮⋮";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #5a78ff;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body class="show-border">
    <div class="drag-header"></div>
    
    <div id="connection-status" class="connecting">
        <div class="status-dot"></div>
        <span>연결 중...</span>
    </div>
    
    <div id="viewer">
        <div id="viewer-text">채널 연결 대기 중...</div>
    </div>
    
    <!-- 여백 조절기 -->
    <div id="margin-adjuster"></div>
    
    <div class="notification" id="notification"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script>
const isElectron = typeof window.electronAPI !== 'undefined';

const CONFIG = {
    SOCKET_URL: 'https://live.nuastudio.co.kr',
    RECONNECT_DELAY: 1000,
    RECONNECT_DELAY_MAX: 5000,
    KEEPALIVE_INTERVAL: 15 * 60 * 1000,
    LONG_PRESS_DURATION: 500,
    DOUBLE_TAP_DELAY: 300
};

let channelCode = null;

// 터치 관련 변수
let longPressTimer = null;
let lastTapTime = 0;
let touchStartTime = 0;
let touchMoved = false;
let socket = null;
let keepaliveInterval = null;
let accumulatedText = '';
let activeStenographer = '1';
let currentActiveInput = '';
let isInitialConnection = true;
let lastTextSentTime = 0;
let lastAccumulatedLength = 0;
let ignoreInputUntil = 0;
let previousInput = '';
let previousDisplay = '';
let isSubtitleHidden = false;
let wasHiddenBeforeInput = false;
let lastRenderedText = '';
let isScrollManual = false;
let isTransparent = false;
let borderVisible = true;
let currentFontSize = 32;
let resizeObserver = null;

// 여백 조절기
let marginAdjusterEnabled = false;
let marginOffset = 0;
let isDragging = false;
let startY = 0;
let startOffset = 0;
let maxMargin = 0;

// 현재 설정값들
let currentSettings = {
    bgColor: '#000000',
    bgAlpha: '100',
    fontColor: '#ffffff',
    fontSize: '32',
    fontFamily: "'Noto Sans KR', sans-serif",
    letterSpacing: '0',
    lineHeight: '1.5',
    outlineOn: false,
    outlineColor: '#000000',
    outlineWidth: '2',
    shadowOn: false,
    shadowColor: '#000000',
    shadowBlur: '3',
    shadowX: '2',
    shadowY: '2',
    textAlign: 'left',
    verticalAlign: 'top',
    marginTop: '10',
    marginBottom: '10',
    marginLeft: '10',
    marginRight: '10',
    speakerEnabled: true,
    speakerStyle: 'divider',
    speakerBgEnabled: true,
    speakerBgColor: '#ffffff',
    speakerBgAlpha: '8',
    colorDividerEnabled: false,
    dividerColor: '#4A90E2',
    subtitleVisible: true,
    marginAdjusterEnabled: false,
    isTransparent: false,
    borderVisible: true
};

const viewerText = document.getElementById('viewer-text');
const connectionStatus = document.getElementById('connection-status');
const marginAdjuster = document.getElementById('margin-adjuster');

function initializeBackground() {
    const defaultBg = 'rgba(0, 0, 0, 1)';
    document.body.style.backgroundColor = defaultBg;
    document.getElementById('viewer').style.backgroundColor = defaultBg;
}

function loadLastSettings() {
    const saved = localStorage.getItem('lastUsedSettings');
    if (saved) {
        currentSettings = JSON.parse(saved);
        applySettings(currentSettings);
    }
}

function saveCurrentSettings() {
    localStorage.setItem('lastUsedSettings', JSON.stringify(currentSettings));
}

function getCurrentSettings() {
    return { ...currentSettings };
}

function applySettings(settings) {
    currentSettings = { ...currentSettings, ...settings };
    
    if (settings.bgColor && settings.bgAlpha !== undefined) {
        const bgHex = settings.bgColor;
        const alpha = parseInt(settings.bgAlpha) / 100;
        const safeAlpha = Math.max(alpha, 0.01);
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${safeAlpha})`;
        
        document.getElementById('viewer').style.backgroundColor = bgRgba;
        if (!isTransparent) {
            document.body.style.backgroundColor = bgRgba;
        }
    }
    
    if (settings.fontSize) {
        currentFontSize = parseInt(settings.fontSize);
        viewerText.style.fontSize = settings.fontSize + 'px';
    }
    
    if (settings.fontColor) {
        viewerText.style.color = settings.fontColor;
    }
    
    if (settings.fontFamily) {
        viewerText.style.fontFamily = settings.fontFamily;
    }
    
    if (settings.letterSpacing !== undefined) {
        viewerText.style.letterSpacing = settings.letterSpacing + 'px';
    }
    
    if (settings.lineHeight) {
        viewerText.style.lineHeight = parseFloat(settings.lineHeight) + 'em';
    }
    
    if (settings.textAlign) {
        viewerText.style.textAlign = settings.textAlign;
    }
    
    if (settings.verticalAlign) {
        viewerText.classList.remove('align-middle', 'align-bottom', 'align-top');
        if (settings.verticalAlign === 'middle') {
            viewerText.classList.add('align-middle');
        } else if (settings.verticalAlign === 'bottom') {
            viewerText.classList.add('align-bottom');
        } else if (settings.verticalAlign === 'top') {
            viewerText.classList.add('align-top');
        }
        // 세로 정렬 변경 후 스크롤 위치 조정
        requestAnimationFrame(() => {
            if (settings.verticalAlign !== 'top') {
                viewerText.scrollTop = viewerText.scrollHeight;
            }
        });
    }
    
    if (settings.marginTop !== undefined && settings.marginBottom !== undefined && 
        settings.marginLeft !== undefined && settings.marginRight !== undefined) {
        const mTop = parseInt(settings.marginTop) || 10;
        const mBottom = parseInt(settings.marginBottom) || 10;
        const mLeft = parseInt(settings.marginLeft) || 10;
        const mRight = parseInt(settings.marginRight) || 10;
        
        viewerText.style.padding = `${mTop}px ${mRight}px ${mBottom}px ${mLeft}px`;
        viewerText.style.width = `calc(100% - ${mLeft + mRight}px)`;
        viewerText.style.height = `calc(100% - ${mTop + mBottom + 20}px)`;
    }
    
    let textShadow = '';
    if (settings.outlineOn && parseFloat(settings.outlineWidth) > 0) {
        const outline = `-${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, -${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}`;
        textShadow = outline;
    }
    if (settings.shadowOn && parseFloat(settings.shadowBlur) > 0) {
        const dropShadow = `${settings.shadowX}px ${settings.shadowY}px ${settings.shadowBlur}px ${settings.shadowColor}`;
        textShadow = textShadow ? textShadow + ', ' + dropShadow : dropShadow;
    }
    viewerText.style.textShadow = textShadow;
    
    if (settings.subtitleVisible !== undefined) {
        isSubtitleHidden = !settings.subtitleVisible;
        if (isSubtitleHidden) {
            viewerText.classList.add('hidden');
        } else {
            viewerText.classList.remove('hidden');
        }
    }
    
    if (settings.marginAdjusterEnabled !== undefined) {
        marginAdjusterEnabled = settings.marginAdjusterEnabled;
        if (marginAdjusterEnabled) {
            marginAdjuster.classList.add('active');
            marginAdjuster.style.bottom = marginOffset + 'px';
        } else {
            marginAdjuster.classList.remove('active');
        }
    }
    
    lastRenderedText = '';
    const currentText = accumulatedText + currentActiveInput;
    updateDisplay(currentText, true);
    
    saveCurrentSettings();
}

function initSocket() {
    console.log('[Socket] 초기화:', CONFIG.SOCKET_URL);
    
    socket = io(CONFIG.SOCKET_URL, {
        transports: ['websocket', 'polling'],
        upgrade: true,
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: CONFIG.RECONNECT_DELAY,
        reconnectionDelayMax: CONFIG.RECONNECT_DELAY_MAX,
        timeout: 20000,
        forceNew: true
    });
    
    socket.on('connect', () => {
        console.log('[Socket] 연결 성공');
        updateConnectionStatus('connected', '연결됨');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('connect_error', (error) => {
        console.error('[Socket] 연결 에러:', error.message);
        updateConnectionStatus('disconnected', '연결 실패');
    });
    
    socket.on('disconnect', (reason) => {
        console.log('[Socket] 연결 끊김:', reason);
        updateConnectionStatus('disconnected', '연결 끊김');
        stopKeepalive();
    });
    
    socket.on('reconnect', () => {
        console.log('[Socket] 재연결 성공');
        updateConnectionStatus('connected', '재연결됨');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('joined_channel', (data) => {
        console.log('[Channel] 참가 성공');
        viewerText.textContent = '자막 대기 중...';
        socket.emit('request_sync', { channel: channelCode });
    });
    
    socket.on('channel_state', (data) => {
        console.log('[State] 채널 상태:', data);
        if (data.state) {
            if (data.state.activeStenographer) {
                activeStenographer = data.state.activeStenographer === 'steno1' ? '1' : '2';
            }
            if (data.state.accumulatedText !== undefined) {
                accumulatedText = data.state.accumulatedText;
                currentActiveInput = '';
                previousInput = '';
                previousDisplay = '';
                updateDisplay(accumulatedText, true);
            }
        }
    });
    
    socket.on('sync_accumulated', (data) => {
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
        
        if (data.activeStenographer) {
            activeStenographer = data.activeStenographer === 'steno1' ? '1' : '2';
        }
    });
    
    socket.on('steno_input', (data) => {
        const roleNumber = data.role === 'steno1' ? '1' : data.role === 'steno2' ? '2' : data.role;
        
        if (roleNumber === activeStenographer) {
            const now = Date.now();
            const inputLength = (data.text || '').length;
            
            if (now < ignoreInputUntil && inputLength < lastAccumulatedLength - 10) {
                return;
            }
            
            currentActiveInput = data.text || '';
            const fullText = accumulatedText + currentActiveInput;
            updateDisplay(fullText, false);
        }
    });
    
    socket.on('switch_role', (data) => {
        activeStenographer = data.newActive === 'steno1' ? '1' : '2';
        
        if (data.accumulatedText !== undefined) {
            accumulatedText = data.accumulatedText;
            currentActiveInput = '';
            previousInput = '';
            previousDisplay = '';
            updateDisplay(accumulatedText, true);
        }
    });
    
    socket.on('text_sent', (data) => {
        lastTextSentTime = Date.now();
        lastAccumulatedLength = (data.accumulatedText || '').length;
        ignoreInputUntil = Date.now() + 1000;
        
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
    });
    
    socket.on('clear_text', () => {
        accumulatedText = '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        lastRenderedText = '';
        updateDisplay('', true);
    });
}

function joinChannel() {
    if (!socket || !socket.connected) return;
    
    console.log('[Channel] 참가 요청:', channelCode);
    socket.emit('join_channel', {
        channel: channelCode,
        role: 'viewer',
        requestSync: true
    });
}

function startKeepalive() {
    stopKeepalive();
    keepaliveInterval = setInterval(() => {
        if (socket && socket.connected) {
            socket.emit('keepalive', { channel: channelCode, timestamp: Date.now() });
        }
    }, CONFIG.KEEPALIVE_INTERVAL);
}

function stopKeepalive() {
    if (keepaliveInterval) {
        clearInterval(keepaliveInterval);
        keepaliveInterval = null;
    }
}

function updateConnectionStatus(status, message) {
    connectionStatus.className = status;
    connectionStatus.querySelector('span').textContent = message;
    
    if (status === 'connected' && isInitialConnection) {
        setTimeout(() => {
            connectionStatus.style.opacity = '0';
            isInitialConnection = false;
        }, 3000);
    } else {
        connectionStatus.style.opacity = '1';
    }
}

function updateDisplay(text, isImmediate = false) {
    if (isSubtitleHidden && text && text.trim()) {
        if (wasHiddenBeforeInput || text.length > (previousInput ? previousInput.length : 0)) {
            toggleSubtitleVisibility(true);
            wasHiddenBeforeInput = false;
        }
    }
    
    let displayText = text;
    
    if (isImmediate) {
        previousInput = '';
        previousDisplay = '';
    } else {
        const isBackspace = previousInput.length > text.length;
        const onlySpaceRemoved = isBackspace && previousInput.endsWith(' ') && text === previousInput.slice(0, -1);
        
        if (text.length > 0) {
            if (text.endsWith(' ') || text.endsWith('\n')) {
                displayText = text;
            } else if (onlySpaceRemoved && previousDisplay) {
                displayText = previousDisplay.trimEnd();
            } else {
                const lastSpace = text.lastIndexOf(' ');
                const lastNewline = text.lastIndexOf('\n');
                const lastDelimiter = Math.max(lastSpace, lastNewline);
                
                if (lastDelimiter > -1) {
                    displayText = text.substring(0, lastDelimiter + 1);
                } else {
                    displayText = '';
                }
            }
        }
        
        previousInput = text;
        previousDisplay = displayText;
    }
    
    if (!currentActiveInput || currentActiveInput.trim().length === 0) {
        displayText = displayText.replace(/\n+$/, '');
    }
    
    const lines = displayText.split('\n');
    if (lines.length > 10000) {
        console.log('[Performance] 줄 수 초과:', lines.length, '→ 8,000줄로 정리');
        displayText = lines.slice(-8000).join('\n');
        if (isImmediate) {
            accumulatedText = displayText;
        }
    }
    
    const finalDisplayText = displayText || (channelCode ? '자막 대기 중...' : '채널 연결 대기 중...');
    if (finalDisplayText === lastRenderedText) return;
    
    renderFormattedText(finalDisplayText);
    lastRenderedText = finalDisplayText;
    
    // 자동 스크롤: 수동 스크롤이 아니면 항상 맨 아래로
    if (!isScrollManual) {
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                viewerText.scrollTop = viewerText.scrollHeight;
            });
        });
    }
}

viewerText.addEventListener('wheel', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

viewerText.addEventListener('touchstart', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

function renderFormattedText(text) {
    const lines = text.split('\n');
    const speakerEnabled = currentSettings.speakerEnabled;
    const speakerStyle = currentSettings.speakerStyle;
    const useBg = currentSettings.speakerBgEnabled;
    const useColorDivider = currentSettings.colorDividerEnabled;
    const bgAlpha = parseInt(currentSettings.speakerBgAlpha) / 100;
    const currentLineHeight = viewerText.style.lineHeight;
    
    viewerText.innerHTML = '';
    
    const vAlign = currentSettings.verticalAlign || 'top';
    const needsWrapper = vAlign === 'middle' || vAlign === 'bottom';
    
    let container = viewerText;
    if (needsWrapper) {
        const wrapper = document.createElement('div');
        wrapper.className = 'content-wrapper';
        viewerText.appendChild(wrapper);
        container = wrapper;
    }
    
    lines.forEach(line => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'speaker-line';
        lineDiv.style.lineHeight = currentLineHeight;
        
        if (speakerEnabled && line.startsWith('-') && line.includes(': ')) {
            const colonIndex = line.indexOf(': ');
            const speaker = line.substring(1, colonIndex).trim();
            const content = line.substring(colonIndex + 2);
            
            const speakerSpan = document.createElement('span');
            speakerSpan.className = 'speaker-name';
            speakerSpan.textContent = speaker;
            
            if (useBg) {
                const bgColor = currentSettings.speakerBgColor;
                const r = parseInt(bgColor.slice(1, 3), 16);
                const g = parseInt(bgColor.slice(3, 5), 16);
                const b = parseInt(bgColor.slice(5, 7), 16);
                speakerSpan.style.background = `rgba(${r}, ${g}, ${b}, ${bgAlpha})`;
            } else {
                speakerSpan.style.background = 'transparent';
            }
            
            lineDiv.appendChild(speakerSpan);
            
            if (speakerStyle === 'divider') {
                const divider = document.createElement('div');
                divider.className = 'speaker-divider';
                if (useColorDivider) {
                    divider.style.background = currentSettings.dividerColor;
                }
                lineDiv.appendChild(divider);
            } else if (speakerStyle === 'pipe') {
                const pipe = document.createElement('span');
                pipe.className = 'speaker-pipe';
                pipe.textContent = '|';
                if (useColorDivider) {
                    pipe.style.color = currentSettings.dividerColor;
                }
                lineDiv.appendChild(pipe);
            } else if (speakerStyle === 'minimal') {
                const divider = document.createElement('div');
                divider.className = 'speaker-divider';
                divider.style.width = '1px';
                divider.style.margin = '0 25px';
                if (useColorDivider) {
                    divider.style.background = currentSettings.dividerColor;
                } else {
                    divider.style.background = 'rgba(255, 255, 255, 0.2)';
                }
                lineDiv.appendChild(divider);
            }
            
            const contentSpan = document.createElement('span');
            contentSpan.className = 'speaker-content';
            contentSpan.textContent = content || '\u200B';
            lineDiv.appendChild(contentSpan);
        } else {
            lineDiv.classList.add('no-speaker');
            const contentSpan = document.createElement('span');
            contentSpan.className = 'speaker-content';
            contentSpan.textContent = line || '\u200B';
            lineDiv.appendChild(contentSpan);
        }
        
        container.appendChild(lineDiv);
    });
}

function toggleSubtitleVisibility(forceShow = null) {
    if (forceShow !== null) {
        isSubtitleHidden = !forceShow;
    } else {
        isSubtitleHidden = !isSubtitleHidden;
    }
    
    if (isSubtitleHidden) {
        viewerText.classList.add('hidden');
        wasHiddenBeforeInput = true;
        currentSettings.subtitleVisible = false;
        showNotification('자막 숨김');
    } else {
        viewerText.classList.remove('hidden');
        wasHiddenBeforeInput = false;
        currentSettings.subtitleVisible = true;
        showNotification('자막 표시');
    }
    saveCurrentSettings();
}

function saveTextToFile() {
    const fullText = accumulatedText || '저장할 텍스트가 없습니다.';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `자막_${channelCode}_${timestamp}.txt`;
    
    const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showNotification(`텍스트 저장됨: ${filename}`);
}

function toggleTransparent() {
    console.log('[Transparent] Toggle called, current:', isTransparent);
    
    isTransparent = !isTransparent;
    currentSettings.isTransparent = isTransparent;
    
    if (isTransparent) {
        document.documentElement.classList.add('transparent-mode');
        document.body.classList.add('transparent-mode');
        const transparentBg = 'rgba(0, 0, 0, 0.01)';
        document.body.style.backgroundColor = transparentBg;
        document.getElementById('viewer').style.backgroundColor = transparentBg;
        if (isElectron) window.electronAPI.toggleTransparent(true);
        showNotification('투명 모드 켜짐');
    } else {
        document.documentElement.classList.remove('transparent-mode');
        document.body.classList.remove('transparent-mode');
        // 배경색 복원
        const bgHex = currentSettings.bgColor || '#000000';
        const alpha = parseInt(currentSettings.bgAlpha || '100') / 100;
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        document.body.style.backgroundColor = bgRgba;
        document.getElementById('viewer').style.backgroundColor = bgRgba;
        if (isElectron) window.electronAPI.toggleTransparent(false);
        showNotification('투명 모드 꺼짐');
    }
    
    saveCurrentSettings();
}

function toggleBorder() {
    console.log('[Border] Toggle called, current:', borderVisible);
    
    borderVisible = !borderVisible;
    
    if (borderVisible) {
        document.body.classList.add('show-border');
        showNotification('테두리 표시');
        console.log('[Border] ON');
    } else {
        document.body.classList.remove('show-border');
        showNotification('테두리 숨김');
        console.log('[Border] OFF');
    }
    
    currentSettings.borderVisible = borderVisible;
    saveCurrentSettings();
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen?.();
    } else {
        document.exitFullscreen?.();
    }
}

function handleQuickAction(action) {
    console.log('[QuickAction] Received:', action);
    
    switch(action) {
        case 'font-up':
            currentFontSize = Math.min(200, currentFontSize + 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`글자 크기: ${currentFontSize}px`);
            break;
        case 'font-down':
            currentFontSize = Math.max(10, currentFontSize - 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`글자 크기: ${currentFontSize}px`);
            break;
        case 'transparent':
            toggleTransparent();
            break;
        case 'border':
            console.log('[QuickAction] Border action triggered');
            toggleBorder();
            break;
        case 'subtitle-toggle':
            toggleSubtitleVisibility();
            break;
        case 'save-text':
            saveTextToFile();
            break;
        case 'fullscreen':
            toggleFullscreen();
            break;
        case 'exit':
            console.log('[Exit] Exit action triggered');
            if (isElectron) {
                window.electronAPI.confirmExit().then(confirmed => {
                    console.log('[Exit] Confirmation result:', confirmed);
                    if (confirmed) {
                        console.log('[Exit] Closing app...');
                        // Quick Menu도 닫기
                        try {
                            window.electronAPI.closeQuickMenu();
                        } catch (e) {
                            console.log('[Exit] Could not close Quick Menu:', e);
                        }
                        // 강제 종료 사용
                        setTimeout(() => {
                            try {
                                window.electronAPI.exitApp();
                            } catch (err) {
                                console.error('[Exit] exitApp failed, using window.close:', err);
                                window.close();
                            }
                        }, 100);
                    } else {
                        console.log('[Exit] User cancelled exit');
                    }
                }).catch(err => {
                    console.error('[Exit] Error during exit confirmation:', err);
                    // 에러 발생 시 일반 confirm 사용
                    if (confirm('앱을 종료하시겠습니까?')) {
                        try {
                            window.electronAPI.exitApp();
                        } catch (e) {
                            window.close();
                        }
                    }
                });
            } else {
                if (confirm('앱을 종료하시겠습니까?')) {
                    window.close();
                }
            }
            break;
    }
}

function showNotification(message, duration = 2000) {
    const notif = document.getElementById('notification');
    notif.textContent = message;
    notif.classList.add('show');
    setTimeout(() => notif.classList.remove('show'), duration);
}

document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (isElectron) {
        window.electronAPI.openQuickMenu();
    }
});

document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    switch(e.key) {
        case 'Enter':
            e.preventDefault();
            toggleFullscreen();
            break;
        case 'h':
        case 'H':
            e.preventDefault();
            toggleSubtitleVisibility();
            break;
        case 'ArrowUp':
            e.preventDefault();
            handleQuickAction('font-up');
            break;
        case 'ArrowDown':
            e.preventDefault();
            handleQuickAction('font-down');
            break;
    }
});

document.body.addEventListener('dblclick', e => {
    console.log('[DblClick] Double click detected');
    toggleBorder();
});

if (isElectron) {
    window.electronAPI.on('deep-link-join', (data) => {
        const { channel, token } = data;
        console.log('[DeepLink] 채널 참가 요청:', channel);
        
        if (channel) {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            channelCode = channel;
            initSocket();
        }
    });
    
    window.electronAPI.on('channel-code', (code) => {
        console.log('[Legacy] 채널 코드 수신:', code);
        
        if (socket) {
            socket.disconnect();
            socket = null;
        }
        channelCode = code;
        initSocket();
    });
    
    window.electronAPI.on('update-settings', (settings) => {
        applySettings(settings);
    });
    
    window.electronAPI.on('send-current-settings-to-menu', () => {
        window.electronAPI.sendSettingsToMenu(getCurrentSettings());
    });
    
    window.electronAPI.on('quick-action', (action) => {
        handleQuickAction(action);
    });
}

window.addEventListener('load', () => {
    initializeBackground();
    
    // 터치 이벤트 설정
    setupTouchEvents();
    
    // 여백 조절기 터치 지원
    setupMarginAdjusterTouch();
    
    // 전체화면 이벤트 리스너
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    
    // 리사이즈 최적화: 항상 맨 아래 유지 + 깜박임 제거
    resizeObserver = new ResizeObserver(() => {
        // 수동 스크롤 중이 아니면 항상 맨 아래로
        if (!isScrollManual) {
            // 이중 RAF로 레이아웃 재계산 후 스크롤
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    viewerText.scrollTop = viewerText.scrollHeight;
                });
            });
        }
    });
    resizeObserver.observe(viewerText);
    
    // 초기 설정 로드
    loadLastSettings();
    
    // 기본 세로 정렬이 없으면 flex-end 적용 (아래쪽 기준)
    if (!viewerText.classList.contains('align-middle') && 
        !viewerText.classList.contains('align-bottom') &&
        !viewerText.classList.contains('align-top')) {
        // 기본값: 아래쪽부터 채우기 (최신 글 우선)
        // CSS에서 이미 justify-content: flex-end로 설정됨
    }
    
    console.log('[Electron] 채널 연결 대기 중...');
    updateConnectionStatus('connecting', '채널 연결 대기 중...');
    
    // 단축키 안내
    setTimeout(() => {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            showNotification('꾹 터치: 설정, 더블 터치: 전체화면, H키: 자막 숨김', 5000);
        } else {
            showNotification('단축키: Enter(전체화면), ↑↓(글자크기), H(자막 숨김)', 5000);
        }
    }, 3000);
});

window.addEventListener('beforeunload', () => {
    stopKeepalive();
    if (socket) socket.disconnect();
    if (resizeObserver) resizeObserver.disconnect();
});
    </script>
</body>
</html>

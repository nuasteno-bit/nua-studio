<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>NUA 자막 뷰어</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=Jua&family=Do+Hyeon&family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gothic+A1&family=IBM+Plex+Sans+KR&family=Pretendard:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html {
            background: transparent;
        }
        
        body {
            width: 100vw; 
            height: 100vh; 
            margin: 0; 
            padding: 0;
            background: transparent;
            color: #fff; 
            overflow: hidden;
            min-width: 400px;   
            min-height: 300px;
            font-family: 'Noto Sans KR', sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            position: relative;
        }
        
        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-family: 'Pretendard', sans-serif;
            z-index: 10001;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #connection-status.connecting {
            background: rgba(255, 193, 7, 0.9);
            color: #000;
        }
        
        #connection-status.connected {
            background: rgba(40, 167, 69, 0.9);
            color: #fff;
        }
        
        #connection-status.disconnected {
            background: rgba(220, 53, 69, 0.9);
            color: #fff;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }
        
        #always-on-top-indicator {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 6px 12px;
            border-radius: 15px;
            font-size: 11px;
            font-family: 'Pretendard', sans-serif;
            background: rgba(0, 240, 255, 0.9);
            color: #000;
            z-index: 10001;
            display: none;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #always-on-top-indicator.active {
            display: flex;
            opacity: 1;
        }
        
        .drag-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: transparent;
            -webkit-app-region: drag;
            z-index: 9999;
            transition: background 0.3s ease;
            cursor: move;
        }
        
        .drag-header:hover {
            background: rgba(0, 240, 255, 0.05);
        }
        
        body.show-border .drag-header {
            background: rgba(0, 240, 255, 0.1);
        }
        
        html.transparent-mode,
        body.transparent-mode {
            background: transparent !important;
        }
        
        body.transparent-mode #viewer {
            background: transparent !important;
        }
        
        body.show-border {
            position: relative;
        }
        
        body.show-border::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 8px solid;
            border-image: linear-gradient(90deg, 
                #00f0ff 0%, 
                #00c4d4 25%, 
                #0099ff 50%, 
                #00c4d4 75%, 
                #00f0ff 100%
            ) 1;
            box-shadow: 
                inset 0 0 40px rgba(0, 240, 255, 0.8),
                0 0 40px rgba(0, 240, 255, 0.6),
                inset 0 0 20px rgba(0, 196, 212, 0.5),
                0 0 20px rgba(0, 196, 212, 0.4);
            pointer-events: none;
            z-index: 9998;
            animation: borderGlow 2s linear infinite;
        }
        
        @keyframes borderGlow {
            0% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
            25% {
                border-image: linear-gradient(180deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            50% {
                border-image: linear-gradient(270deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 153, 255, 0.8),
                    0 0 40px rgba(0, 153, 255, 0.6),
                    inset 0 0 20px rgba(0, 240, 255, 0.5),
                    0 0 20px rgba(0, 240, 255, 0.4);
            }
            75% {
                border-image: linear-gradient(360deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 196, 212, 0.8),
                    0 0 40px rgba(0, 196, 212, 0.6),
                    inset 0 0 20px rgba(0, 153, 255, 0.5),
                    0 0 20px rgba(0, 153, 255, 0.4);
            }
            100% {
                border-image: linear-gradient(90deg, 
                    #00f0ff 0%, #00c4d4 25%, #0099ff 50%, #00c4d4 75%, #00f0ff 100%) 1;
                box-shadow: 
                    inset 0 0 40px rgba(0, 240, 255, 0.8),
                    0 0 40px rgba(0, 240, 255, 0.6),
                    inset 0 0 20px rgba(0, 196, 212, 0.5),
                    0 0 20px rgba(0, 196, 212, 0.4);
            }
        }
        
        #viewer {
            position: relative;
            width: 100%; 
            height: 100%;
            font-size: 32px; 
            line-height: 1.5; 
            text-align: left;
            transition: none;
            z-index: 1;
            box-sizing: border-box;
            display: flex;
            align-items: flex-end;
            justify-content: flex-start;
            background: transparent;
            overflow: visible;
        }
        
        #viewer-text {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            overflow-anchor: none;
            scrollbar-gutter: stable both-edges;
            scrollbar-width: thin;
            scrollbar-color: #8884 #0000;
            background: none;
            word-break: break-all;
            white-space: pre-wrap;
            padding: 10px;
            font-size: inherit;
            font-family: inherit;
            color: inherit;
            text-align: inherit;
            line-height: inherit;
            letter-spacing: 0;
            transition: color 0.2s, opacity 0.5s ease;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 0px;
            scroll-behavior: auto;
        }
        
        #viewer-text.hidden {
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        
        #viewer-text.align-middle .content-wrapper {
            margin: auto 0;
        }
        
        #viewer-text.align-bottom .content-wrapper {
            margin-top: auto;
        }
        
        #viewer-text.align-top .content-wrapper {
            margin-bottom: auto;
        }
        
        #viewer-text.scroll-disabled {
            overflow-y: hidden !important;
        }
        
        #viewer-text::-webkit-scrollbar {
            width: 8px;
            background: transparent;
        }
        
        #viewer-text::-webkit-scrollbar-thumb {
            background: rgba(180,180,180,0.18);
            border-radius: 4px;
        }
        
        .notification {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #000, #333);
            color: white;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 13px;
            font-family: 'Pretendard', sans-serif;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 10002;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .notification.show {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }
        
        .content-wrapper {
            width: 100%;
            min-height: min-content;
            display: flex;
            flex-direction: column;
            gap: 0px;
        }
        
        .speaker-line {
            display: flex;
            align-items: baseline;
            padding: 0;
            margin: 0;
            min-height: auto;
            box-sizing: border-box;
            line-height: inherit;
            flex-shrink: 0;
        }
        
        .speaker-name {
            background: rgba(255, 255, 255, 0.08);
            padding: 3px 15px;
            border-radius: 4px;
            font-weight: 700;
            margin-right: 20px;
            white-space: nowrap;
            flex-shrink: 0;
            line-height: inherit;
            display: inline-flex;
            align-items: baseline;
        }
        
        .speaker-divider {
            width: 2px;
            align-self: stretch;
            background: rgba(255, 255, 255, 0.3);
            margin-right: 20px;
            flex-shrink: 0;
        }
        
        .speaker-pipe {
            color: rgba(255, 255, 255, 0.4);
            margin: 0 20px;
            font-weight: 300;
            line-height: inherit;
        }
        
        .speaker-content {
            flex: 1;
            line-height: inherit;
            min-width: 0;
            word-break: break-word;
        }
        
        .speaker-line.no-speaker {
            display: flex;
            align-items: baseline;
        }
        
        .word-bg {
            display: inline-block;
            padding: 2px 6px;
            margin: 0 2px 2px 0;
            border-radius: 4px;
            word-break: inherit;
            transition: background-color 0.2s ease;
        }
        
        .word-bg.minimal {
            padding: 1px 4px;
            margin: 0 1px;
            border-radius: 2px;
        }
        
        .word-bg.full {
            padding: 3px 8px;
            margin: 0 3px 3px 0;
            border-radius: 6px;
        }
        
        #margin-adjuster {
            position: fixed;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.2), rgba(90,120,255,0.5));
            border-top: 2px solid #5a78ff;
            cursor: ns-resize;
            z-index: 9999;
            display: none;
            transition: all 0.2s ease;
            user-select: none;
            touch-action: none;
        }
        
        #margin-adjuster.active {
            display: block;
        }
        
        #margin-adjuster:hover {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.4), rgba(90,120,255,0.7));
            border-top-color: #7b9eff;
        }
        
        #margin-adjuster.dragging {
            background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.6), rgba(90,120,255,0.8));
            border-top-color: #fff;
        }
        
        #margin-adjuster::before {
            content: "⋮⋮⋮";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: #5a78ff;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
        }
    </style>
</head>
<body class="show-border">
    <div class="drag-header"></div>
    
    <div id="connection-status" class="connecting">
        <div class="status-dot"></div>
        <span>연결 중...</span>
    </div>
    
    <div id="always-on-top-indicator">
        <span>📌</span>
        <span>항상 위</span>
    </div>
    
    <div id="viewer">
        <div id="viewer-text">채널 연결 대기 중...</div>
    </div>
    
    <div id="margin-adjuster"></div>
    
    <div class="notification" id="notification"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
    <script>
const isElectron = typeof window.electronAPI !== 'undefined';

const CONFIG = {
    SOCKET_URL: 'https://live.nuastudio.co.kr',
    RECONNECT_DELAY: 1000,
    RECONNECT_DELAY_MAX: 5000,
    KEEPALIVE_INTERVAL: 15 * 60 * 1000,
    LONG_PRESS_DURATION: 500,
    DOUBLE_TAP_DELAY: 300
};

let channelCode = null;

let longPressTimer = null;
let lastTapTime = 0;
let touchStartTime = 0;
let touchMoved = false;
let socket = null;
let keepaliveInterval = null;
let accumulatedText = '';
let activeStenographer = '1';
let currentActiveInput = '';
let isInitialConnection = true;
let lastTextSentTime = 0;
let lastAccumulatedLength = 0;
let ignoreInputUntil = 0;
let previousInput = '';
let previousDisplay = '';
let isSubtitleHidden = false;
let wasHiddenBeforeInput = false;
let lastRenderedText = '';
let isScrollManual = false;
let isTransparent = false;
let borderVisible = true;
let currentFontSize = 32;
let resizeObserver = null;
let isAlwaysOnTop = false;
let isScrollEnabled = true;
let alwaysOnTopTimer = null;

let marginAdjusterEnabled = false;
let marginOffset = 0;
let isDragging = false;
let startY = 0;
let startOffset = 0;
let maxMargin = 0;

let currentSettings = {
    bgColor: '#000000',
    bgAlpha: '100',
    fontColor: '#ffffff',
    fontSize: '32',
    fontFamily: "'Noto Sans KR', sans-serif",
    letterSpacing: '0',
    lineHeight: '1.5',
    outlineOn: false,
    outlineColor: '#000000',
    outlineWidth: '2',
    shadowOn: false,
    shadowColor: '#000000',
    shadowBlur: '3',
    shadowX: '2',
    shadowY: '2',
    textAlign: 'left',
    verticalAlign: 'top',
    marginTop: '10',
    marginBottom: '10',
    marginLeft: '10',
    marginRight: '10',
    speakerEnabled: true,
    speakerStyle: 'divider',
    speakerBgEnabled: true,
    speakerBgColor: '#ffffff',
    speakerBgAlpha: '8',
    colorDividerEnabled: false,
    dividerColor: '#4A90E2',
    subtitleVisible: true,
    marginAdjusterEnabled: false,
    isTransparent: false,
    borderVisible: true,
    alwaysOnTop: false,
    scrollEnabled: true,
    wordBgEnabled: false,
    wordBgColor: '#ffffff',
    wordBgAlpha: '15',
    wordBgStyle: 'subtle'
};

const viewerText = document.getElementById('viewer-text');
const connectionStatus = document.getElementById('connection-status');
const marginAdjuster = document.getElementById('margin-adjuster');
const alwaysOnTopIndicator = document.getElementById('always-on-top-indicator');

function initializeBackground() {
    const defaultBg = 'rgba(0, 0, 0, 1)';
    document.body.style.backgroundColor = defaultBg;
    document.getElementById('viewer').style.backgroundColor = defaultBg;
}

function loadLastSettings() {
    const saved = localStorage.getItem('lastUsedSettings');
    if (saved) {
        currentSettings = JSON.parse(saved);
        applySettings(currentSettings);
    }
    
    // 항상 위 인디케이터는 초기 로드 시 표시하지 않음
    if (currentSettings.alwaysOnTop) {
        isAlwaysOnTop = true;
        // 인디케이터는 표시하지 않음 (사용자 액션에만 반응)
    }
}

function saveCurrentSettings() {
    localStorage.setItem('lastUsedSettings', JSON.stringify(currentSettings));
}

function getCurrentSettings() {
    return { ...currentSettings };
}

function applySettings(settings) {
    currentSettings = { ...currentSettings, ...settings };
    
    if (settings.bgColor && settings.bgAlpha !== undefined) {
        const bgHex = settings.bgColor;
        const alpha = parseInt(settings.bgAlpha) / 100;
        const safeAlpha = Math.max(alpha, 0.01);
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${safeAlpha})`;
        
        document.getElementById('viewer').style.backgroundColor = bgRgba;
        if (!isTransparent) {
            document.body.style.backgroundColor = bgRgba;
        }
    }
    
    if (settings.fontSize) {
        currentFontSize = parseInt(settings.fontSize);
        viewerText.style.fontSize = settings.fontSize + 'px';
    }
    
    if (settings.fontColor) {
        viewerText.style.color = settings.fontColor;
    }
    
    if (settings.fontFamily) {
        viewerText.style.fontFamily = settings.fontFamily;
    }
    
    if (settings.letterSpacing !== undefined) {
        viewerText.style.letterSpacing = settings.letterSpacing + 'px';
    }
    
    if (settings.lineHeight) {
        viewerText.style.lineHeight = parseFloat(settings.lineHeight) + 'em';
    }
    
    if (settings.textAlign) {
        viewerText.style.textAlign = settings.textAlign;
    }
    
    if (settings.verticalAlign) {
        viewerText.classList.remove('align-middle', 'align-bottom', 'align-top');
        if (settings.verticalAlign === 'middle') {
            viewerText.classList.add('align-middle');
        } else if (settings.verticalAlign === 'bottom') {
            viewerText.classList.add('align-bottom');
        } else if (settings.verticalAlign === 'top') {
            viewerText.classList.add('align-top');
        }
        scrollToBottom();
    }
    
    if (settings.marginTop !== undefined && settings.marginBottom !== undefined && 
        settings.marginLeft !== undefined && settings.marginRight !== undefined) {
        const mTop = parseInt(settings.marginTop) || 10;
        const mBottom = parseInt(settings.marginBottom) || 10;
        const mLeft = parseInt(settings.marginLeft) || 10;
        const mRight = parseInt(settings.marginRight) || 10;
        
        viewerText.style.padding = `${mTop}px ${mRight}px ${mBottom}px ${mLeft}px`;
        
        scrollToBottom();
    }
    
    let textShadow = '';
    if (settings.outlineOn && parseFloat(settings.outlineWidth) > 0) {
        const outline = `-${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px -${settings.outlineWidth}px 0 ${settings.outlineColor}, -${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}, ${settings.outlineWidth}px ${settings.outlineWidth}px 0 ${settings.outlineColor}`;
        textShadow = outline;
    }
    if (settings.shadowOn && parseFloat(settings.shadowBlur) > 0) {
        const dropShadow = `${settings.shadowX}px ${settings.shadowY}px ${settings.shadowBlur}px ${settings.shadowColor}`;
        textShadow = textShadow ? textShadow + ', ' + dropShadow : dropShadow;
    }
    viewerText.style.textShadow = textShadow;
    
    if (settings.subtitleVisible !== undefined) {
        isSubtitleHidden = !settings.subtitleVisible;
        if (isSubtitleHidden) {
            viewerText.classList.add('hidden');
        } else {
            viewerText.classList.remove('hidden');
        }
    }
    
    if (settings.marginAdjusterEnabled !== undefined) {
        marginAdjusterEnabled = settings.marginAdjusterEnabled;
        if (marginAdjusterEnabled) {
            marginAdjuster.classList.add('active');
            marginAdjuster.style.bottom = marginOffset + 'px';
        } else {
            marginAdjuster.classList.remove('active');
        }
    }
    
    if (settings.alwaysOnTop !== undefined) {
        isAlwaysOnTop = settings.alwaysOnTop;
    }
    
    if (settings.scrollEnabled !== undefined) {
        isScrollEnabled = settings.scrollEnabled;
        if (isScrollEnabled) {
            viewerText.classList.remove('scroll-disabled');
        } else {
            viewerText.classList.add('scroll-disabled');
        }
    }
    
    lastRenderedText = '';
    const currentText = accumulatedText + currentActiveInput;
    updateDisplay(currentText, true);
    
    saveCurrentSettings();
}

function scrollToBottom() {
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            viewerText.scrollTop = viewerText.scrollHeight;
        });
    });
}

function initSocket() {
    console.log('[Socket] 초기화:', CONFIG.SOCKET_URL);
    
    socket = io(CONFIG.SOCKET_URL, {
        transports: ['websocket', 'polling'],
        upgrade: true,
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: CONFIG.RECONNECT_DELAY,
        reconnectionDelayMax: CONFIG.RECONNECT_DELAY_MAX,
        timeout: 20000,
        forceNew: true
    });
    
    socket.on('connect', () => {
        console.log('[Socket] 연결 성공');
        updateConnectionStatus('connected', '연결됨');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('connect_error', (error) => {
        console.error('[Socket] 연결 에러:', error.message);
        updateConnectionStatus('disconnected', '연결 실패');
    });
    
    socket.on('disconnect', (reason) => {
        console.log('[Socket] 연결 끊김:', reason);
        updateConnectionStatus('disconnected', '연결 끊김');
        stopKeepalive();
    });
    
    socket.on('reconnect', () => {
        console.log('[Socket] 재연결 성공');
        updateConnectionStatus('connected', '재연결됨');
        joinChannel();
        startKeepalive();
    });
    
    socket.on('joined_channel', (data) => {
        console.log('[Channel] 참가 성공');
        viewerText.textContent = '자막 대기 중...';
        socket.emit('request_sync', { channel: channelCode });
    });
    
    socket.on('channel_state', (data) => {
        console.log('[State] 채널 상태:', data);
        if (data.state) {
            if (data.state.activeStenographer) {
                activeStenographer = data.state.activeStenographer === 'steno1' ? '1' : '2';
            }
            if (data.state.accumulatedText !== undefined) {
                accumulatedText = data.state.accumulatedText;
                currentActiveInput = '';
                previousInput = '';
                previousDisplay = '';
                updateDisplay(accumulatedText, true);
            }
        }
    });
    
    socket.on('sync_accumulated', (data) => {
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
        
        if (data.activeStenographer) {
            activeStenographer = data.activeStenographer === 'steno1' ? '1' : '2';
        }
    });
    
    socket.on('steno_input', (data) => {
        const roleNumber = data.role === 'steno1' ? '1' : data.role === 'steno2' ? '2' : data.role;
        
        if (roleNumber === activeStenographer) {
            const now = Date.now();
            const inputLength = (data.text || '').length;
            
            if (now < ignoreInputUntil && inputLength < lastAccumulatedLength - 10) {
                return;
            }
            
            currentActiveInput = data.text || '';
            const fullText = accumulatedText + currentActiveInput;
            updateDisplay(fullText, false);
        }
    });
    
    socket.on('switch_role', (data) => {
        activeStenographer = data.newActive === 'steno1' ? '1' : '2';
        
        if (data.accumulatedText !== undefined) {
            accumulatedText = data.accumulatedText;
            currentActiveInput = '';
            previousInput = '';
            previousDisplay = '';
            updateDisplay(accumulatedText, true);
        }
    });
    
    socket.on('text_sent', (data) => {
        lastTextSentTime = Date.now();
        lastAccumulatedLength = (data.accumulatedText || '').length;
        ignoreInputUntil = Date.now() + 1000;
        
        accumulatedText = data.accumulatedText || '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        updateDisplay(accumulatedText, true);
    });
    
    socket.on('clear_text', () => {
        accumulatedText = '';
        currentActiveInput = '';
        previousInput = '';
        previousDisplay = '';
        lastRenderedText = '';
        updateDisplay('', true);
    });
}

function joinChannel() {
    if (!socket || !socket.connected) return;
    
    console.log('[Channel] 참가 요청:', channelCode);
    socket.emit('join_channel', {
        channel: channelCode,
        role: 'viewer',
        requestSync: true
    });
}

function startKeepalive() {
    stopKeepalive();
    keepaliveInterval = setInterval(() => {
        if (socket && socket.connected) {
            socket.emit('keepalive', { channel: channelCode, timestamp: Date.now() });
        }
    }, CONFIG.KEEPALIVE_INTERVAL);
}

function stopKeepalive() {
    if (keepaliveInterval) {
        clearInterval(keepaliveInterval);
        keepaliveInterval = null;
    }
}

function updateConnectionStatus(status, message) {
    connectionStatus.className = status;
    connectionStatus.querySelector('span').textContent = message;
    
    if (status === 'connected' && isInitialConnection) {
        setTimeout(() => {
            connectionStatus.style.opacity = '0';
            isInitialConnection = false;
        }, 3000);
    } else {
        connectionStatus.style.opacity = '1';
    }
}

function updateDisplay(text, isImmediate = false) {
    if (isSubtitleHidden && text && text.trim()) {
        if (wasHiddenBeforeInput || text.length > (previousInput ? previousInput.length : 0)) {
            toggleSubtitleVisibility(true);
            wasHiddenBeforeInput = false;
        }
    }
    
    let displayText = text;
    
    if (isImmediate) {
        previousInput = '';
        previousDisplay = '';
    } else {
        const isBackspace = previousInput.length > text.length;
        const onlySpaceRemoved = isBackspace && previousInput.endsWith(' ') && text === previousInput.slice(0, -1);
        
        if (text.length > 0) {
            if (text.endsWith(' ') || text.endsWith('\n')) {
                displayText = text;
            } else if (onlySpaceRemoved && previousDisplay) {
                displayText = previousDisplay.trimEnd();
            } else {
                const lastSpace = text.lastIndexOf(' ');
                const lastNewline = text.lastIndexOf('\n');
                const lastDelimiter = Math.max(lastSpace, lastNewline);
                
                if (lastDelimiter > -1) {
                    displayText = text.substring(0, lastDelimiter + 1);
                } else {
                    displayText = '';
                }
            }
        }
        
        previousInput = text;
        previousDisplay = displayText;
    }
    
    if (!currentActiveInput || currentActiveInput.trim().length === 0) {
        displayText = displayText.replace(/\n+$/, '');
    }
    
    const lines = displayText.split('\n');
    if (lines.length > 10000) {
        console.log('[Performance] 줄 수 초과:', lines.length, '→ 8,000줄로 정리');
        displayText = lines.slice(-8000).join('\n');
        if (isImmediate) {
            accumulatedText = displayText;
        }
    }
    
    const finalDisplayText = displayText || (channelCode ? '자막 대기 중...' : '채널 연결 대기 중...');
    if (finalDisplayText === lastRenderedText) return;
    
    renderFormattedText(finalDisplayText);
    lastRenderedText = finalDisplayText;
    
    if (!isScrollManual) {
        scrollToBottom();
    }
}

viewerText.addEventListener('wheel', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

viewerText.addEventListener('touchstart', () => {
    isScrollManual = true;
    setTimeout(() => {
        isScrollManual = false;
    }, 1000);
});

function renderFormattedText(text) {
    const lines = text.split('\n');
    const speakerEnabled = currentSettings.speakerEnabled;
    const speakerStyle = currentSettings.speakerStyle;
    const useBg = currentSettings.speakerBgEnabled;
    const useColorDivider = currentSettings.colorDividerEnabled;
    const bgAlpha = parseInt(currentSettings.speakerBgAlpha) / 100;
    const currentLineHeight = viewerText.style.lineHeight;
    
    const useWordBg = currentSettings.wordBgEnabled;
    const wordBgColor = currentSettings.wordBgColor;
    const wordBgAlpha = parseInt(currentSettings.wordBgAlpha || '15') / 100;
    const wordBgStyle = currentSettings.wordBgStyle || 'subtle';
    
    viewerText.innerHTML = '';
    
    // 항상 wrapper 사용
    const wrapper = document.createElement('div');
    wrapper.className = 'content-wrapper';
    viewerText.appendChild(wrapper);
    
    lines.forEach(line => {
        const lineDiv = document.createElement('div');
        lineDiv.className = 'speaker-line';
        lineDiv.style.lineHeight = currentLineHeight;
        
        if (speakerEnabled && line.startsWith('-') && line.includes(': ')) {
            const colonIndex = line.indexOf(': ');
            const speaker = line.substring(1, colonIndex).trim();
            const content = line.substring(colonIndex + 2);
            
            const speakerSpan = document.createElement('span');
            speakerSpan.className = 'speaker-name';
            speakerSpan.textContent = speaker;
            
            if (useBg) {
                const bgColor = currentSettings.speakerBgColor;
                const r = parseInt(bgColor.slice(1, 3), 16);
                const g = parseInt(bgColor.slice(3, 5), 16);
                const b = parseInt(bgColor.slice(5, 7), 16);
                speakerSpan.style.background = `rgba(${r}, ${g}, ${b}, ${bgAlpha})`;
            } else {
                speakerSpan.style.background = 'transparent';
            }
            
            lineDiv.appendChild(speakerSpan);
            
            if (speakerStyle === 'divider') {
                const divider = document.createElement('div');
                divider.className = 'speaker-divider';
                if (useColorDivider) {
                    divider.style.background = currentSettings.dividerColor;
                }
                lineDiv.appendChild(divider);
            } else if (speakerStyle === 'pipe') {
                const pipe = document.createElement('span');
                pipe.className = 'speaker-pipe';
                pipe.textContent = '|';
                if (useColorDivider) {
                    pipe.style.color = currentSettings.dividerColor;
                }
                lineDiv.appendChild(pipe);
            } else if (speakerStyle === 'minimal') {
                const divider = document.createElement('div');
                divider.className = 'speaker-divider';
                divider.style.width = '1px';
                divider.style.margin = '0 25px';
                if (useColorDivider) {
                    divider.style.background = currentSettings.dividerColor;
                } else {
                    divider.style.background = 'rgba(255, 255, 255, 0.2)';
                }
                lineDiv.appendChild(divider);
            }
            
            const contentSpan = document.createElement('span');
            contentSpan.className = 'speaker-content';
            
            if (useWordBg && content.trim()) {
                const words = content.split(/(\s+)/);
                const r = parseInt(wordBgColor.slice(1, 3), 16);
                const g = parseInt(wordBgColor.slice(3, 5), 16);
                const b = parseInt(wordBgColor.slice(5, 7), 16);
                
                words.forEach(word => {
                    if (word.trim()) {
                        const wordSpan = document.createElement('span');
                        wordSpan.className = `word-bg ${wordBgStyle}`;
                        wordSpan.textContent = word;
                        wordSpan.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${wordBgAlpha})`;
                        contentSpan.appendChild(wordSpan);
                    } else if (word) {
                        contentSpan.appendChild(document.createTextNode(word));
                    }
                });
            } else {
                contentSpan.textContent = content || '\u200B';
            }
            
            lineDiv.appendChild(contentSpan);
        } else {
            lineDiv.classList.add('no-speaker');
            const contentSpan = document.createElement('span');
            contentSpan.className = 'speaker-content';
            
            if (useWordBg && line.trim()) {
                const words = line.split(/(\s+)/);
                const r = parseInt(wordBgColor.slice(1, 3), 16);
                const g = parseInt(wordBgColor.slice(3, 5), 16);
                const b = parseInt(wordBgColor.slice(5, 7), 16);
                
                words.forEach(word => {
                    if (word.trim()) {
                        const wordSpan = document.createElement('span');
                        wordSpan.className = `word-bg ${wordBgStyle}`;
                        wordSpan.textContent = word;
                        wordSpan.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${wordBgAlpha})`;
                        contentSpan.appendChild(wordSpan);
                    } else if (word) {
                        contentSpan.appendChild(document.createTextNode(word));
                    }
                });
            } else {
                contentSpan.textContent = line || '\u200B';
            }
            
            lineDiv.appendChild(contentSpan);
        }
        
        wrapper.appendChild(lineDiv);
    });
}

function toggleSubtitleVisibility(forceShow = null) {
    if (forceShow !== null) {
        isSubtitleHidden = !forceShow;
    } else {
        isSubtitleHidden = !isSubtitleHidden;
    }
    
    if (isSubtitleHidden) {
        viewerText.classList.add('hidden');
        wasHiddenBeforeInput = true;
        currentSettings.subtitleVisible = false;
        showNotification('자막 숨김');
    } else {
        viewerText.classList.remove('hidden');
        wasHiddenBeforeInput = false;
        currentSettings.subtitleVisible = true;
        showNotification('자막 표시');
    }
    saveCurrentSettings();
}

function toggleScrollEnabled() {
    isScrollEnabled = !isScrollEnabled;
    currentSettings.scrollEnabled = isScrollEnabled;
    
    if (isScrollEnabled) {
        viewerText.classList.remove('scroll-disabled');
        showNotification('스크롤 활성화');
    } else {
        viewerText.classList.add('scroll-disabled');
        showNotification('스크롤 비활성화');
    }
    
    saveCurrentSettings();
}

function toggleAlwaysOnTop() {
    if (isElectron) {
        window.electronAPI.toggleAlwaysOnTop();
    }
}

function updateAlwaysOnTopIndicator(state, showTemporary = true) {
    if (alwaysOnTopTimer) {
        clearTimeout(alwaysOnTopTimer);
        alwaysOnTopTimer = null;
    }
    
    if (state) {
        alwaysOnTopIndicator.classList.add('active');
        if (showTemporary) {
            alwaysOnTopTimer = setTimeout(() => {
                alwaysOnTopIndicator.classList.remove('active');
                alwaysOnTopTimer = null;
            }, 3000);
        }
    } else {
        alwaysOnTopIndicator.classList.remove('active');
    }
}

function saveTextToFile() {
    const fullText = accumulatedText || '저장할 텍스트가 없습니다.';
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `자막_${channelCode}_${timestamp}.txt`;
    
    const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    showNotification(`텍스트 저장됨: ${filename}`);
}

function toggleTransparent() {
    console.log('[Transparent] Toggle called, current:', isTransparent);
    
    isTransparent = !isTransparent;
    currentSettings.isTransparent = isTransparent;
    
    if (isTransparent) {
        document.documentElement.classList.add('transparent-mode');
        document.body.classList.add('transparent-mode');
        const transparentBg = 'rgba(0, 0, 0, 0.01)';
        document.body.style.backgroundColor = transparentBg;
        document.getElementById('viewer').style.backgroundColor = transparentBg;
        if (isElectron) window.electronAPI.toggleTransparent(true);
        showNotification('투명 모드 켜짐');
    } else {
        document.documentElement.classList.remove('transparent-mode');
        document.body.classList.remove('transparent-mode');
        const bgHex = currentSettings.bgColor || '#000000';
        const alpha = parseInt(currentSettings.bgAlpha || '100') / 100;
        const r = parseInt(bgHex.slice(1, 3), 16);
        const g = parseInt(bgHex.slice(3, 5), 16);
        const b = parseInt(bgHex.slice(5, 7), 16);
        const bgRgba = `rgba(${r}, ${g}, ${b}, ${alpha})`;
        document.body.style.backgroundColor = bgRgba;
        document.getElementById('viewer').style.backgroundColor = bgRgba;
        if (isElectron) window.electronAPI.toggleTransparent(false);
        showNotification('투명 모드 꺼짐');
    }
    
    saveCurrentSettings();
}

function toggleBorder() {
    console.log('[Border] Toggle called, current:', borderVisible);
    
    borderVisible = !borderVisible;
    
    if (borderVisible) {
        document.body.classList.add('show-border');
        showNotification('테두리 표시');
        console.log('[Border] ON');
    } else {
        document.body.classList.remove('show-border');
        showNotification('테두리 숨김');
        console.log('[Border] OFF');
    }
    
    currentSettings.borderVisible = borderVisible;
    saveCurrentSettings();
}

function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen?.();
    } else {
        document.exitFullscreen?.();
    }
}

function handleQuickAction(action) {
    console.log('[QuickAction] Received:', action);
    
    switch(action) {
        case 'font-up':
            currentFontSize = Math.min(200, currentFontSize + 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`글자 크기: ${currentFontSize}px`);
            break;
        case 'font-down':
            currentFontSize = Math.max(10, currentFontSize - 4);
            currentSettings.fontSize = currentFontSize.toString();
            applySettings(currentSettings);
            showNotification(`글자 크기: ${currentFontSize}px`);
            break;
        case 'transparent':
            toggleTransparent();
            break;
        case 'border':
            console.log('[QuickAction] Border action triggered');
            toggleBorder();
            break;
        case 'subtitle-toggle':
            toggleSubtitleVisibility();
            break;
        case 'scroll-toggle':
            toggleScrollEnabled();
            break;
        case 'always-on-top':
            toggleAlwaysOnTop();
            break;
        case 'save-text':
            saveTextToFile();
            break;
        case 'fullscreen':
            toggleFullscreen();
            break;
        case 'exit':
            console.log('[Exit] Exit action triggered');
            if (isElectron) {
                window.electronAPI.confirmExit().then(confirmed => {
                    console.log('[Exit] Confirmation result:', confirmed);
                    if (confirmed) {
                        console.log('[Exit] Closing app...');
                        try {
                            window.electronAPI.closeQuickMenu();
                        } catch (e) {
                            console.log('[Exit] Could not close Quick Menu:', e);
                        }
                        setTimeout(() => {
                            try {
                                window.electronAPI.exitApp();
                            } catch (err) {
                                console.error('[Exit] exitApp failed, using window.close:', err);
                                window.close();
                            }
                        }, 100);
                    } else {
                        console.log('[Exit] User cancelled exit');
                    }
                }).catch(err => {
                    console.error('[Exit] Error during exit confirmation:', err);
                    if (confirm('앱을 종료하시겠습니까?')) {
                        try {
                            window.electronAPI.exitApp();
                        } catch (e) {
                            window.close();
                        }
                    }
                });
            } else {
                if (confirm('앱을 종료하시겠습니까?')) {
                    window.close();
                }
            }
            break;
    }
}

function showNotification(message, duration = 2000) {
    const notif = document.getElementById('notification');
    notif.textContent = message;
    notif.classList.add('show');
    setTimeout(() => notif.classList.remove('show'), duration);
}

document.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (isElectron) {
        window.electronAPI.openQuickMenu();
    }
});

document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
    
    switch(e.key) {
        case 'Enter':
            e.preventDefault();
            toggleFullscreen();
            break;
        case 'h':
        case 'H':
            e.preventDefault();
            toggleSubtitleVisibility();
            break;
        case 's':
        case 'S':
            e.preventDefault();
            toggleScrollEnabled();
            break;
        case 't':
        case 'T':
            e.preventDefault();
            toggleAlwaysOnTop();
            break;
        case 'ArrowUp':
            e.preventDefault();
            handleQuickAction('font-up');
            break;
        case 'ArrowDown':
            e.preventDefault();
            handleQuickAction('font-down');
            break;
    }
});

document.body.addEventListener('dblclick', e => {
    console.log('[DblClick] Double click detected');
    toggleBorder();
});

function setupTouchEvents() {
    viewerText.addEventListener('touchstart', (e) => {
        touchStartTime = Date.now();
        touchMoved = false;
        
        longPressTimer = setTimeout(() => {
            if (!touchMoved && isElectron) {
                window.electronAPI.openQuickMenu();
            }
        }, CONFIG.LONG_PRESS_DURATION);
    }, { passive: true });
    
    viewerText.addEventListener('touchmove', () => {
        touchMoved = true;
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
    }, { passive: true });
    
    viewerText.addEventListener('touchend', (e) => {
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        
        if (!touchMoved) {
            const now = Date.now();
            if (now - lastTapTime < CONFIG.DOUBLE_TAP_DELAY) {
                toggleFullscreen();
                lastTapTime = 0;
            } else {
                lastTapTime = now;
            }
        }
    }, { passive: true });
}

function setupMarginAdjusterTouch() {
    marginAdjuster.addEventListener('mousedown', startDrag);
    marginAdjuster.addEventListener('touchstart', startDrag, { passive: false });
    
    function startDrag(e) {
        if (e.type === 'touchstart') {
            e.preventDefault();
            startY = e.touches[0].clientY;
        } else {
            startY = e.clientY;
        }
        
        startOffset = marginOffset;
        isDragging = true;
        marginAdjuster.classList.add('dragging');
        
        const viewerHeight = document.getElementById('viewer').offsetHeight;
        maxMargin = viewerHeight - 100;
        
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', onDrag, { passive: false });
        document.addEventListener('touchend', stopDrag);
    }
    
    function onDrag(e) {
        if (!isDragging) return;
        
        let currentY;
        if (e.type === 'touchmove') {
            e.preventDefault();
            currentY = e.touches[0].clientY;
        } else {
            currentY = e.clientY;
        }
        
        const deltaY = startY - currentY;
        marginOffset = Math.max(0, Math.min(maxMargin, startOffset + deltaY));
        
        marginAdjuster.style.bottom = marginOffset + 'px';
        
        const currentMarginBottom = parseInt(currentSettings.marginBottom) || 10;
        const newMarginBottom = currentMarginBottom + marginOffset;
        
        const mTop = parseInt(currentSettings.marginTop) || 10;
        const mLeft = parseInt(currentSettings.marginLeft) || 10;
        const mRight = parseInt(currentSettings.marginRight) || 10;
        
        viewerText.style.padding = `${mTop}px ${mRight}px ${newMarginBottom}px ${mLeft}px`;
        
        viewerText.scrollTop = viewerText.scrollHeight;
        
        currentSettings.marginBottom = newMarginBottom.toString();
    }
    
    function stopDrag() {
        if (!isDragging) return;
        
        isDragging = false;
        marginAdjuster.classList.remove('dragging');
        
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', stopDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', stopDrag);
        
        saveCurrentSettings();
        
        marginOffset = 0;
        marginAdjuster.style.bottom = '0px';
        
        scrollToBottom();
    }
}

function handleFullscreenChange() {
    if (document.fullscreenElement) {
        showNotification('전체화면 모드');
    } else {
        showNotification('전체화면 해제');
    }
}

if (isElectron) {
    window.electronAPI.on('deep-link-join', (data) => {
        const { channel, token } = data;
        console.log('[DeepLink] 채널 참가 요청:', channel);
        
        if (channel) {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            channelCode = channel;
            initSocket();
        }
    });
    
    window.electronAPI.on('channel-code', (code) => {
        console.log('[Legacy] 채널 코드 수신:', code);
        
        if (socket) {
            socket.disconnect();
            socket = null;
        }
        channelCode = code;
        initSocket();
    });
    
    window.electronAPI.on('update-settings', (settings) => {
        applySettings(settings);
    });
    
    window.electronAPI.on('send-current-settings-to-menu', () => {
        window.electronAPI.sendSettingsToMenu(getCurrentSettings());
    });
    
    window.electronAPI.on('quick-action', (action) => {
        handleQuickAction(action);
    });
    
    window.electronAPI.on('always-on-top-changed', (newState) => {
        isAlwaysOnTop = newState;
        currentSettings.alwaysOnTop = newState;
        
        if (newState) {
            showNotification('항상 위 활성화');
            updateAlwaysOnTopIndicator(true, true);
        } else {
            showNotification('항상 위 비활성화');
            updateAlwaysOnTopIndicator(false, false);
        }
        
        saveCurrentSettings();
    });
}

window.addEventListener('load', () => {
    initializeBackground();
    
    setupTouchEvents();
    
    setupMarginAdjusterTouch();
    
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    
    resizeObserver = new ResizeObserver(() => {
        if (!isScrollManual) {
            scrollToBottom();
        }
    });
    resizeObserver.observe(viewerText);
    
    loadLastSettings();
    
    console.log('[Electron] 채널 연결 대기 중...');
    updateConnectionStatus('connecting', '채널 연결 대기 중...');
    
    setTimeout(() => {
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            showNotification('꾹 터치: 설정, 더블 터치: 전체화면, H키: 자막 숨김', 5000);
        } else {
            showNotification('단축키: Enter(전체화면), ↑↓(글자크기), H(자막), S(스크롤), T(항상위)', 5000);
        }
    }, 3000);
});

window.addEventListener('beforeunload', () => {
    stopKeepalive();
    if (socket) socket.disconnect();
    if (resizeObserver) resizeObserver.disconnect();
    if (alwaysOnTopTimer) clearTimeout(alwaysOnTopTimer);
});
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>속기 뷰어 (단일 파일)</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&family=Jua&family=Do+Hyeon&family=Nanum+Gothic&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Gothic+A1&family=IBM+Plex+Sans+KR&family=Pretendard:wght@400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* 기본 스타일 */
    html, body {
      width: 100vw; height: 100vh; margin: 0; padding: 0;
      background: #000; color: #fff; overflow: hidden;
    }
    
    /* 연결 상태 인디케이터 */
    #connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 12px;
      font-family: 'Noto Sans KR', sans-serif;
      z-index: 10001;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    #connection-status.connecting {
      background: rgba(255, 193, 7, 0.9);
      color: #000;
    }
    
    #connection-status.connected {
      background: rgba(40, 167, 69, 0.9);
      color: #fff;
    }
    
    #connection-status.disconnected {
      background: rgba(220, 53, 69, 0.9);
      color: #fff;
    }
    
    #connection-status .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.2); opacity: 0.7; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    #viewer {
      position: relative;
      width: 100vw; height: 100vh;
      font-size: 32px; line-height: 1.5; text-align: left;
      transition: background 0.3s;
      z-index: 1;
      padding: 10px 15px;
      box-sizing: border-box;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
    }
    
    /* ========== 스크롤 안정화된 #viewer-text ========== */
    #viewer-text {
      width: calc(100% - 30px);
      height: calc(100% - 20px);
      overflow-y: auto;
      overflow-anchor: none;
      scrollbar-gutter: stable both-edges;
      scrollbar-width: thin;
      scrollbar-color: #8884 #0000;
      background: none;
      word-break: break-all;
      white-space: pre-wrap;
      padding: 0;
      font-size: inherit;
      font-family: inherit;
      color: inherit;
      text-align: inherit;
      line-height: inherit;
      letter-spacing: 0;
      transition: color 0.2s, background 0.2s, opacity 0.5s ease;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 0px;
      scroll-behavior: auto;
    }
    
    #viewer-text.hidden {
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    /* 세로 정렬을 위한 클래스들 - wrapper 구조 사용 */
    #viewer-text.align-middle {
      justify-content: center;
      height: calc(100% - 20px);
    }
    
    #viewer-text.align-bottom {
      justify-content: flex-end;
      height: calc(100% - 20px);
    }
    
    #viewer-text::-webkit-scrollbar {
      width: 8px;
      background: transparent;
    }
    
    #viewer-text::-webkit-scrollbar-thumb {
      background: rgba(180,180,180,0.18);
      border-radius: 4px;
    }
    
    /* 여백 조절기 */
    #margin-adjuster {
      position: fixed;
      left: 0;
      right: 0;
      height: 20px;
      background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.2), rgba(90,120,255,0.5));
      border-top: 2px solid #5a78ff;
      cursor: ns-resize;
      z-index: 100;
      display: none;
      transition: all 0.2s ease;
      user-select: none;
    }
    
    #margin-adjuster.active {
      display: block;
    }
    
    #margin-adjuster:hover {
      background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.4), rgba(90,120,255,0.7));
      border-top-color: #7b9eff;
    }
    
    #margin-adjuster.dragging {
      background: linear-gradient(to bottom, transparent, rgba(90,120,255,0.6), rgba(90,120,255,0.8));
      border-top-color: #fff;
    }
    
    #margin-adjuster::before {
      content: "⋮⋮⋮";
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #5a78ff;
      font-size: 12px;
      letter-spacing: 2px;
      pointer-events: none;
    }
    
    /* 우클릭 메뉴 오버레이 */
    .quick-wheel-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      opacity: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.2s ease;
    }
    
    .quick-wheel-overlay.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* 우클릭 메뉴 - 일렉트론 스타일 */
    .quick-wheel {
      width: 480px;
      max-width: 90vw;
      max-height: 85vh;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      animation: scaleIn 0.2s ease;
    }
    
    @keyframes scaleIn {
      from {
        transform: scale(0.9);
        opacity: 0;
      }
      to {
        transform: scale(1);
        opacity: 1;
      }
    }
    
    /* 헤더 영역 */
    .quick-wheel-header {
      padding: 20px 25px 15px;
      border-bottom: 1px solid #e0e0e0;
      position: relative;
      background: #fff;
      flex-shrink: 0;
      cursor: move;
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
    }
    
    .quick-wheel-header:active {
      cursor: grabbing;
    }
    
    .quick-wheel-header h3 {
      font-size: 20px;
      color: #000;
      font-weight: 700;
      font-family: 'Poppins', sans-serif;
      text-align: center;
      margin: 0;
      pointer-events: none;
      user-select: none;
    }
    
    .close-btn {
      position: absolute;
      top: 20px;
      right: 25px;
      width: 32px;
      height: 32px;
      border: none;
      background: #f5f5f5;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      font-size: 18px;
      color: #666;
    }
    
    .close-btn:hover {
      background: #00f0ff;
      color: #fff;
      transform: scale(1.1);
    }
    
    /* 탭 네비게이션 */
    .tab-nav {
      display: flex;
      background: #f8f8f8;
      padding: 5px;
      margin: 15px 25px 0;
      border-radius: 12px;
      flex-shrink: 0;
    }
    
    .tab-btn {
      flex: 1;
      padding: 12px 20px;
      background: transparent;
      border: none;
      color: #999;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Pretendard', sans-serif;
      border-radius: 8px;
      position: relative;
    }
    
    .tab-btn:hover {
      color: #333;
    }
    
    .tab-btn.active {
      color: #000;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
    }
    
    /* 탭 콘텐츠 */
    .tab-content {
      display: none;
      padding: 20px 25px;
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      background: #fff;
      color: #333;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .tab-content::-webkit-scrollbar {
      width: 6px;
    }
    
    .tab-content::-webkit-scrollbar-track {
      background: #f8f8f8;
      border-radius: 3px;
    }
    
    .tab-content::-webkit-scrollbar-thumb {
      background: #ccc;
      border-radius: 3px;
    }
    
    .tab-content::-webkit-scrollbar-thumb:hover {
      background: #999;
    }
    
    /* 옵션 그룹 */
    .option-group {
      margin-bottom: 20px;
    }
    
    .option-group-title {
      font-size: 11px;
      font-weight: 600;
      color: #00c4d4;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 12px;
      font-family: 'Poppins', sans-serif;
    }
    
    .option-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 15px;
    }
    
    .option-row > label {
      width: 80px;
      flex-shrink: 0;
      color: #666;
      font-size: 12px;
      font-weight: 500;
    }
    
    /* 입력 요소들 - 일렉트론 스타일 */
    input[type="color"] {
      width: 40px;
      height: 30px;
      border: 1px solid #e0e0e0;
      background: #fff;
      cursor: pointer;
      border-radius: 6px;
      padding: 2px;
    }
    
    input[type="text"].color-hex {
      width: 75px;
      height: 30px;
      font-size: 11px;
      padding: 0 8px;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #333;
      text-align: center;
      font-family: 'Poppins', monospace;
      text-transform: uppercase;
      transition: border-color 0.2s;
    }
    
    input[type="text"].color-hex:focus {
      outline: none;
      border-color: #00f0ff;
    }
    
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: #00f0ff;
      cursor: pointer;
    }
    
    input[type="number"] {
      width: 60px;
      height: 30px;
      font-size: 12px;
      padding: 0 8px;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #333;
      text-align: center;
      font-family: 'Pretendard', sans-serif;
      transition: border-color 0.2s;
    }
    
    input[type="number"]:focus {
      outline: none;
      border-color: #00f0ff;
    }
    
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      appearance: none;
      margin: 0;
      display: none;
    }
    
    input[type="range"] {
      width: 100px;
      height: 5px;
      -webkit-appearance: none;
      appearance: none;
      background: #e0e0e0;
      border-radius: 3px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      background: linear-gradient(135deg, #00f0ff, #00c4d4);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    select {
      flex: 1;
      height: 30px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #333;
      padding: 0 8px;
      font-family: 'Pretendard', sans-serif;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    
    select:focus {
      outline: none;
      border-color: #00f0ff;
    }
    
    .num-btns {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }
    
    .num-btns button {
      width: 20px;
      height: 12px;
      font-size: 8px;
      border: none;
      background: #f0f0f0;
      color: #666;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
      line-height: 1;
    }
    
    .num-btns button:hover {
      background: #00f0ff;
      color: #fff;
    }
    
    .unit-label {
      color: #999;
      font-size: 12px;
    }
    
    /* 색상 입력 그룹 */
    .color-input-group {
      display: flex;
      gap: 10px;
      align-items: center;
      flex: 1;
    }
    
    /* 정렬 버튼 */
    .align-btn, .valign-btn {
      width: 30px;
      height: 30px;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #666;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 12px;
    }
    
    .align-btn:hover, .valign-btn:hover {
      background: #f0f0f0;
      border-color: #ccc;
    }
    
    .align-btn.active, .valign-btn.active {
      background: linear-gradient(135deg, #00f0ff, #00c4d4);
      border-color: transparent;
      color: #fff;
    }
    
    /* 프리셋 그리드 */
    .preset-grid {
      display: grid;
      gap: 10px;
    }
    
    .preset-item {
      display: flex;
      align-items: center;
      padding: 15px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .preset-item:hover {
      border-color: #00f0ff;
      background: #f0fdff;
      transform: translateX(5px);
    }
    
    .preset-item.selected {
      background: linear-gradient(135deg, rgba(0, 240, 255, 0.1), rgba(0, 196, 212, 0.1));
      border-color: #00f0ff;
    }
    
    .preset-name {
      flex: 1;
      font-size: 14px;
      font-weight: 500;
      color: #333;
    }
    
    .preset-actions {
      display: flex;
      gap: 8px;
    }
    
    .preset-btn {
      padding: 6px 14px;
      font-size: 11px;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #666;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: 'Pretendard', sans-serif;
      font-weight: 500;
    }
    
    .preset-btn:hover {
      background: #f0f0f0;
      border-color: #ccc;
    }
    
    .preset-btn.apply {
      background: linear-gradient(135deg, #00f0ff, #00c4d4);
      border-color: transparent;
      color: white;
    }
    
    .preset-btn.apply:hover {
      background: linear-gradient(135deg, #00c4d4, #00a0b0);
    }
    
    /* 퀵 액션 그리드 */
    .quick-actions-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 15px;
    }
    
    .quick-action-item {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      padding: 18px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .quick-action-item:hover {
      background: linear-gradient(135deg, #00f0ff, #00c4d4);
      border-color: transparent;
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 240, 255, 0.3);
    }
    
    .quick-action-item:hover .action-icon,
    .quick-action-item:hover .action-label {
      color: #fff;
    }
    
    .action-icon {
      font-size: 24px;
      color: #333;
      font-weight: 600;
      font-family: 'Poppins', sans-serif;
      transition: color 0.2s;
    }
    
    .action-label {
      font-size: 12px;
      color: #666;
      font-family: 'Pretendard', sans-serif;
      transition: color 0.2s;
    }
    
    /* 알림 메시지 */
    .notification {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #000, #333);
      color: white;
      padding: 12px 24px;
      border-radius: 25px;
      font-size: 13px;
      font-family: 'Pretendard', sans-serif;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 10002;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    
    .notification.show {
      opacity: 1;
      transform: translateX(-50%) translateY(-10px);
    }
    
    /* ========== 완전히 안정화된 화자 구분 스타일 (GPT 권장 기준) ========== */
    /* 세로 정렬용 wrapper - 내용을 감싸는 컨테이너 */
    .content-wrapper {
      width: 100%;
      flex-shrink: 0;
      display: flex;
      flex-direction: column;
      gap: 0px;
    }
    
    /* 
     * 핵심: 모든 라인(화자 있음/없음)을 동일한 구조로 통일
     * - display: flex로 고정 (block 혼용 금지)
     * - align-items: baseline (텍스트 기준 정렬)
     * - padding/margin: 0 (px 누적 방지)
     * - min-height: auto (1em 제거로 line-height 불일치 해소)
     */
    .speaker-line {
      display: flex;
      align-items: baseline;
      padding: 0;
      margin: 0;
      min-height: auto;
      box-sizing: border-box;
      line-height: inherit;
      flex-shrink: 0;
    }
    
    /* 화자 이름 영역 */
    .speaker-name {
      background: rgba(255, 255, 255, 0.08);
      padding: 3px 15px;
      border-radius: 4px;
      font-weight: 700;
      margin-right: 20px;
      white-space: nowrap;
      flex-shrink: 0;
      line-height: inherit;
      display: inline-flex;
      align-items: baseline;
      box-sizing: border-box;
    }
    
    /* 세로 구분선 */
    .speaker-divider {
      width: 2px;
      align-self: stretch;
      background: rgba(255, 255, 255, 0.3);
      margin-right: 20px;
      flex-shrink: 0;
    }
    
    /* 파이프 문자 구분 */
    .speaker-pipe {
      color: rgba(255, 255, 255, 0.4);
      margin: 0 20px;
      font-weight: 300;
      line-height: inherit;
    }
    
    /* 화자 내용 영역 */
    .speaker-content {
      flex: 1;
      line-height: inherit;
      min-width: 0;
      word-break: break-word;
      box-sizing: border-box;
    }
    
    /* 화자가 없는 일반 텍스트 라인 - 동일한 구조 유지 */
    .speaker-line.no-speaker {
      display: flex;
      align-items: baseline;
      line-height: inherit;
      padding: 0;
      margin: 0;
      min-height: auto;
      box-sizing: border-box;
    }
    
    /* 반응형 */
    @media (max-width: 600px) {
      .quick-wheel {
        width: 360px;
      }
      #viewer { padding: 10px; }
      #viewer-text {
        width: calc(100% - 20px);
        height: calc(100% - 20px);
      }
    }
  </style>
</head>
<body>
  <!-- 연결 상태 표시 -->
  <div id="connection-status" class="connecting">
    <div class="status-dot"></div>
    <span>연결 중...</span>
  </div>
  
  <div id="viewer">
    <div id="viewer-text">자막 대기 중...</div>
  </div>
  
  <!-- 여백 조절기 -->
  <div id="margin-adjuster"></div>
  
  <!-- 우클릭 빠른 설정 휠 -->
  <div class="quick-wheel-overlay" id="quickWheelOverlay">
    <div class="quick-wheel">
      <div class="quick-wheel-header">
        <h3>Viewer Settings</h3>
        <button class="close-btn" id="closeOptionsBtn">✕</button>
      </div>
      
      <div class="tab-nav">
        <button class="tab-btn active" data-tab="tab1">기본 설정</button>
        <button class="tab-btn" data-tab="tab2">레이아웃</button>
        <button class="tab-btn" data-tab="tab3">화자 구분</button>
        <button class="tab-btn" data-tab="tab4">프리셋</button>
      </div>
      
      <!-- 탭 1: 기본 설정 -->
      <div id="tab1" class="tab-content active">
        <div class="option-group">
          <div class="option-group-title">Display</div>
          
          <div class="option-row">
            <label>배경색</label>
            <div class="color-input-group">
              <input type="color" id="bgColor" value="#000000">
              <input type="text" class="color-hex" id="bgColorHex" value="#000000" maxlength="7">
              <input type="range" id="bgAlpha" min="0" max="100" value="100">
              <span class="unit-label" id="bgAlphaLabel" style="min-width: 35px;">100%</span>
            </div>
          </div>
          
          <div class="option-row">
            <label>글자색</label>
            <div class="color-input-group">
              <input type="color" id="fontColor" value="#ffffff">
              <input type="text" class="color-hex" id="fontColorHex" value="#FFFFFF" maxlength="7">
            </div>
          </div>
          
          <div class="option-row">
            <label>글꼴</label>
            <select id="fontFamily">
              <option value="'Noto Sans KR', sans-serif">Noto Sans KR</option>
              <option value="'Pretendard', sans-serif">Pretendard</option>
              <option value="sans-serif">기본 고딕</option>
              <option value="serif">기본 명조</option>
              <option value="'Nanum Gothic', sans-serif">나눔고딕</option>
              <option value="'Nanum Myeongjo', serif">나눔명조</option>
              <option value="'Nanum Pen Script', cursive">나눔펜체</option>
              <option value="'Jua', sans-serif">주아체</option>
              <option value="'Do Hyeon', sans-serif">도현체</option>
              <option value="'Gothic A1', sans-serif">고딕 A1</option>
              <option value="'IBM Plex Sans KR', sans-serif">IBM Plex 한글</option>
            </select>
          </div>
          
          <div class="option-row">
            <label>글자크기</label>
            <input type="number" id="fontSize" min="10" max="200" value="32">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="fontSizeUp">▲</button>
              <button type="button" id="fontSizeDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>자간</label>
            <input type="number" id="letterSpacing" min="-5" max="20" value="0" step="0.5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="letterSpacingUp">▲</button>
              <button type="button" id="letterSpacingDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>행간</label>
            <input type="number" id="lineHeight" min="1" max="3" value="1.5" step="0.1">
            <span class="unit-label">배</span>
            <div class="num-btns">
              <button type="button" id="lineHeightUp">▲</button>
              <button type="button" id="lineHeightDown">▼</button>
            </div>
          </div>
        </div>
        
        <div class="option-group">
          <div class="option-group-title">Effects</div>
          
          <div class="option-row">
            <label>테두리</label>
            <div class="color-input-group">
              <input type="checkbox" id="outlineOn">
              <input type="color" id="outlineColor" value="#000000">
              <input type="text" class="color-hex" id="outlineColorHex" value="#000000" maxlength="7">
            </div>
          </div>
          
          <div class="option-row">
            <label>굵기</label>
            <input type="number" id="outlineWidth" min="0" max="10" value="2" step="0.1">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="outlineWidthUp">▲</button>
              <button type="button" id="outlineWidthDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>그림자</label>
            <div class="color-input-group">
              <input type="checkbox" id="shadowOn">
              <input type="color" id="shadowColor" value="#000000">
              <input type="text" class="color-hex" id="shadowColorHex" value="#000000" maxlength="7">
            </div>
          </div>
          
          <div class="option-row">
            <label>흐림</label>
            <input type="number" id="shadowBlur" min="0" max="20" value="3" step="0.5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="shadowBlurUp">▲</button>
              <button type="button" id="shadowBlurDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>X 방향</label>
            <input type="number" id="shadowX" min="-20" max="20" value="2" step="0.5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="shadowXUp">▲</button>
              <button type="button" id="shadowXDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>Y 방향</label>
            <input type="number" id="shadowY" min="-20" max="20" value="2" step="0.5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="shadowYUp">▲</button>
              <button type="button" id="shadowYDown">▼</button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- 탭 2: 레이아웃 -->
      <div id="tab2" class="tab-content">
        <div class="option-group">
          <div class="option-group-title">Display Control</div>
          
          <div class="option-row">
            <label>자막 표시</label>
            <input type="checkbox" id="subtitleVisible" checked>
            <span style="color: #888; font-size: 11px; margin-left: 8px;">체크 해제 시 자막 숨김 (단축키: H)</span>
          </div>
        </div>
        
        <div class="option-group">
          <div class="option-group-title">Alignment</div>
          
          <div class="option-row">
            <label>가로정렬</label>
            <div style="display: flex; gap: 5px;">
              <button type="button" class="align-btn active" data-align="left" title="왼쪽">◀</button>
              <button type="button" class="align-btn" data-align="center" title="가운데">■</button>
              <button type="button" class="align-btn" data-align="right" title="오른쪽">▶</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>세로정렬</label>
            <div style="display: flex; gap: 5px;">
              <button type="button" class="valign-btn active" data-valign="top" title="상단">▲</button>
              <button type="button" class="valign-btn" data-valign="middle" title="중앙">■</button>
              <button type="button" class="valign-btn" data-valign="bottom" title="하단">▼</button>
            </div>
          </div>
        </div>
        
        <div class="option-group">
          <div class="option-group-title">Spacing</div>
          
          <div class="option-row">
            <label>여백조절기</label>
            <input type="checkbox" id="marginAdjusterToggle">
            <span style="color: #888; font-size: 11px; margin-left: 8px;">하단 드래그바</span>
          </div>
          
          <div class="option-row">
            <label>상단여백</label>
            <input type="number" id="marginTop" min="0" max="200" value="10" step="5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="marginTopUp">▲</button>
              <button type="button" id="marginTopDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>하단여백</label>
            <input type="number" id="marginBottom" min="0" max="400" value="10" step="5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="marginBottomUp">▲</button>
              <button type="button" id="marginBottomDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>좌측여백</label>
            <input type="number" id="marginLeft" min="0" max="200" value="15" step="5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="marginLeftUp">▲</button>
              <button type="button" id="marginLeftDown">▼</button>
            </div>
          </div>
          
          <div class="option-row">
            <label>우측여백</label>
            <input type="number" id="marginRight" min="0" max="200" value="15" step="5">
            <span class="unit-label">px</span>
            <div class="num-btns">
              <button type="button" id="marginRightUp">▲</button>
              <button type="button" id="marginRightDown">▼</button>
            </div>
          </div>
        </div>
      </div>
      
      <!-- 탭 3: 화자 구분 -->
      <div id="tab3" class="tab-content">
        <div class="option-group">
          <div class="option-group-title">Speaker Identification</div>
          
          <div class="option-row">
            <label>화자 구분</label>
            <input type="checkbox" id="speakerEnabled" checked>
            <span style="color: #888; font-size: 11px; margin-left: 8px;">활성화</span>
          </div>
          
          <div class="option-row">
            <label>구분 스타일</label>
            <select id="speakerStyle">
              <option value="divider">세로선 구분</option>
              <option value="pipe">파이프 문자 ( | )</option>
              <option value="minimal">미니멀 (은은하게)</option>
              <option value="none">구분선 없음</option>
            </select>
          </div>
          
          <div class="option-row">
            <label>화자 배경</label>
            <div class="color-input-group">
              <input type="checkbox" id="speakerBgEnabled" checked>
              <input type="color" id="speakerBgColor" value="#ffffff">
              <input type="range" id="speakerBgAlpha" min="0" max="30" value="8">
              <span class="unit-label" id="speakerBgAlphaLabel" style="min-width: 35px;">8%</span>
            </div>
          </div>
          
          <div class="option-row">
            <label>구분선 색상</label>
            <div class="color-input-group">
              <input type="checkbox" id="colorDividerEnabled">
              <input type="color" id="dividerColor" value="#4A90E2">
              <input type="text" class="color-hex" id="dividerColorHex" value="#4A90E2" maxlength="7">
            </div>
          </div>
          

        </div>
      </div>
      
      <!-- 탭 4: 프리셋 -->
      <div id="tab4" class="tab-content">
        <div class="preset-grid">
          <div class="preset-item" data-preset="basic">
            <div class="preset-name">기본 자막</div>
            <div class="preset-actions">
              <button class="preset-btn apply">적용</button>
            </div>
          </div>
          <div class="preset-item" data-preset="official">
            <div class="preset-name">공식 행사</div>
            <div class="preset-actions">
              <button class="preset-btn apply">적용</button>
            </div>
          </div>
          <div class="preset-item" data-preset="news">
            <div class="preset-name">뉴스/보도</div>
            <div class="preset-actions">
              <button class="preset-btn apply">적용</button>
            </div>
          </div>
          <div class="preset-item" data-preset="conference">
            <div class="preset-name">컨퍼런스/세미나</div>
            <div class="preset-actions">
              <button class="preset-btn apply">적용</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="notification" id="notification"></div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
  <script>
// ========== 설정 및 상태 관리 ==========
const CONFIG = {
  SOCKET_URL: 'https://nuastudio.co.kr',
  RECONNECT_DELAY: 1000,
  RECONNECT_DELAY_MAX: 5000,
  KEEPALIVE_INTERVAL: 15 * 60 * 1000
};

// URL 파라미터에서 채널 코드 가져오기
const params = new URLSearchParams(window.location.search);
let channelCode = params.get('channel');

// 채널 코드가 없으면 사용자에게 입력 받기
if (!channelCode) {
  channelCode = prompt('채널 코드를 입력하세요:');
  if (!channelCode) {
    alert('채널 코드가 필요합니다.');
    window.close();
  }
}

// DOM 요소
const viewerText = document.getElementById('viewer-text');
const connectionStatus = document.getElementById('connection-status');
const marginAdjusterToggle = document.getElementById('marginAdjusterToggle');
const marginAdjuster = document.getElementById('margin-adjuster');

// 상태 변수
let socket = null;
let keepaliveInterval = null;
let accumulatedText = '';
let activeStenographer = '1';
let currentActiveInput = '';
let isInitialConnection = true;

// 깜빡임 방지를 위한 변수 추가
let lastTextSentTime = 0;
let lastAccumulatedLength = 0;
let ignoreInputUntil = 0;

// 스마트 1단어 지연을 위한 변수
let previousInput = '';
let previousDisplay = '';

// 자막 숨김 상태
let isSubtitleHidden = false;
let wasHiddenBeforeInput = false;

// 화자 구분 관련

// 여백 조절기 상태
let marginAdjusterEnabled = false;
let marginOffset = 0;
let isDragging = false;
let startY = 0;
let startOffset = 0;
let maxMargin = 0;
let ignoreNextClick = false;

// ========== 스크롤 안정화 관련 변수 ==========
let lastRenderedText = '';
let isScrollManual = false;

// 프리셋 데이터
const presets = {
  'basic': {
    name: '기본 자막',
    bgColor: '#000000',
    bgAlpha: '100',
    fontColor: '#ffffff',
    fontSize: '32',
    fontFamily: "'Noto Sans KR', sans-serif",
    letterSpacing: '0',
    lineHeight: '1.5',
    outlineOn: false,
    shadowOn: false
  },
  'official': {
    name: '공식 행사',
    bgColor: '#003d7a',
    bgAlpha: '90',
    fontColor: '#ffffff',
    fontSize: '34',
    fontFamily: "'Noto Sans KR', sans-serif",
    letterSpacing: '1',
    lineHeight: '1.7',
    outlineOn: false,
    shadowOn: false
  },
  'news': {
    name: '뉴스/보도',
    bgColor: '#1a1a1a',
    bgAlpha: '95',
    fontColor: '#ffffff',
    fontSize: '30',
    fontFamily: "'Noto Sans KR', sans-serif",
    letterSpacing: '0',
    lineHeight: '1.4',
    outlineOn: false,
    shadowOn: true,
    shadowColor: '#000000',
    shadowBlur: '2',
    shadowX: '1',
    shadowY: '1'
  },
  'conference': {
    name: '컨퍼런스/세미나',
    bgColor: '#2c3e50',
    bgAlpha: '85',
    fontColor: '#ecf0f1',
    fontSize: '36',
    fontFamily: "'Pretendard', sans-serif",
    letterSpacing: '0.5',
    lineHeight: '1.6',
    outlineOn: false,
    shadowOn: true,
    shadowColor: '#000000',
    shadowBlur: '3',
    shadowX: '1',
    shadowY: '1'
  }
};

// ========== 스크롤 유틸리티 함수 ==========
function isNearBottom(el, thresholdPx = 2) {
  const gap = el.scrollHeight - (el.scrollTop + el.clientHeight);
  return gap <= thresholdPx;
}

function snapToBottom(el) {
  el.scrollTop = el.scrollHeight - el.clientHeight;
}

// ========== 연결 상태 관리 ==========
function updateConnectionStatus(status, message) {
  if (!isInitialConnection) {
    if (status === 'disconnected' && message.includes('채널')) {
      connectionStatus.className = status;
      connectionStatus.querySelector('span').textContent = message;
      connectionStatus.style.opacity = '1';
      setTimeout(() => {
        connectionStatus.style.opacity = '0';
      }, 5000);
    }
    return;
  }
  
  connectionStatus.className = status;
  connectionStatus.querySelector('span').textContent = message;
  
  if (status === 'connected') {
    setTimeout(() => {
      connectionStatus.style.opacity = '0';
      isInitialConnection = false;
    }, 3000);
  } else {
    connectionStatus.style.opacity = '1';
  }
}

// ========== Socket.IO 연결 관리 ==========
function initSocket() {
  console.log('[Socket] 초기화 시작:', CONFIG.SOCKET_URL);
  
  socket = io(CONFIG.SOCKET_URL, {
    transports: ['websocket', 'polling'],
    upgrade: true,
    reconnection: true,
    reconnectionAttempts: Infinity,
    reconnectionDelay: CONFIG.RECONNECT_DELAY,
    reconnectionDelayMax: CONFIG.RECONNECT_DELAY_MAX,
    timeout: 20000,
    forceNew: true
  });
  
  socket.on('connect', () => {
    console.log('[Socket] 연결 성공! ID:', socket.id);
    updateConnectionStatus('connected', '연결됨');
    joinChannel();
    startKeepalive();
  });
  
  socket.on('connect_error', (error) => {
    console.error('[Socket] 연결 에러:', error.message);
    updateConnectionStatus('disconnected', '연결 실패');
  });
  
  socket.on('disconnect', (reason) => {
    console.log('[Socket] 연결 끊김:', reason);
    updateConnectionStatus('disconnected', '연결 끊김');
    stopKeepalive();
  });
  
  socket.on('reconnect_attempt', (attemptNumber) => {
    console.log('[Socket] 재연결 시도:', attemptNumber);
    updateConnectionStatus('connecting', `재연결 중... (${attemptNumber})`);
  });
  
  socket.on('reconnect', () => {
    console.log('[Socket] 재연결 성공');
    updateConnectionStatus('connected', '재연결됨');
    joinChannel();
    startKeepalive();
  });
  
  socket.on('joined_channel', (data) => {
    console.log('[Channel] 참가 성공:', data);
    socket.emit('request_sync', { channel: channelCode });
  });
  
  socket.on('sync_accumulated', handleSyncAccumulated);
  socket.on('channel_state', handleChannelState);
  socket.on('steno_input', handleStenoInput);
  socket.on('switch_role', handleSwitchRole);
  socket.on('text_sent', handleTextSent);
  socket.on('clear_text', handleClearText);
}

// ========== 채널 참가 ==========
function joinChannel() {
  if (!socket || !socket.connected) {
    console.warn('[Channel] 소켓이 연결되지 않음');
    return;
  }
  
  console.log('[Channel] 참가 요청:', channelCode);
  socket.emit('join_channel', {
    channel: channelCode,
    role: 'viewer',
    requestSync: true
  });
}

// ========== Keepalive 관리 ==========
function startKeepalive() {
  stopKeepalive();
  
  keepaliveInterval = setInterval(() => {
    if (socket && socket.connected) {
      console.log('[Keepalive] 신호 전송');
      socket.emit('keepalive', {
        channel: channelCode,
        timestamp: Date.now()
      });
    }
  }, CONFIG.KEEPALIVE_INTERVAL);
}

function stopKeepalive() {
  if (keepaliveInterval) {
    clearInterval(keepaliveInterval);
    keepaliveInterval = null;
  }
}

// ========== 메시지 핸들러 ==========
function handleSyncAccumulated(data) {
  console.log('[Sync] 누적 텍스트 동기화');
  accumulatedText = data.accumulatedText || '';
  currentActiveInput = '';
  previousInput = '';
  previousDisplay = '';
  updateDisplay(accumulatedText, true);
  
  if (data.activeStenographer) {
    activeStenographer = data.activeStenographer === 'steno1' ? '1' : '2';
  }
}

function handleChannelState(data) {
  console.log('[State] 채널 상태:', data);
  if (data.state) {
    if (data.state.activeStenographer) {
      activeStenographer = data.state.activeStenographer === 'steno1' ? '1' : '2';
    }
    if (data.state.accumulatedText !== undefined) {
      accumulatedText = data.state.accumulatedText;
      currentActiveInput = '';
      previousInput = '';
      previousDisplay = '';
      updateDisplay(accumulatedText, true);
    }
  }
}

function handleStenoInput(data) {
  const roleNumber = data.role === 'steno1' ? '1' : 
                     data.role === 'steno2' ? '2' : 
                     data.role;
  
  if (roleNumber === activeStenographer) {
    const now = Date.now();
    const inputLength = (data.text || '').length;
    
    // 깜빡임 방지: text_sent 직후 1초간 짧아진 입력 무시
    if (now < ignoreInputUntil && inputLength < lastAccumulatedLength - 10) {
      console.log('⏭️ 빈 입력 무시:', inputLength, '<', lastAccumulatedLength);
      return;
    }
    
    currentActiveInput = data.text || '';
    const fullText = accumulatedText + currentActiveInput;
    updateDisplay(fullText, false);
  }
}

function handleSwitchRole(data) {
  activeStenographer = data.newActive === 'steno1' ? '1' : '2';
  
  if (data.accumulatedText !== undefined) {
    accumulatedText = data.accumulatedText;
    currentActiveInput = '';
    previousInput = '';
    previousDisplay = '';
    updateDisplay(accumulatedText, true);
  }
  
  console.log('[Role] 권한 전환:', activeStenographer);
}

function handleTextSent(data) {
  // 깜빡임 방지: text_sent 시간과 길이 기록
  lastTextSentTime = Date.now();
  lastAccumulatedLength = (data.accumulatedText || '').length;
  ignoreInputUntil = Date.now() + 1000; // 1초간 짧은 입력 무시
  
  accumulatedText = data.accumulatedText || '';
  currentActiveInput = '';
  previousInput = '';
  previousDisplay = '';
  updateDisplay(accumulatedText, true);
}

function handleClearText() {
  accumulatedText = '';
  currentActiveInput = '';
  previousInput = '';
  previousDisplay = '';
  lastRenderedText = '';
  updateDisplay('', true);
}

// ========== 개선된 화면 업데이트 함수 ==========
function updateDisplay(text, isImmediate = false) {
  // 자막 숨김 상태에서 새 입력이 들어오면 자동으로 표시
  if (isSubtitleHidden && text && text.trim()) {
    if (wasHiddenBeforeInput || text.length > (previousInput ? previousInput.length : 0)) {
      toggleSubtitleVisibility(true);
      wasHiddenBeforeInput = false;
    }
  }
  
  let displayText = text;
  
  if (isImmediate) {
    // 즉시 표시 (text_sent 등)
    previousInput = '';
    previousDisplay = '';
  } else {
    // 백스페이스 감지: 이전보다 짧아짐
    const isBackspace = previousInput.length > text.length;
    
    // 끝 공백만 지운 경우 감지
    const onlySpaceRemoved = isBackspace && 
                           previousInput.endsWith(' ') && 
                           text === previousInput.slice(0, -1);
    
    if (text.length > 0) {
      // 끝이 공백이면 전체 표시
      if (text.endsWith(' ') || text.endsWith('\n')) {
        displayText = text;
      }
      // 끝 공백만 지운 경우 → 이전 표시 내용 유지 (단어는 그대로)
      else if (onlySpaceRemoved && previousDisplay) {
        displayText = previousDisplay.trimEnd();
      }
      // 일반적인 1단어 지연
      else {
        const lastSpace = text.lastIndexOf(' ');
        const lastNewline = text.lastIndexOf('\n');
        const lastDelimiter = Math.max(lastSpace, lastNewline);
        
        if (lastDelimiter > -1) {
          displayText = text.substring(0, lastDelimiter + 1);
        } else {
          displayText = '';
        }
      }
    }
    
    // 상태 저장
    previousInput = text;
    previousDisplay = displayText;
  }

  // ========== 빈 줄 숨김 처리 (새 기능) ==========
  // 끝의 빈 줄들을 제거 (단, 새로운 입력이 시작되면 줄바꿈 표시)
  if (!currentActiveInput || currentActiveInput.trim().length === 0) {
    // 입력 중이 아니거나 빈 입력만 있으면 trailing newlines 제거
    displayText = displayText.replace(/\n+$/, '');
  }
  
  // ========== 불필요한 재렌더링 방지 ==========
  const finalDisplayText = displayText || '자막 대기 중...';
  if (finalDisplayText === lastRenderedText) {
    return; // 동일한 내용이면 재렌더링 하지 않음
  }
  
  // ========== 개선된 스크롤 위치 보존 ==========
  const scrollTop = viewerText.scrollTop;
  const scrollHeight = viewerText.scrollHeight;
  const clientHeight = viewerText.clientHeight;
  
  // 더 정확한 바닥 감지 (1px 허용치)
  const wasAtBottom = (scrollTop + clientHeight) >= (scrollHeight - 1);
  
  // 화자 구분 처리 - 항상 renderFormattedText 사용
  renderFormattedText(finalDisplayText);
  
  // 렌더링된 텍스트 기록
  lastRenderedText = finalDisplayText;
  
  // ========== 개선된 스크롤 복원 ==========
  if (wasAtBottom) {
    // 즉시 스크롤 (requestAnimationFrame 제거로 지연 최소화)
    viewerText.scrollTop = viewerText.scrollHeight - viewerText.clientHeight;
  } else {
    // 수동 스크롤 중이었다면 위치 유지
    viewerText.scrollTop = scrollTop;
  }
}

// ========== 화자 구분 형식 렌더링 함수 (GPT 권장사항 완전 적용) ==========
function renderFormattedText(text) {
  const lines = text.split('\n');
  const speakerEnabled = document.getElementById('speakerEnabled').checked;
  const speakerStyle = document.getElementById('speakerStyle').value;
  const useBg = document.getElementById('speakerBgEnabled').checked;
  const useColorDivider = document.getElementById('colorDividerEnabled').checked;
  const bgAlpha = parseInt(document.getElementById('speakerBgAlpha').value) / 100;
  
  // 현재 설정된 line-height 가져오기
  const currentLineHeight = viewerText.style.lineHeight;
  
  viewerText.innerHTML = '';
  
  // 세로 정렬 확인 및 wrapper 생성
  const vAlign = document.querySelector('.valign-btn.active')?.dataset.valign || 'top';
  const needsWrapper = vAlign === 'middle' || vAlign === 'bottom';
  
  let container = viewerText;
  if (needsWrapper) {
    const wrapper = document.createElement('div');
    wrapper.className = 'content-wrapper';
    viewerText.appendChild(wrapper);
    container = wrapper;
  }
  
  lines.forEach(line => {
    const lineDiv = document.createElement('div');
    lineDiv.className = 'speaker-line';
    
    // 모든 라인에 line-height 명시적 적용
    lineDiv.style.lineHeight = currentLineHeight;
    
    // 화자 구분이 활성화되고 화자 패턴이 있는 경우
    if (speakerEnabled && line.startsWith('-') && line.includes(': ')) {
      const colonIndex = line.indexOf(': ');
      const speaker = line.substring(1, colonIndex).trim(); // "-" 제거
      const content = line.substring(colonIndex + 2); // ": " 이후 내용
      
      // 화자 이름 요소
      const speakerSpan = document.createElement('span');
      speakerSpan.className = 'speaker-name';
      speakerSpan.textContent = speaker;
      
      // 배경색 설정
      if (useBg) {
        const bgColor = document.getElementById('speakerBgColor').value;
        const r = parseInt(bgColor.slice(1, 3), 16);
        const g = parseInt(bgColor.slice(3, 5), 16);
        const b = parseInt(bgColor.slice(5, 7), 16);
        speakerSpan.style.background = `rgba(${r}, ${g}, ${b}, ${bgAlpha})`;
      } else {
        speakerSpan.style.background = 'transparent';
      }
      
      lineDiv.appendChild(speakerSpan);
      
      // 구분 스타일 적용
      if (speakerStyle === 'divider') {
        const divider = document.createElement('div');
        divider.className = 'speaker-divider';
        
        // 구분선 색상 적용
        if (useColorDivider) {
          const dividerColor = document.getElementById('dividerColor').value;
          divider.style.background = dividerColor;
        }
        
        lineDiv.appendChild(divider);
      } else if (speakerStyle === 'pipe') {
        const pipe = document.createElement('span');
        pipe.className = 'speaker-pipe';
        pipe.textContent = '|';
        
        // 구분선 색상 적용
        if (useColorDivider) {
          const dividerColor = document.getElementById('dividerColor').value;
          pipe.style.color = dividerColor;
        }
        
        lineDiv.appendChild(pipe);
      } else if (speakerStyle === 'minimal') {
        const divider = document.createElement('div');
        divider.className = 'speaker-divider';
        divider.style.width = '1px';
        divider.style.margin = '0 25px';
        
        // 구분선 색상 적용
        if (useColorDivider) {
          const dividerColor = document.getElementById('dividerColor').value;
          divider.style.background = dividerColor;
        } else {
          divider.style.background = 'rgba(255, 255, 255, 0.2)';
        }
        
        lineDiv.appendChild(divider);
      }
      
      // 내용 요소
      const contentSpan = document.createElement('span');
      contentSpan.className = 'speaker-content';
      contentSpan.textContent = content || '\u200B'; // 빈 줄 처리
      lineDiv.appendChild(contentSpan);
      
    } else {
      // 일반 텍스트도 동일한 구조 사용 - GPT 권장: no-speaker도 같은 flex 구조
      lineDiv.classList.add('no-speaker');
      
      const contentSpan = document.createElement('span');
      contentSpan.className = 'speaker-content';
      contentSpan.textContent = line || '\u200B'; // 빈 줄 처리
      lineDiv.appendChild(contentSpan);
    }
    
    container.appendChild(lineDiv);
  });
}

// ========== 수동 스크롤 감지 ==========
viewerText.addEventListener('wheel', () => {
  isScrollManual = true;
  setTimeout(() => {
    isScrollManual = false;
  }, 1000);
});

viewerText.addEventListener('touchstart', () => {
  isScrollManual = true;
  setTimeout(() => {
    isScrollManual = false;
  }, 1000);
});

// 자막 표시/숨김 토글
function toggleSubtitleVisibility(forceShow = null) {
  if (forceShow !== null) {
    isSubtitleHidden = !forceShow;
  } else {
    isSubtitleHidden = !isSubtitleHidden;
  }
  
  if (isSubtitleHidden) {
    viewerText.classList.add('hidden');
    wasHiddenBeforeInput = true;
    document.getElementById('subtitleVisible').checked = false;
    showNotification('자막 숨김');
  } else {
    viewerText.classList.remove('hidden');
    wasHiddenBeforeInput = false;
    document.getElementById('subtitleVisible').checked = true;
    showNotification('자막 표시');
  }
}

// ========== UI 이벤트 ==========
// 우클릭 메뉴
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  showQuickWheel();
});

function showQuickWheel() {
  const overlay = document.getElementById('quickWheelOverlay');
  const quickWheel = document.querySelector('.quick-wheel');
  // 위치 리셋 (중앙)
  quickWheel.style.transform = '';
  overlay.classList.add('active');
}

function closeQuickWheel() {
  const overlay = document.getElementById('quickWheelOverlay');
  const quickWheel = document.querySelector('.quick-wheel');
  overlay.classList.remove('active');
  // 위치 리셋
  quickWheel.style.transform = '';
}

// 오버레이 클릭으로 닫기
document.getElementById('quickWheelOverlay').addEventListener('click', (e) => {
  if (e.target === e.currentTarget) {
    closeQuickWheel();
  }
});

// 옵션창 드래그 기능
let isDraggingOptions = false;
let optionsDragStartX = 0;
let optionsDragStartY = 0;
let optionsInitialX = 0;
let optionsInitialY = 0;

function setupOptionsDrag() {
  const quickWheel = document.querySelector('.quick-wheel');
  const quickWheelHeader = document.querySelector('.quick-wheel-header');
  
  // 헤더 클릭 시 드래그 시작
  quickWheelHeader.addEventListener('mousedown', (e) => {
    // X 버튼 클릭은 제외
    if (e.target.classList.contains('close-btn')) return;
    
    isDraggingOptions = true;
    
    // 현재 위치 계산
    const rect = quickWheel.getBoundingClientRect();
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    
    optionsInitialX = rect.left + rect.width / 2 - centerX;
    optionsInitialY = rect.top + rect.height / 2 - centerY;
    
    optionsDragStartX = e.clientX - optionsInitialX;
    optionsDragStartY = e.clientY - optionsInitialY;
    
    quickWheelHeader.style.cursor = 'grabbing';
  });
  
  // 드래그 중
  document.addEventListener('mousemove', (e) => {
    if (!isDraggingOptions) return;
    
    e.preventDefault();
    
    const x = e.clientX - optionsDragStartX;
    const y = e.clientY - optionsDragStartY;
    
    quickWheel.style.transform = `translate(${x}px, ${y}px)`;
  });
  
  // 드래그 종료
  document.addEventListener('mouseup', () => {
    if (isDraggingOptions) {
      isDraggingOptions = false;
      quickWheelHeader.style.cursor = 'grab';
    }
  });
}

// 탭 기능
const tabBtns = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');

tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const targetTab = btn.dataset.tab;
    
    tabBtns.forEach(b => b.classList.remove('active'));
    tabContents.forEach(c => c.classList.remove('active'));
    
    btn.classList.add('active');
    document.getElementById(targetTab).classList.add('active');
  });
});

// 정렬 버튼들
document.querySelectorAll('.align-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.align-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applyBasicOptions();
  });
});

document.querySelectorAll('.valign-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.valign-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applyBasicOptions();
  });
});

// 여백 조절기 토글
marginAdjusterToggle.addEventListener('change', () => {
  marginAdjusterEnabled = marginAdjusterToggle.checked;
  if (marginAdjusterEnabled) {
    marginAdjuster.classList.add('active');
    marginAdjuster.style.bottom = marginOffset + 'px';
    maxMargin = Math.floor(viewerText.clientHeight * 0.8);
  } else {
    marginAdjuster.classList.remove('active');
  }
  updateMarginAdjuster();
});

// 여백 조절기 업데이트
function updateMarginAdjuster() {
  const bottomMargin = parseInt(document.getElementById('marginBottom').value) || 0;
  const adjustedBottom = bottomMargin + marginOffset;
  
  if (marginOffset > 0 || bottomMargin > 0) {
    viewerText.style.paddingBottom = adjustedBottom + 'px';
  } else {
    viewerText.style.paddingBottom = '0px';
  }
  
  viewerText.scrollTop = viewerText.scrollHeight;
}

// 드래그 이벤트
marginAdjuster.addEventListener('mousedown', e => {
  if (!marginAdjusterEnabled) return;
  isDragging = true;
  startY = e.clientY;
  startOffset = marginOffset;
  maxMargin = Math.floor(viewerText.clientHeight * 0.8);
  marginAdjuster.classList.add('dragging');
  ignoreNextClick = true;
  e.preventDefault();
});

document.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const deltaY = startY - e.clientY;
  const newOffset = Math.max(0, Math.min(maxMargin, startOffset + deltaY));
  
  if (newOffset !== marginOffset) {
    marginOffset = newOffset;
    marginAdjuster.style.bottom = marginOffset + 'px';
    updateMarginAdjuster();
  }
});

document.addEventListener('mouseup', () => {
  if (isDragging) {
    isDragging = false;
    marginAdjuster.classList.remove('dragging');
    setTimeout(() => { ignoreNextClick = false; }, 100);
  }
});

// 프리셋 적용
document.querySelectorAll('.preset-item').forEach(item => {
  item.addEventListener('click', () => {
    const presetName = item.dataset.preset;
    applyPreset(presets[presetName]);
    
    // 선택 표시
    document.querySelectorAll('.preset-item').forEach(p => p.classList.remove('selected'));
    item.classList.add('selected');
    
    showNotification(`${presets[presetName].name} 적용됨`);
  });
});

function applyPreset(preset) {
  if (preset.bgColor) document.getElementById('bgColor').value = preset.bgColor;
  if (preset.bgAlpha) {
    document.getElementById('bgAlpha').value = preset.bgAlpha;
    document.getElementById('bgAlphaLabel').textContent = preset.bgAlpha + '%';
  }
  if (preset.fontColor) document.getElementById('fontColor').value = preset.fontColor;
  if (preset.fontSize) document.getElementById('fontSize').value = preset.fontSize;
  if (preset.fontFamily) document.getElementById('fontFamily').value = preset.fontFamily;
  if (preset.letterSpacing) document.getElementById('letterSpacing').value = preset.letterSpacing;
  if (preset.lineHeight) document.getElementById('lineHeight').value = preset.lineHeight;
  if (preset.outlineOn !== undefined) document.getElementById('outlineOn').checked = preset.outlineOn;
  if (preset.outlineColor) document.getElementById('outlineColor').value = preset.outlineColor;
  if (preset.outlineWidth) document.getElementById('outlineWidth').value = preset.outlineWidth;
  if (preset.shadowOn !== undefined) document.getElementById('shadowOn').checked = preset.shadowOn;
  if (preset.shadowColor) document.getElementById('shadowColor').value = preset.shadowColor;
  if (preset.shadowBlur) document.getElementById('shadowBlur').value = preset.shadowBlur;
  if (preset.shadowX) document.getElementById('shadowX').value = preset.shadowX;
  if (preset.shadowY) document.getElementById('shadowY').value = preset.shadowY;
  
  // HEX 값 업데이트
  document.getElementById('bgColorHex').value = preset.bgColor || '#000000';
  document.getElementById('fontColorHex').value = preset.fontColor || '#ffffff';
  if (preset.outlineColor) document.getElementById('outlineColorHex').value = preset.outlineColor;
  if (preset.shadowColor) document.getElementById('shadowColorHex').value = preset.shadowColor;
  
  applyBasicOptions();
}

// 색상 HEX 연동
function setupColorSync(colorId, hexId) {
  const colorInput = document.getElementById(colorId);
  const hexInput = document.getElementById(hexId);
  
  colorInput.addEventListener('input', () => {
    hexInput.value = colorInput.value.toUpperCase();
    applyBasicOptions();
  });
  
  hexInput.addEventListener('input', (e) => {
    let value = e.target.value;
    if (!value.startsWith('#')) value = '#' + value;
    value = value.slice(0, 7);
    e.target.value = value.toUpperCase();
    
    if (/^#[0-9A-F]{6}$/i.test(value)) {
      colorInput.value = value;
      applyBasicOptions();
    }
  });
}

// 옵션 적용 함수
function applyBasicOptions() {
  // 배경색에 투명도 적용
  const bgHex = document.getElementById('bgColor').value;
  const alpha = (parseInt(document.getElementById('bgAlpha').value) / 100).toFixed(2);
  const r = parseInt(bgHex.slice(1, 3), 16);
  const g = parseInt(bgHex.slice(3, 5), 16);
  const b = parseInt(bgHex.slice(5, 7), 16);
  document.getElementById('viewer').style.background = `rgba(${r}, ${g}, ${b}, ${alpha})`;
  
  // 텍스트 스타일
  viewerText.style.color = document.getElementById('fontColor').value;
  viewerText.style.fontSize = document.getElementById('fontSize').value + 'px';
  viewerText.style.fontFamily = document.getElementById('fontFamily').value;
  viewerText.style.letterSpacing = document.getElementById('letterSpacing').value + 'px';
  
  // line-height를 em 단위로 설정
  const lineHeightMul = parseFloat(document.getElementById('lineHeight').value);
  viewerText.style.lineHeight = lineHeightMul + 'em';
  
  // 정렬 설정
  const hAlign = document.querySelector('.align-btn.active')?.dataset.align || 'left';
  viewerText.style.textAlign = hAlign;
  
  // 세로 정렬 처리
  const vAlign = document.querySelector('.valign-btn.active')?.dataset.valign || 'top';
  viewerText.classList.remove('align-middle', 'align-bottom');
  
  if (vAlign === 'middle') {
    viewerText.classList.add('align-middle');
  } else if (vAlign === 'bottom') {
    viewerText.classList.add('align-bottom');
  }
  
  // 여백 설정
  const marginTop = parseInt(document.getElementById('marginTop').value) || 10;
  const marginBottom = parseInt(document.getElementById('marginBottom').value) || 10;
  const marginLeft = parseInt(document.getElementById('marginLeft').value) || 15;
  const marginRight = parseInt(document.getElementById('marginRight').value) || 15;
  
  viewerText.style.padding = `${marginTop}px ${marginRight}px ${marginBottom}px ${marginLeft}px`;
  viewerText.style.width = `calc(100% - ${marginLeft + marginRight}px)`;
  viewerText.style.height = `calc(100% - ${marginTop + marginBottom + 20}px)`;
  
  // 테두리 적용
  const outlineOn = document.getElementById('outlineOn').checked;
  const outlineColor = document.getElementById('outlineColor').value;
  const outlineWidth = document.getElementById('outlineWidth').value;
  
  // 그림자 적용
  const shadowOn = document.getElementById('shadowOn').checked;
  const shadowColor = document.getElementById('shadowColor').value;
  const shadowBlur = document.getElementById('shadowBlur').value;
  const shadowX = document.getElementById('shadowX').value;
  const shadowY = document.getElementById('shadowY').value;
  
  let textShadow = '';
  
  if (outlineOn && parseFloat(outlineWidth) > 0) {
    const outline = `-${outlineWidth}px -${outlineWidth}px 0 ${outlineColor}, ${outlineWidth}px -${outlineWidth}px 0 ${outlineColor}, -${outlineWidth}px ${outlineWidth}px 0 ${outlineColor}, ${outlineWidth}px ${outlineWidth}px 0 ${outlineColor}`;
    textShadow = outline;
  }
  
  if (shadowOn && parseFloat(shadowBlur) > 0) {
    const dropShadow = `${shadowX}px ${shadowY}px ${shadowBlur}px ${shadowColor}`;
    textShadow = textShadow ? textShadow + ', ' + dropShadow : dropShadow;
  }
  
  viewerText.style.textShadow = textShadow;
  updateMarginAdjuster();
  
  // 현재 텍스트 다시 렌더링 (스타일 적용)
  lastRenderedText = ''; // 강제 재렌더링
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
}

// 알림 표시
function showNotification(message, duration = 2000) {
  const notif = document.getElementById('notification');
  notif.textContent = message;
  notif.classList.add('show');
  
  setTimeout(() => {
    notif.classList.remove('show');
  }, duration);
}

// 설정 변경 이벤트 리스너들
document.getElementById('bgColor').addEventListener('input', applyBasicOptions);
document.getElementById('bgAlpha').addEventListener('input', (e) => {
  document.getElementById('bgAlphaLabel').textContent = e.target.value + '%';
  applyBasicOptions();
});
document.getElementById('fontColor').addEventListener('input', applyBasicOptions);
document.getElementById('fontSize').addEventListener('input', applyBasicOptions);
document.getElementById('fontFamily').addEventListener('change', applyBasicOptions);
document.getElementById('letterSpacing').addEventListener('input', applyBasicOptions);
document.getElementById('lineHeight').addEventListener('input', applyBasicOptions);
document.getElementById('marginTop').addEventListener('input', applyBasicOptions);
document.getElementById('marginBottom').addEventListener('input', applyBasicOptions);
document.getElementById('marginLeft').addEventListener('input', applyBasicOptions);
document.getElementById('marginRight').addEventListener('input', applyBasicOptions);
document.getElementById('outlineOn').addEventListener('change', applyBasicOptions);
document.getElementById('outlineColor').addEventListener('input', applyBasicOptions);
document.getElementById('outlineWidth').addEventListener('input', applyBasicOptions);
document.getElementById('shadowOn').addEventListener('change', applyBasicOptions);
document.getElementById('shadowColor').addEventListener('input', applyBasicOptions);
document.getElementById('shadowBlur').addEventListener('input', applyBasicOptions);
document.getElementById('shadowX').addEventListener('input', applyBasicOptions);
document.getElementById('shadowY').addEventListener('input', applyBasicOptions);

// 화자 구분 설정 변경 시 적용
document.getElementById('speakerEnabled').addEventListener('change', () => {
  lastRenderedText = ''; // 강제 재렌더링
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
});

document.getElementById('speakerStyle').addEventListener('change', () => {
  lastRenderedText = '';
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
});

document.getElementById('speakerBgEnabled').addEventListener('change', () => {
  lastRenderedText = '';
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
});

document.getElementById('speakerBgColor').addEventListener('input', () => {
  lastRenderedText = '';
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
});

document.getElementById('speakerBgAlpha').addEventListener('input', (e) => {
  document.getElementById('speakerBgAlphaLabel').textContent = e.target.value + '%';
  lastRenderedText = '';
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
});

document.getElementById('colorDividerEnabled').addEventListener('change', () => {
  lastRenderedText = '';
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
});

document.getElementById('dividerColor').addEventListener('input', () => {
  lastRenderedText = '';
  const currentText = accumulatedText + currentActiveInput;
  updateDisplay(currentText, true);
});

// 숫자 조절 버튼들
document.getElementById('fontSizeUp').addEventListener('click', () => {
  const input = document.getElementById('fontSize');
  input.value = Math.min(200, Number(input.value) + 1);
  applyBasicOptions();
});

document.getElementById('fontSizeDown').addEventListener('click', () => {
  const input = document.getElementById('fontSize');
  input.value = Math.max(10, Number(input.value) - 1);
  applyBasicOptions();
});

document.getElementById('letterSpacingUp').addEventListener('click', () => {
  const input = document.getElementById('letterSpacing');
  input.value = Math.min(20, Number(input.value) + 0.5).toFixed(1);
  applyBasicOptions();
});

document.getElementById('letterSpacingDown').addEventListener('click', () => {
  const input = document.getElementById('letterSpacing');
  input.value = Math.max(-5, Number(input.value) - 0.5).toFixed(1);
  applyBasicOptions();
});

document.getElementById('lineHeightUp').addEventListener('click', () => {
  const input = document.getElementById('lineHeight');
  input.value = Math.min(3, Number(input.value) + 0.1).toFixed(1);
  applyBasicOptions();
});

document.getElementById('lineHeightDown').addEventListener('click', () => {
  const input = document.getElementById('lineHeight');
  input.value = Math.max(1, Number(input.value) - 0.1).toFixed(1);
  applyBasicOptions();
});

document.getElementById('marginTopUp').addEventListener('click', () => {
  const input = document.getElementById('marginTop');
  input.value = Math.min(200, Number(input.value) + 5);
  applyBasicOptions();
});

document.getElementById('marginTopDown').addEventListener('click', () => {
  const input = document.getElementById('marginTop');
  input.value = Math.max(0, Number(input.value) - 5);
  applyBasicOptions();
});

document.getElementById('marginBottomUp').addEventListener('click', () => {
  const input = document.getElementById('marginBottom');
  input.value = Math.min(400, Number(input.value) + 5);
  applyBasicOptions();
});

document.getElementById('marginBottomDown').addEventListener('click', () => {
  const input = document.getElementById('marginBottom');
  input.value = Math.max(0, Number(input.value) - 5);
  applyBasicOptions();
});

document.getElementById('marginLeftUp').addEventListener('click', () => {
  const input = document.getElementById('marginLeft');
  input.value = Math.min(200, Number(input.value) + 5);
  applyBasicOptions();
});

document.getElementById('marginLeftDown').addEventListener('click', () => {
  const input = document.getElementById('marginLeft');
  input.value = Math.max(0, Number(input.value) - 5);
  applyBasicOptions();
});

document.getElementById('marginRightUp').addEventListener('click', () => {
  const input = document.getElementById('marginRight');
  input.value = Math.min(200, Number(input.value) + 5);
  applyBasicOptions();
});

document.getElementById('marginRightDown').addEventListener('click', () => {
  const input = document.getElementById('marginRight');
  input.value = Math.max(0, Number(input.value) - 5);
  applyBasicOptions();
});

document.getElementById('outlineWidthUp').addEventListener('click', () => {
  const input = document.getElementById('outlineWidth');
  input.value = Math.min(10, Number(input.value) + 0.1).toFixed(1);
  applyBasicOptions();
});

document.getElementById('outlineWidthDown').addEventListener('click', () => {
  const input = document.getElementById('outlineWidth');
  input.value = Math.max(0, Number(input.value) - 0.1).toFixed(1);
  applyBasicOptions();
});

document.getElementById('shadowBlurUp').addEventListener('click', () => {
  const input = document.getElementById('shadowBlur');
  input.value = Math.min(20, Number(input.value) + 0.5).toFixed(1);
  applyBasicOptions();
});

document.getElementById('shadowBlurDown').addEventListener('click', () => {
  const input = document.getElementById('shadowBlur');
  input.value = Math.max(0, Number(input.value) - 0.5).toFixed(1);
  applyBasicOptions();
});

document.getElementById('shadowXUp').addEventListener('click', () => {
  const input = document.getElementById('shadowX');
  input.value = Math.min(20, Number(input.value) + 0.5).toFixed(1);
  applyBasicOptions();
});

document.getElementById('shadowXDown').addEventListener('click', () => {
  const input = document.getElementById('shadowX');
  input.value = Math.max(-20, Number(input.value) - 0.5).toFixed(1);
  applyBasicOptions();
});

document.getElementById('shadowYUp').addEventListener('click', () => {
  const input = document.getElementById('shadowY');
  input.value = Math.min(20, Number(input.value) + 0.5).toFixed(1);
  applyBasicOptions();
});

document.getElementById('shadowYDown').addEventListener('click', () => {
  const input = document.getElementById('shadowY');
  input.value = Math.max(-20, Number(input.value) - 0.5).toFixed(1);
  applyBasicOptions();
});

// 자막 표시/숨김 체크박스
document.getElementById('subtitleVisible').addEventListener('change', (e) => {
  toggleSubtitleVisibility(e.target.checked);
});

// 전체화면 토글
document.body.addEventListener('dblclick', e => {
  if (e.target.closest('.quick-wheel-overlay')) return;
  
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

// 단축키 이벤트
document.addEventListener('keydown', (e) => {
  // 입력 필드에 포커스가 있으면 단축키 무시
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
    return;
  }
  
  switch(e.key) {
    case 'Escape':
      closeQuickWheel();
      break;
      
    case 'Enter':
      e.preventDefault();
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
      break;
      
    case 'ArrowUp':
      e.preventDefault();
      const currentSizeUp = parseInt(document.getElementById('fontSize').value);
      const newSizeUp = Math.min(200, currentSizeUp + 2);
      document.getElementById('fontSize').value = newSizeUp;
      applyBasicOptions();
      showNotification(`글자 크기: ${newSizeUp}px`);
      break;
      
    case 'ArrowDown':
      e.preventDefault();
      const currentSizeDown = parseInt(document.getElementById('fontSize').value);
      const newSizeDown = Math.max(10, currentSizeDown - 2);
      document.getElementById('fontSize').value = newSizeDown;
      applyBasicOptions();
      showNotification(`글자 크기: ${newSizeDown}px`);
      break;
      
    case 'h':
    case 'H':
      e.preventDefault();
      toggleSubtitleVisibility();
      break;
  }
});

// ========== 초기화 ==========
window.addEventListener('load', () => {
  console.log('[App] 초기화 시작');
  console.log('[App] 채널 코드:', channelCode);
  
  // 색상 연동 설정
  setupColorSync('bgColor', 'bgColorHex');
  setupColorSync('fontColor', 'fontColorHex');
  setupColorSync('outlineColor', 'outlineColorHex');
  setupColorSync('shadowColor', 'shadowColorHex');
  setupColorSync('dividerColor', 'dividerColorHex');
  
  // 옵션창 드래그 설정
  setupOptionsDrag();
  
  // X 버튼 클릭 이벤트
  document.getElementById('closeOptionsBtn').addEventListener('click', closeQuickWheel);
  
  // 초기 설정 적용
  applyBasicOptions();
  
  // Socket 연결 시작
  initSocket();
  
  // 단축키 안내 (3초 후)
  setTimeout(() => {
    showNotification('단축키: Enter(전체화면), ↑↓(글자크기), H(자막 숨김)', 5000);
  }, 3000);
});

// 페이지 언로드 시 정리
window.addEventListener('beforeunload', () => {
  stopKeepalive();
  if (socket) {
    socket.disconnect();
  }
});
  </script>
</body>
</html>

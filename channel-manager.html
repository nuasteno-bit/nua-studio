<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Channel Manager - NUA STUDIO</title>
  
  <!-- 보안: 즉시 토큰 검증 -->
  <script>
    (function() {
      const token = localStorage.getItem('adminToken');
      const role = localStorage.getItem('adminRole');
      
      // 토큰이 없거나 system_admin 역할이 아니면 즉시 리다이렉트
      // ⚠️ 중요: 백엔드의 역할 문자열과 정확히 일치해야 함
      // 예시: 'system_admin', 'admin', 'super', 'owner' 등
      // 실제 백엔드에서 사용하는 값으로 변경 필요
      const REQUIRED_ROLE = 'system_admin';  // TODO: 실제 백엔드 역할 문자열로 변경
      
      if (!token || role !== REQUIRED_ROLE) {
        window.location.replace('index.html');
        return;
      }
    })();
  </script>
  
  <!-- 변경: Contact/About과 동일한 폰트 추가 -->
  <link href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Poppins:100,100italic,200,200italic,300,300italic,regular,italic,500,500italic,600,600italic,700,700italic,800,800italic,900,900italic" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Ubuntu:300,300italic,regular,italic,500,500italic,700,700italic" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xeicon@2.3.3/xeicon.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css">
  
  <!-- 변경: GSAP 추가 (About/Contact 애니메이션용) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
  
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    :root {
      --black: #000000;
      --white: #ffffff;
      --gray: #666666;
      --light-gray: #f5f5f5;
      --neon-blue: #00f0ff;
      --neon-purple: #a259ff;
      --accent-gradient: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
      --ease: cubic-bezier(0.19, 1, 0.22, 1);
    }
    
    /* 변경: About/Contact 스타일 적용 */
    body {
      background: #fff;
      color: #000;
      font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      line-height: 1;
    }
    
    /* Scroll styles */
    html::-webkit-scrollbar {width: 8px;}
    html::-webkit-scrollbar-thumb {background-color: #2f3542; border-radius: 10px;}
    
    /* General wrapper styles */
    .wrap {margin: 0 auto; width: 95%;}
    .wrap[max='1708'] {max-width: 1708px;}
    .wrap[max='1440'] {max-width: 1440px;}
    
    /* Header - About/Contact 스타일 적용 */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: transparent;
      z-index: 1000;
      padding: 2rem 0;
      transition: all 0.3s ease;
    }
    
    .header.scrolled {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 20px rgba(0,0,0,0.05);
      padding: 1rem 0;
    }
    
    .header .wrap {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .header .logo {
      width: 122px;
      flex-shrink: 0;
      position: relative;
      z-index: 101;
    }
    
    .header .logo svg {
      width: 100%;
      height: auto;
    }
    
    .header .logo svg path {
      fill: #000;
    }
    
    .header .logo svg text {
      fill: #fff;
    }
    
    .header .menu {
      font-size: 20px;
      display: flex;
      align-items: center;
    }
    
    .header .menu ul {
      display: flex;
      align-items: center;
      gap: 3rem;
      list-style: none;
    }
    
    .header .menu li {
      font-size: inherit;
      font-weight: 700;
      letter-spacing: 0.025em;
      font-family: 'Ubuntu', sans-serif;
      position: relative;
      transition: .4s;
      color: #000;
    }
    
    .header .menu li.active {
      color: var(--neon-blue);
    }
    
    .header .menu li a {
      position: relative;
      z-index: 1;
      padding: 5px;
      color: inherit;
      text-decoration: none;
    }
    
    .header .menu li::before {
      content: '';
      z-index: -1;
      position: absolute;
      top: 0;
      left: 0;
      display: block;
      width: 0%;
      height: 100%;
      background: var(--neon-blue);
      transition: .4s;
    }
    
    .header .menu li:hover::before {
      width: 100%;
    }
    
    /* 변경: Hero Section 추가 (About/Contact 스타일) */
    .cm-hero {
      position: relative;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      background: #000;
    }
    
    .cm-hero-title {
      position: relative;
      z-index: 2;
      text-align: center;
      opacity: 0;
      transform: translateY(30px);
    }
    
    .cm-hero-title h1 {
      font-family: 'Poppins', sans-serif;
      font-size: clamp(80px, 10vw, 160px);
      font-weight: 700;
      letter-spacing: -0.02em;
      color: transparent;
      -webkit-text-stroke: 2px var(--neon-blue);
      margin-bottom: 2rem;
      position: relative;
      display: inline-block;
    }
    
    .cm-hero-title h1::after {
      content: 'CHANNEL';
      position: absolute;
      left: 10px;
      top: 10px;
      z-index: -1;
      background: linear-gradient(90deg, var(--neon-blue), var(--neon-purple));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      -webkit-text-stroke: 0;
    }
    
    .cm-hero-subtitle {
      font-family: 'Poppins', sans-serif;
      font-size: 1.5rem;
      color: #fff;
      opacity: 0.8;
      margin-bottom: 1rem;
    }
    
    .cm-hero-desc {
      font-family: 'Pretendard', sans-serif;
      font-size: 1.1rem;
      color: #fff;
      opacity: 0.6;
    }
    
    /* 변경: Floating objects (About/Contact 스타일) */
    .cm-objects {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      filter: url(#gooey);
      opacity: 0;
    }
    
    .cm-obj {
      position: absolute;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
      opacity: 0.3;
    }
    
    .cm-obj:nth-child(1) {
      width: 200px;
      height: 200px;
      top: 10%;
      left: 10%;
      animation: float1 8s ease-in-out infinite;
    }
    
    .cm-obj:nth-child(2) {
      width: 150px;
      height: 150px;
      top: 60%;
      right: 15%;
      animation: float2 10s ease-in-out infinite;
    }
    
    .cm-obj:nth-child(3) {
      width: 100px;
      height: 100px;
      bottom: 20%;
      left: 30%;
      animation: float3 6s ease-in-out infinite;
    }
    
    @keyframes float1 {
      0%, 100% { transform: translate(0, 0) scale(1); }
      50% { transform: translate(30px, -50px) scale(0.9); }
    }
    
    @keyframes float2 {
      0%, 100% { transform: translate(0, 0) scale(1); }
      50% { transform: translate(-40px, 30px) scale(1.1); }
    }
    
    @keyframes float3 {
      0%, 100% { transform: translate(0, 0) scale(1); }
      50% { transform: translate(20px, -30px) scale(0.95); }
    }
    
    /* Container 조정 */
    .container {
      max-width: 1440px;
      margin: 0 auto;
      padding: 2rem;
      position: relative;
      z-index: 1;
    }
    
    /* 변경: Section Title (About/Contact 스타일) */
    .cm-section-title {
      text-align: center;
      margin: 6rem 0 4rem;
      opacity: 0;
      transform: translateY(30px);
    }
    
    .cm-section-title span {
      font-family: 'Poppins', sans-serif;
      font-size: 1rem;
      font-weight: 500;
      color: var(--neon-blue);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      display: block;
      margin-bottom: 1rem;
    }
    
    .cm-section-title h2 {
      font-family: 'Poppins', sans-serif;
      font-size: 3rem;
      font-weight: 700;
      color: #000;
      letter-spacing: -0.02em;
      position: relative;
      display: inline-block;
    }
    
    .cm-section-title h2 b {
      background: linear-gradient(90deg, var(--neon-blue), var(--neon-purple));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    /* Stats Dashboard - 리디자인 */
    .stats-dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 2rem;
      margin: 4rem 0;
    }
    
    .stat-card {
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px solid transparent;
      background-clip: padding-box;
      border-radius: 20px;
      padding: 2rem;
      text-align: center;
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
      opacity: 0;
      transform: translateY(30px);
    }
    
    .stat-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--accent-gradient);
      border-radius: 20px;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: -1;
    }
    
    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 40px rgba(0, 240, 255, 0.2);
      border-color: var(--neon-blue);
    }
    
    .stat-card:hover::before {
      opacity: 0.05;
    }
    
    .stat-number {
      font-size: 3rem;
      font-weight: 700;
      background: linear-gradient(90deg, var(--neon-blue), var(--neon-purple));
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      font-family: 'Poppins', sans-serif;
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-family: 'Pretendard', sans-serif;
      font-weight: 500;
    }
    
    /* Create Channel Section - 리디자인 */
    .create-section {
      background: linear-gradient(135deg, #000 0%, #1a1a1a 100%);
      border: 2px solid transparent;
      background-clip: padding-box;
      border-radius: 30px;
      padding: 3rem;
      margin: 4rem 0;
      position: relative;
      overflow: hidden;
      opacity: 0;
      transform: translateY(30px);
    }
    
    .create-section::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: var(--accent-gradient);
      border-radius: 30px;
      z-index: -1;
    }
    
    .section-title {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 2rem;
      color: #fff;
      display: flex;
      align-items: center;
      gap: 1rem;
      font-family: 'Poppins', sans-serif;
      letter-spacing: -0.02em;
    }
    
    .create-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 2rem;
    }
    
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }
    
    .form-label {
      font-size: 0.9rem;
      color: var(--neon-blue);
      font-family: 'Poppins', sans-serif;
      font-weight: 500;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    
    input[type="text"], input[type="number"], input[type="datetime-local"], select {
      padding: 1rem 1.2rem;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.1);
      background: rgba(255,255,255,0.05);
      color: #fff;
      font-family: 'Pretendard', sans-serif;
      font-size: 1rem;
      letter-spacing: 0.02em;
      transition: all 0.3s ease;
      width: 100%;
      height: 50px;
    }
    
    input:focus, select:focus {
      outline: none;
      border-color: var(--neon-blue);
      background: rgba(0, 240, 255, 0.05);
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.1);
    }
    
    input::placeholder {
      color: rgba(255,255,255,0.3);
    }
    
    /* Quick Actions - 리디자인 */
    .quick-actions {
      display: flex;
      gap: 1.5rem;
      margin: 2rem 0;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .quick-btn {
      padding: 1.2rem 2rem;
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      border: 2px solid #e0e0e0;
      border-radius: 15px;
      color: #000;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 1rem;
      font-family: 'Pretendard', sans-serif;
      font-weight: 600;
      position: relative;
      overflow: hidden;
    }
    
    .quick-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 100%;
      background: var(--accent-gradient);
      transition: width 0.4s ease;
      z-index: -1;
    }
    
    .quick-btn:hover {
      color: #fff;
      border-color: var(--neon-blue);
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 240, 255, 0.3);
    }
    
    .quick-btn:hover::before {
      width: 100%;
    }
    
    /* Channel Type Radio - 리디자인 */
    .channel-types {
      display: flex;
      gap: 1rem;
    }
    
    .type-option {
      flex: 1;
      position: relative;
    }
    
    .type-option input[type="radio"] {
      position: absolute;
      opacity: 0;
    }
    
    .type-label {
      display: block;
      padding: 1rem;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      color: rgba(255,255,255,0.6);
      font-family: 'Pretendard', sans-serif;
      font-weight: 500;
    }
    
    .type-label:hover {
      background: rgba(0, 240, 255, 0.1);
      border-color: var(--neon-blue);
      color: #fff;
    }
    
    .type-option input[type="radio"]:checked + .type-label {
      background: var(--accent-gradient);
      border-color: transparent;
      color: #fff;
      font-weight: 600;
    }
    
    .passkey-group {
      display: flex;
      gap: 0.8rem;
      align-items: flex-end;
    }
    
    .passkey-group input {
      flex: 1;
    }
    
    .dice-button {
      background: rgba(255,255,255,0.1);
      border: 2px solid rgba(255,255,255,0.2);
      border-radius: 12px;
      padding: 0;
      cursor: pointer;
      color: #fff;
      font-size: 1.5rem;
      transition: all 0.3s ease;
      height: 50px;
      width: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .dice-button:hover {
      color: var(--neon-blue);
      background: rgba(0, 240, 255, 0.1);
      border-color: var(--neon-blue);
      transform: rotate(180deg) scale(1.1);
    }
    
    .btn-primary {
      background: var(--accent-gradient);
      color: #fff;
      padding: 1rem 3rem;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-size: 1.1rem;
      font-weight: 600;
      transition: all 0.3s ease;
      font-family: 'Poppins', sans-serif;
      letter-spacing: 0.02em;
      position: relative;
      overflow: hidden;
    }
    
    .btn-primary::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      transform: translate(-50%, -50%);
      transition: width 0.6s, height 0.6s;
    }
    
    .btn-primary:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 40px rgba(0, 240, 255, 0.4);
    }
    
    .btn-primary:hover::before {
      width: 300px;
      height: 300px;
    }
    
    /* Channel List Table - 리디자인 */
    .channel-list {
      background: #fff;
      border: 2px solid #f0f0f0;
      border-radius: 30px;
      overflow: hidden;
      margin: 4rem 0;
      box-shadow: 0 10px 40px rgba(0,0,0,0.05);
      opacity: 0;
      transform: translateY(30px);
    }
    
    .list-header {
      padding: 2rem;
      border-bottom: 2px solid #f0f0f0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(135deg, #fafafa 0%, #ffffff 100%);
    }
    
    .search-box {
      display: flex;
      gap: 1rem;
      align-items: center;
    }
    
    .search-box input {
      width: 300px;
      padding: 0.8rem 1.2rem;
      font-size: 0.95rem;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      transition: all 0.3s ease;
      font-family: 'Pretendard', sans-serif;
    }
    
    .search-box input:focus {
      border-color: var(--neon-blue);
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.1);
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
    }
    
    thead {
      background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%);
      border-bottom: 2px solid #f0f0f0;
    }
    
    th {
      padding: 1.5rem 1rem;
      text-align: left;
      font-size: 0.85rem;
      color: #666;
      font-weight: 700;
      letter-spacing: 0.1em;
      font-family: 'Poppins', sans-serif;
      text-transform: uppercase;
    }
    
    td {
      padding: 1.2rem 1rem;
      border-bottom: 1px solid #f0f0f0;
      font-size: 0.95rem;
      font-family: 'Pretendard', sans-serif;
    }
    
    tbody tr {
      transition: all 0.3s ease;
      background: #fff;
    }
    
    tbody tr:hover {
      background: linear-gradient(135deg, rgba(0,240,255,0.03) 0%, rgba(162,89,255,0.03) 100%);
      transform: translateX(5px);
    }
    
    .channel-code {
      font-family: 'Poppins', sans-serif;
      font-weight: 700;
      color: #000;
      letter-spacing: 0.05em;
      cursor: pointer;
      font-size: 1.1rem;
      transition: color 0.3s ease;
    }
    
    .channel-code:hover {
      color: var(--neon-blue);
    }
    
    .badge {
      padding: 0.4rem 0.8rem;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      display: inline-block;
      font-family: 'Poppins', sans-serif;
      letter-spacing: 0.05em;
    }
    
    .badge.public {
      background: linear-gradient(135deg, #4ecdc4, #44a3aa);
      color: #fff;
      border: none;
    }
    
    .badge.secured {
      background: linear-gradient(135deg, var(--neon-blue), var(--neon-purple));
      color: #fff;
      border: none;
    }
    
    .passkey {
      font-family: 'Poppins', sans-serif;
      background: #f5f5f5;
      padding: 0.3rem 0.6rem;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
      font-weight: 600;
      letter-spacing: 0.1em;
    }
    
    .active-count {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .count-dot {
      width: 10px;
      height: 10px;
      background: #4ecdc4;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.2); }
      100% { opacity: 1; transform: scale(1); }
    }
    
    .actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .btn-small {
      padding: 0.5rem 1rem;
      border: 2px solid #e0e0e0;
      background: #fff;
      color: #666;
      border-radius: 8px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Pretendard', sans-serif;
      font-weight: 600;
    }
    
    .btn-small:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
    }
    
    .btn-small.manage {
      border-color: var(--neon-blue);
      color: var(--neon-blue);
    }
    
    .btn-small.manage:hover {
      background: var(--neon-blue);
      color: #fff;
    }
    
    .btn-small.copy {
      border-color: #4ecdc4;
      color: #4ecdc4;
    }
    
    .btn-small.copy:hover {
      background: #4ecdc4;
      color: #fff;
    }
    
    .btn-small.delete {
      border-color: #e06c75;
      color: #e06c75;
    }
    
    .btn-small.delete:hover {
      background: #e06c75;
      color: #fff;
    }
    
    /* Modal - 리디자인 */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }
    
    .modal.show {
      display: flex;
    }
    
    .modal-content {
      background: #fff;
      border: 2px solid var(--neon-blue);
      border-radius: 30px;
      padding: 2.5rem;
      max-width: 650px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
    }
    
    .modal-content::before {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: var(--accent-gradient);
      border-radius: 30px;
      z-index: -1;
      opacity: 0.3;
      filter: blur(20px);
    }
    
    .modal-header {
      margin-bottom: 2rem;
      padding-bottom: 1.5rem;
      border-bottom: 2px solid #f0f0f0;
    }
    
    .modal-title {
      font-size: 1.8rem;
      font-weight: 700;
      color: #000;
      font-family: 'Poppins', sans-serif;
      letter-spacing: -0.02em;
    }
    
    .modal-title span {
      color: var(--neon-blue);
    }
    
    .modal-section {
      margin-bottom: 2rem;
    }
    
    .modal-section h4 {
      color: var(--neon-purple);
      font-size: 0.9rem;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-family: 'Poppins', sans-serif;
      font-weight: 600;
    }
    
    .url-group {
      display: flex;
      gap: 0.8rem;
      margin-bottom: 1rem;
    }
    
    .url-input {
      flex: 1;
      padding: 0.8rem;
      background: #f5f5f5;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      color: #666;
      font-family: 'Pretendard', sans-serif;
      font-size: 0.9rem;
    }
    
    .copy-btn {
      padding: 0.8rem 1.5rem;
      background: var(--accent-gradient);
      border: none;
      border-radius: 10px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Pretendard', sans-serif;
      font-weight: 600;
    }
    
    .copy-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0, 240, 255, 0.3);
    }
    
    .type-toggle {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
    }
    
    .type-toggle-btn {
      flex: 1;
      padding: 1rem;
      background: #f5f5f5;
      border: 2px solid #e0e0e0;
      border-radius: 12px;
      color: #666;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.95rem;
      font-family: 'Pretendard', sans-serif;
      font-weight: 600;
    }
    
    .type-toggle-btn.active {
      background: var(--accent-gradient);
      color: #fff;
      border-color: transparent;
    }
    
    .type-toggle-btn:hover:not(.active) {
      background: #fff;
      border-color: var(--neon-blue);
      color: var(--neon-blue);
    }
    
    .status-info {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
      padding: 1.5rem;
      background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
      border-radius: 15px;
      border: 2px solid #f0f0f0;
    }
    
    .status-item {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .status-label {
      font-size: 0.8rem;
      color: #888;
      font-family: 'Poppins', sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .status-value {
      font-size: 1.3rem;
      color: #000;
      font-weight: 700;
      font-family: 'Poppins', sans-serif;
    }
    
    .modal-footer {
      margin-top: 2rem;
      padding-top: 1.5rem;
      border-top: 2px solid #f0f0f0;
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }
    
    /* Footer - 리디자인 */
    footer {
      background: #000;
      text-align: center;
      padding: 3rem;
      font-size: 0.9rem;
      color: #666;
      margin-top: 6rem;
      font-family: 'Pretendard', sans-serif;
      position: relative;
    }
    
    footer::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent-gradient);
    }
    
    /* Loading */
    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid #e0e0e0;
      border-radius: 50%;
      border-top-color: var(--neon-blue);
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    /* Toast Notification - 리디자인 */
    .toast {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: #fff;
      border: 2px solid var(--neon-blue);
      border-radius: 15px;
      padding: 1.2rem 2rem;
      color: #000;
      z-index: 3000;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      font-family: 'Pretendard', sans-serif;
      font-weight: 600;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }
    
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    
    .toast.success {
      border-color: #4ecdc4;
      background: linear-gradient(135deg, #e8fffe 0%, #ffffff 100%);
    }
    
    .toast.error {
      border-color: #e06c75;
      background: linear-gradient(135deg, #ffe8e8 0%, #ffffff 100%);
    }
    
    /* SVG Filter for Gooey effect */
    svg {
      display: none;
    }
    
    /* Responsive */
    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
      
      .header .menu ul {
        gap: 1rem;
        font-size: 16px;
      }
      
      .create-form {
        grid-template-columns: 1fr;
      }
      
      .search-box input {
        width: 150px;
      }
      
      table {
        font-size: 0.8rem;
      }
      
      th, td {
        padding: 0.8rem 0.5rem;
      }
      
      .actions {
        flex-direction: column;
      }
      
      .stats-dashboard {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .cm-hero-title h1 {
        font-size: clamp(60px, 8vw, 100px);
      }
    }
    
    @media (max-width: 480px) {
      .stats-dashboard {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <!-- SVG Filter for Gooey Effect -->
  <svg>
    <filter id="gooey">
      <feGaussianBlur in="SourceGraphic" stdDeviation="10" />
      <feColorMatrix values="
        1 0 0 0 0
        0 1 0 0 0
        0 0 1 0 0
        0 0 0 20 -10" />
    </filter>
  </svg>

  <!-- Header - 구조 유지, 스타일만 변경 -->
  <header class="header" id="header">
    <div class="wrap" max="1708">
      <div class="logo">
        <a href="index.html">
          <svg viewBox="0 0 122 50" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M0 25C0 11.193 11.193 0 25 0h72c13.807 0 25 11.193 25 25s-11.193 25-25 25H25C11.193 50 0 38.807 0 25z" fill="#000"/>
            <text x="61" y="32" text-anchor="middle" fill="white" font-family="Poppins" font-size="20" font-weight="700">NUA</text>
          </svg>
        </a>
      </div>
      <div class="menu">
        <ul>
          <li><a href="index.html">HOME</a></li>
          <li class="active"><a href="#">ADMIN</a></li>
          <li><a href="#" onclick="showStats()">STATS</a></li>
          <li><a href="#" onclick="logout()">LOGOUT</a></li>
        </ul>
      </div>
    </div>
  </header>

  <!-- 변경: Hero Section 추가 -->
  <section class="cm-hero">
    <div class="cm-objects">
      <div class="cm-obj"></div>
      <div class="cm-obj"></div>
      <div class="cm-obj"></div>
    </div>
    
    <div class="cm-hero-title">
      <h1>CHANNEL</h1>
      <p class="cm-hero-subtitle">Real-time Caption Management</p>
      <p class="cm-hero-desc">NUA STUDIO</p>
    </div>
  </section>

  <div class="container">
    <!-- 변경: Section Title 추가 -->
    <div class="cm-section-title">
      <span>Dashboard</span>
      <h2>Channel <b>Statistics</b></h2>
    </div>

    <!-- Statistics Dashboard - 구조 유지, 스타일만 변경 -->
    <div class="stats-dashboard">
      <div class="stat-card">
        <div class="stat-number" id="totalChannels">0</div>
        <div class="stat-label">활성 채널</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="totalUsers">0</div>
        <div class="stat-label">전체 사용자</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="todayChannels">0</div>
        <div class="stat-label">오늘 생성</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="avgDuration">0</div>
        <div class="stat-label">평균 사용시간(분)</div>
      </div>
    </div>

    <!-- Quick Actions - 구조 유지 -->
    <div class="quick-actions">
      <button class="quick-btn" onclick="exportAllData()">
        📊 전체 데이터 내보내기
      </button>
      <button class="quick-btn" onclick="exportAllSubtitles()">
        📝 전체 자막 내보내기
      </button>
    </div>

    <!-- 변경: Section Title 추가 -->
    <div class="cm-section-title">
      <span>Create</span>
      <h2>New <b>Channel</b></h2>
    </div>

    <!-- Create New Channel - 구조 유지 -->
    <div class="create-section">
      <h2 class="section-title">📡 Create New Channel</h2>
      <form class="create-form" onsubmit="createChannel(event)">
        <div class="form-group">
          <label class="form-label">CHANNEL CODE</label>
          <div class="passkey-group">
            <input type="text" id="newChannelCode" placeholder="ABCD12" maxlength="6" required />
            <button type="button" class="dice-button" onclick="generateChannelCode()" title="Generate random code">🎲</button>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">CHANNEL TYPE</label>
          <div class="channel-types">
            <div class="type-option">
              <input type="radio" id="typePublic" name="channelType" value="public" />
              <label class="type-label" for="typePublic">🌐 공개</label>
            </div>
            <div class="type-option">
              <input type="radio" id="typeSecured" name="channelType" value="secured" checked />
              <label class="type-label" for="typeSecured">🔒 비공개</label>
            </div>
          </div>
        </div>

        <div class="form-group" id="passkeyField">
          <label class="form-label">PASSKEY (4 DIGITS)</label>
          <div class="passkey-group">
            <input type="text" id="newPasskey" placeholder="1234" maxlength="4" pattern="[0-9]{4}" />
            <button type="button" class="dice-button" onclick="generatePasskey()" title="Generate random passkey">🔐</button>
          </div>
        </div>

        <div class="form-group">
          <label class="form-label">EVENT NAME</label>
          <input type="text" id="eventName" placeholder="예: 2025 신년 세미나" />
        </div>

        <div class="form-group">
          <label class="form-label">EVENT DATE & TIME</label>
          <input type="datetime-local" id="eventDateTime" />
        </div>

        <div class="form-group">
          <label class="form-label">AUTO CLOSE</label>
          <div style="display: flex; gap: 0.5rem;">
            <select id="autoCloseType" onchange="toggleAutoCloseInput()" style="flex: 1;">
              <option value="none">자동 종료 안함</option>
              <option value="hours" selected>시간 후 종료</option>
              <option value="datetime">특정 시간 종료</option>
            </select>
            <select id="autoCloseHours" style="flex: 1;">
              <option value="1">1시간 후</option>
              <option value="2" selected>2시간 후</option>
              <option value="3">3시간 후</option>
              <option value="4">4시간 후</option>
              <option value="6">6시간 후</option>
              <option value="12">12시간 후</option>
              <option value="24">24시간 후</option>
            </select>
            <input type="datetime-local" id="autoCloseDateTime" style="flex: 1; display: none;" />
          </div>
        </div>

        <div class="form-group">
          <button type="submit" class="btn-primary" id="createBtn">CREATE CHANNEL</button>
        </div>
      </form>
    </div>

    <!-- 변경: Section Title 추가 -->
    <div class="cm-section-title">
      <span>Manage</span>
      <h2>Active <b>Channels</b></h2>
    </div>

    <!-- Channel List - 구조 유지 -->
    <div class="channel-list">
      <div class="list-header">
        <h2 class="section-title">📋 Active Channels</h2>
        <div class="search-box">
          <input type="text" placeholder="Search channels..." onkeyup="searchChannels(this.value)" />
          <button class="btn-small" onclick="searchChannels(document.querySelector('.search-box input').value)">Search</button>
        </div>
      </div>
      
      <table>
        <thead>
          <tr>
            <th>CHANNEL</th>
            <th>TYPE</th>
            <th>PASSKEY</th>
            <th>USERS</th>
            <th>STATUS</th>
            <th>CREATED</th>
            <th style="width: 300px;">ACTIONS</th>
          </tr>
        </thead>
        <tbody id="channelTableBody">
          <tr>
            <td colspan="7" style="text-align: center; padding: 2rem;">
              <div class="loading"></div>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Channel Management Modal - 구조 유지 -->
  <div class="modal" id="channelModal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">채널 관리: <span id="modalChannelCode"></span></h3>
      </div>
      
      <div class="modal-section">
        <h4>접속 URL</h4>
        <div class="url-group">
          <input type="text" class="url-input" id="viewerURL" readonly>
          <button class="copy-btn" onclick="copyURL('viewerURL')">복사</button>
        </div>
        <div class="url-group">
          <input type="text" class="url-input" id="stenoURL" readonly>
          <button class="copy-btn" onclick="copyURL('stenoURL')">복사</button>
        </div>
      </div>
      
      <div class="modal-section">
        <h4>채널 상태</h4>
        <div class="status-info">
          <div class="status-item">
            <span class="status-label">현재 접속자</span>
            <span class="status-value" id="modalViewers">0명</span>
          </div>
          <div class="status-item">
            <span class="status-label">생성 시간</span>
            <span class="status-value" id="modalCreated">-</span>
          </div>
          <div class="status-item">
            <span class="status-label">경과 시간</span>
            <span class="status-value" id="modalDuration">0분</span>
          </div>
          <div class="status-item">
            <span class="status-label">자동 종료</span>
            <span class="status-value" id="modalAutoClose">-</span>
          </div>
        </div>
      </div>
      
      <div class="modal-section">
        <h4>채널 타입 변경</h4>
        <div class="type-toggle">
          <button class="type-toggle-btn" id="publicToggle" onclick="changeChannelType('public')">
            🌐 공개로 변경
          </button>
          <button class="type-toggle-btn" id="securedToggle" onclick="changeChannelType('secured')">
            🔒 비공개로 변경
          </button>
        </div>
      </div>
      
      <div class="modal-section" id="passkeySection">
        <h4>패스키 변경</h4>
        <div class="url-group">
          <input type="text" id="modalNewPasskey" placeholder="새 패스키 (4자리)" maxlength="4">
          <button class="copy-btn" onclick="updatePasskey()">변경</button>
        </div>
      </div>
      
      <div class="modal-section">
        <h4>채널 연장</h4>
        <div class="quick-actions">
          <button class="quick-btn" onclick="extendChannel(1)">+1시간</button>
          <button class="quick-btn" onclick="extendChannel(2)">+2시간</button>
          <button class="quick-btn" onclick="extendChannel(3)">+3시간</button>
        </div>
      </div>
      
      <div class="modal-footer">
        <button class="btn-primary" onclick="exportChannelData()">데이터 내보내기</button>
        <button class="btn-small delete" onclick="deleteChannelFromModal()">채널 삭제</button>
        <button class="btn-small" onclick="closeModal()">닫기</button>
      </div>
    </div>
  </div>

  <!-- Toast Notification -->
  <div class="toast" id="toast"></div>

  <footer>
    &copy; 2025 NUA STUDIO · Channel Management System
  </footer>

  <script src="config.js"></script>
  <script>
    // API Base URL - REST API 우선, SOCKET_URL은 백업
    const API_BASE_URL = 
      (window.CONFIG && (window.CONFIG.API_BASE_URL || window.CONFIG.REST_URL)) ||
      (window.CONFIG && window.CONFIG.SOCKET_URL) || // 백업
      'http://localhost:3000';
    
    let currentModalChannel = null;
    let channels = [];
    
    // 인증 헤더 공통 함수
    function authHeaders(extra = {}) {
      const token = localStorage.getItem('adminToken');
      return {
        'Content-Type': 'application/json',
        'Authorization': token || '',
        'ngrok-skip-browser-warning': 'true',
        ...extra
      };
    }
    
    // Auth check - 보안 강화: 토큰과 역할 재확인
    const REQUIRED_ROLE = 'system_admin';  // TODO: 실제 백엔드 역할 문자열로 변경
    
    window.addEventListener('DOMContentLoaded', () => {
      const token = localStorage.getItem('adminToken');
      const role = localStorage.getItem('adminRole');
      
      // 토큰이 없거나 필요한 역할이 아니면 리다이렉트
      if (!token || role !== REQUIRED_ROLE) {
        alert('관리자 권한이 필요합니다.');
        window.location.href = 'index.html';
        return;
      }
      
      // Load initial data
      loadChannelList();
      updateStats();
      
      // Auto refresh every 30 seconds
      setInterval(() => {
        loadChannelList();
        updateStats();
      }, 30000);
      
      // 변경: GSAP 애니메이션 추가
      initAnimations();
    });
    
    // 변경: 애니메이션 초기화
    function initAnimations() {
      // Hero animation
      gsap.timeline()
        .to('.cm-hero-title', {opacity: 1, y: 0, duration: 1, delay: 0.5})
        .to('.cm-objects', {opacity: 1, duration: 1}, '-=0.5');
      
      // Scroll animations
      gsap.registerPlugin(ScrollTrigger);
      
      // Section titles
      gsap.utils.toArray('.cm-section-title').forEach(el => {
        gsap.to(el, {
          opacity: 1,
          y: 0,
          duration: 0.8,
          scrollTrigger: {
            trigger: el,
            start: 'top 80%',
            once: true
          }
        });
      });
      
      // Stats cards
      gsap.utils.toArray('.stat-card').forEach((el, i) => {
        gsap.to(el, {
          opacity: 1,
          y: 0,
          duration: 0.8,
          delay: i * 0.1,
          scrollTrigger: {
            trigger: '.stats-dashboard',
            start: 'top 70%',
            once: true
          }
        });
      });
      
      // Create section
      gsap.to('.create-section', {
        opacity: 1,
        y: 0,
        duration: 0.8,
        scrollTrigger: {
          trigger: '.create-section',
          start: 'top 70%',
          once: true
        }
      });
      
      // Channel list
      gsap.to('.channel-list', {
        opacity: 1,
        y: 0,
        duration: 0.8,
        scrollTrigger: {
          trigger: '.channel-list',
          start: 'top 70%',
          once: true
        }
      });
      
      // Header scroll effect
      window.addEventListener('scroll', () => {
        const header = document.getElementById('header');
        if (window.scrollY > 100) {
          header.classList.add('scrolled');
        } else {
          header.classList.remove('scrolled');
        }
      });
    }
    
    // Logout
    function logout() {
      const token = localStorage.getItem('adminToken');
      if (token) {
        fetch(`${API_BASE_URL}/api/admin/logout`, {
          method: 'POST',
          headers: authHeaders()
        });
      }
      localStorage.removeItem('adminToken');
      localStorage.removeItem('adminRole');
      window.location.href = 'index.html';
    }
    
    // Show stats (placeholder)
    function showStats() {
      showToast('통계 페이지 준비중입니다', 'info');
    }
    
    // Update statistics
    function updateStats() {
      const today = new Date().toDateString();
      const todayChannels = channels.filter(ch => 
        new Date(ch.createdAt).toDateString() === today
      ).length;
      
      document.getElementById('totalChannels').textContent = channels.length;
      document.getElementById('totalUsers').textContent = channels.reduce((sum, ch) => sum + (ch.activeUsers || 0), 0);
      document.getElementById('todayChannels').textContent = todayChannels;
      
      // TODO: 실제 평균 사용시간 계산 로직 구현 필요 (현재는 mock 데이터)
      // 예: 각 채널의 createdAt과 현재 시간 차이를 계산하여 평균 산출
      document.getElementById('avgDuration').textContent = Math.floor(Math.random() * 60 + 30);
    }
    
    // Channel type toggle
    document.querySelectorAll('input[name="channelType"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const passkeyField = document.getElementById('passkeyField');
        if (this.value === 'public') {
          passkeyField.style.opacity = '0.5';
          passkeyField.style.pointerEvents = 'none';
          document.getElementById('newPasskey').value = '';
        } else {
          passkeyField.style.opacity = '1';
          passkeyField.style.pointerEvents = 'auto';
          generatePasskey();
        }
      });
    });
    
    // Toggle auto close input
    function toggleAutoCloseInput() {
      const type = document.getElementById('autoCloseType').value;
      const hoursSelect = document.getElementById('autoCloseHours');
      const dateTimeInput = document.getElementById('autoCloseDateTime');
      
      if (type === 'none') {
        hoursSelect.style.display = 'none';
        dateTimeInput.style.display = 'none';
      } else if (type === 'hours') {
        hoursSelect.style.display = 'block';
        dateTimeInput.style.display = 'none';
      } else if (type === 'datetime') {
        hoursSelect.style.display = 'none';
        dateTimeInput.style.display = 'block';
        
        // Set minimum datetime to now
        const now = new Date();
        now.setMinutes(now.getMinutes() + 30); // Minimum 30 minutes from now
        dateTimeInput.min = now.toISOString().slice(0, 16);
        if (!dateTimeInput.value) {
          dateTimeInput.value = now.toISOString().slice(0, 16);
        }
      }
    }
    
    // Export all subtitles
    async function exportAllSubtitles() {
      const subtitlesData = {};
      
      // Collect subtitle data for each channel
      for (const channel of channels) {
        // TODO: 실제 서버에서 자막 데이터 가져오기
        // const response = await fetch(`${API_BASE_URL}/api/channel/${channel.code}/subtitles`, {
        //   headers: authHeaders()
        // });
        // const data = await response.json();
        
        subtitlesData[channel.code] = {
          channelCode: channel.code,
          eventName: channel.eventName || 'Untitled',
          createdAt: channel.createdAt,
          subtitles: channel.accumulatedText || '[자막 데이터 없음]'
        };
      }
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const blob = new Blob([JSON.stringify(subtitlesData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `all_subtitles_${timestamp}.json`;
      a.click();
      
      showToast('전체 자막이 내보내졌습니다', 'success');
    }
    
    // Generate random channel code
    function generateChannelCode() {
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let code = '';
      for (let i = 0; i < 6; i++) {
        code += characters.charAt(Math.floor(Math.random() * characters.length));
      }
      document.getElementById('newChannelCode').value = code;
      animateInput('newChannelCode');
    }
    
    // Generate random passkey
    function generatePasskey() {
      const passkey = Math.floor(1000 + Math.random() * 9000).toString();
      document.getElementById('newPasskey').value = passkey;
      animateInput('newPasskey');
    }
    
    // Input animation
    function animateInput(inputId) {
      const input = document.getElementById(inputId);
      gsap.to(input, {
        scale: 1.05,
        duration: 0.2,
        onComplete: () => {
          gsap.to(input, {scale: 1, duration: 0.2});
        }
      });
    }
    
    // Create channel
    async function createChannel(event) {
      event.preventDefault();
      
      const createBtn = document.getElementById('createBtn');
      const originalText = createBtn.textContent;
      createBtn.disabled = true;
      createBtn.innerHTML = '<span class="loading" style="width: 16px; height: 16px;"></span>';
      
      // Get auto close settings
      let autoCloseValue = null;
      const autoCloseType = document.getElementById('autoCloseType').value;
      
      if (autoCloseType === 'hours') {
        autoCloseValue = {
          type: 'hours',
          value: parseInt(document.getElementById('autoCloseHours').value)
        };
      } else if (autoCloseType === 'datetime') {
        autoCloseValue = {
          type: 'datetime',
          value: document.getElementById('autoCloseDateTime').value
        };
      }
      
      const channelData = {
        code: document.getElementById('newChannelCode').value,
        type: document.querySelector('input[name="channelType"]:checked').value,
        passkey: document.getElementById('newPasskey').value || null,
        eventDateTime: document.getElementById('eventDateTime').value || null,
        eventName: document.getElementById('eventName').value || null,
        autoClose: autoCloseValue
      };
      
      try {
        const response = await fetch(`${API_BASE_URL}/api/channel/create`, {
          method: 'POST',
          headers: authHeaders(),
          body: JSON.stringify(channelData)
        });
        
        const result = await response.json();
        
        if (response.ok) {
          showToast(`채널 ${channelData.code}가 생성되었습니다`, 'success');
          document.querySelector('.create-form').reset();
          document.getElementById('typeSecured').checked = true;
          document.getElementById('autoCloseType').value = 'hours';
          document.getElementById('autoCloseHours').value = '2';
          toggleAutoCloseInput();
          generatePasskey();
          await loadChannelList();
          
          // Show URLs immediately
          showChannelModal(channelData.code);
        } else {
          showToast(result.error || '채널 생성 실패', 'error');
        }
      } catch (error) {
        console.error('Error:', error);
        showToast('서버 연결 실패', 'error');
      } finally {
        createBtn.disabled = false;
        createBtn.textContent = originalText;
      }
    }
    
    // Load channel list
    async function loadChannelList() {
      try {
        const response = await fetch(`${API_BASE_URL}/api/channels`, {
          headers: authHeaders()
        });
        
        if (!response.ok) {
          throw new Error('Failed to fetch channels');
        }
        
        channels = await response.json();
        const tbody = document.getElementById('channelTableBody');
        
        if (channels.length === 0) {
          tbody.innerHTML = `
            <tr>
              <td colspan="7" style="text-align: center; padding: 2rem; color: #888;">
                No channels created yet
              </td>
            </tr>
          `;
          return;
        }
        
        tbody.innerHTML = channels.map(ch => {
          const createdDate = new Date(ch.createdAt);
          const now = new Date();
          const duration = Math.floor((now - createdDate) / 60000); // minutes
          
          return `
            <tr>
              <td>
                <span class="channel-code" onclick="showChannelModal('${ch.code}')">${ch.code}</span>
              </td>
              <td><span class="badge ${ch.type}" id="type-${ch.code}">${ch.type === 'public' ? '공개' : '비공개'}</span></td>
              <td><span id="passkey-${ch.code}">${ch.passkey ? `<span class="passkey">${ch.passkey}</span>` : '-'}</span></td>
              <td>
                <div class="active-count">
                  ${ch.activeUsers > 0 ? '<span class="count-dot"></span>' : ''}
                  <span>${ch.activeUsers || 0}</span>
                </div>
              </td>
              <td>
                <span style="color: ${duration < 60 ? '#4ecdc4' : duration < 180 ? '#f0c674' : '#e06c75'}">
                  ${duration < 60 ? '활성' : duration < 180 ? '진행중' : '장시간'}
                </span>
              </td>
              <td>${createdDate.toLocaleString('ko-KR', { 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
              })}</td>
              <td>
                <div class="actions">
                  <button class="btn-small manage" onclick="showChannelModal('${ch.code}')">관리</button>
                  <button class="btn-small copy" onclick="copyChannelURL('${ch.code}')">URL복사</button>
                  <button class="btn-small delete" onclick="deleteChannel('${ch.code}')">삭제</button>
                </div>
              </td>
            </tr>
          `;
        }).join('');
        
        updateStats();
      } catch (error) {
        console.error('Error loading channels:', error);
        const tbody = document.getElementById('channelTableBody');
        tbody.innerHTML = `
          <tr>
            <td colspan="7" style="text-align: center; padding: 2rem; color: #e06c75;">
              Failed to load channels. Please check your connection.
            </td>
          </tr>
        `;
      }
    }
    
    // Show channel modal
    function showChannelModal(code) {
      const channel = channels.find(ch => ch.code === code);
      if (!channel) return;
      
      currentModalChannel = channel;
      
      document.getElementById('modalChannelCode').textContent = code;
      document.getElementById('viewerURL').value = `${window.location.origin}/viewer.html?channel=${code}`;
      document.getElementById('stenoURL').value = `${window.location.origin}/editor.html?channel=${code}`;
      
      document.getElementById('modalViewers').textContent = `${channel.activeUsers || 0}명`;
      document.getElementById('modalCreated').textContent = new Date(channel.createdAt).toLocaleString('ko-KR');
      
      const duration = Math.floor((new Date() - new Date(channel.createdAt)) / 60000);
      document.getElementById('modalDuration').textContent = `${duration}분`;
      
      // Display auto close information
      let autoCloseText = '설정 안함';
      if (channel.autoClose) {
        if (channel.autoClose.type === 'hours') {
          autoCloseText = `${channel.autoClose.value}시간 후`;
        } else if (channel.autoClose.type === 'datetime') {
          const closeDate = new Date(channel.autoClose.value);
          autoCloseText = closeDate.toLocaleString('ko-KR');
        }
      }
      document.getElementById('modalAutoClose').textContent = autoCloseText;
      
      // Update type toggle buttons
      if (channel.type === 'public') {
        document.getElementById('publicToggle').classList.add('active');
        document.getElementById('securedToggle').classList.remove('active');
        document.getElementById('passkeySection').style.display = 'none';
      } else {
        document.getElementById('publicToggle').classList.remove('active');
        document.getElementById('securedToggle').classList.add('active');
        document.getElementById('passkeySection').style.display = 'block';
      }
      
      document.getElementById('channelModal').classList.add('show');
    }
    
    // Change channel type
    async function changeChannelType(newType) {
      if (!currentModalChannel) return;
      
      const oldType = currentModalChannel.type;
      if (oldType === newType) {
        showToast('이미 해당 타입입니다', 'info');
        return;
      }
      
      // 공개→비공개 전환이면 새 패스키 미리 준비
      let newPasskey = null;
      if (newType === 'secured') {
        newPasskey = Math.floor(1000 + Math.random() * 9000).toString();
      }
      
      try {
        // 1) 서버에 타입과 패스키 함께 반영
        const res = await fetch(`${API_BASE_URL}/api/channel/${currentModalChannel.code}/type`, {
          method: 'PATCH',
          headers: authHeaders(),
          body: JSON.stringify({ 
            type: newType, 
            passkey: newPasskey  // 타입과 패스키 함께 전송
          })
        });
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.message || '타입 변경 실패');
        }
        
        // 2) 로컬 데이터 업데이트
        currentModalChannel.type = newType;
        currentModalChannel.passkey = newPasskey;
        
        if (newType === 'public') {
          document.getElementById('publicToggle').classList.add('active');
          document.getElementById('securedToggle').classList.remove('active');
          document.getElementById('passkeySection').style.display = 'none';
        } else {
          document.getElementById('publicToggle').classList.remove('active');
          document.getElementById('securedToggle').classList.add('active');
          document.getElementById('passkeySection').style.display = 'block';
          document.getElementById('modalNewPasskey').value = '';
        }
        
        // 3) 테이블 UI 업데이트
        const typeElement = document.querySelector(`#type-${currentModalChannel.code}`);
        const passkeyElement = document.querySelector(`#passkey-${currentModalChannel.code}`);
        
        if (typeElement) {
          typeElement.className = `badge ${newType}`;
          typeElement.textContent = newType === 'public' ? '공개' : '비공개';
        }
        
        if (passkeyElement) {
          passkeyElement.innerHTML = currentModalChannel.passkey ? 
            `<span class="passkey">${currentModalChannel.passkey}</span>` : '-';
        }
        
        // 4) channels 배열 업데이트
        const channelIndex = channels.findIndex(ch => ch.code === currentModalChannel.code);
        if (channelIndex !== -1) {
          channels[channelIndex] = currentModalChannel;
        }
        
        showToast(`채널이 ${newType === 'public' ? '공개' : '비공개'}로 변경되었습니다`, 'success');
      } catch (error) {
        showToast(error.message || '변경 실패', 'error');
      }
    }
    
    // Close modal
    function closeModal() {
      document.getElementById('channelModal').classList.remove('show');
      currentModalChannel = null;
    }
    
    // Copy URL - 최신 Clipboard API 우선, fallback 포함
    async function copyURL(inputId) {
      const input = document.getElementById(inputId);
      const text = input.value;
      
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
        } else {
          // Fallback for older browsers or non-secure contexts
          input.select();
          document.execCommand('copy');
        }
        showToast('URL이 복사되었습니다', 'success');
      } catch (error) {
        showToast('복사 실패', 'error');
      }
    }
    
    // Copy channel URL directly - 최신 Clipboard API 우선, fallback 포함
    async function copyChannelURL(code) {
      const url = `${window.location.origin}/viewer.html?channel=${code}`;
      
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(url);
        } else {
          // Fallback: 임시 input 생성
          const tempInput = document.createElement('input');
          tempInput.value = url;
          document.body.appendChild(tempInput);
          tempInput.select();
          document.execCommand('copy');
          document.body.removeChild(tempInput);
        }
        showToast('뷰어 URL이 복사되었습니다', 'success');
      } catch (error) {
        showToast('복사 실패', 'error');
      }
    }
    
    // Update passkey
    async function updatePasskey() {
      const newPasskey = document.getElementById('modalNewPasskey').value;
      if (!/^\d{4}$/.test(newPasskey)) {
        showToast('4자리 패스키를 입력하세요', 'error');
        return;
      }
      
      if (!currentModalChannel) return;
      
      try {
        // 1) 서버 반영
        const res = await fetch(`${API_BASE_URL}/api/channel/${currentModalChannel.code}/passkey`, {
          method: 'PATCH',
          headers: authHeaders(),
          body: JSON.stringify({ passkey: newPasskey })
        });
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.message || '패스키 변경 실패');
        }
        
        // 2) 로컬 데이터 업데이트
        currentModalChannel.passkey = newPasskey;
        
        // 3) 테이블 UI 업데이트
        const passkeyElement = document.querySelector(`#passkey-${currentModalChannel.code}`);
        if (passkeyElement) {
          passkeyElement.innerHTML = `<span class="passkey">${newPasskey}</span>`;
        }
        
        // 4) channels 배열 업데이트
        const channelIndex = channels.findIndex(ch => ch.code === currentModalChannel.code);
        if (channelIndex !== -1) {
          channels[channelIndex].passkey = newPasskey;
        }
        
        showToast('패스키가 변경되었습니다', 'success');
        document.getElementById('modalNewPasskey').value = '';
      } catch (error) {
        showToast(error.message || '변경 실패', 'error');
      }
    }
    
    // Extend channel
    async function extendChannel(hours) {
      if (!currentModalChannel) return;
      
      try {
        const res = await fetch(`${API_BASE_URL}/api/channel/${currentModalChannel.code}/extend`, {
          method: 'POST',
          headers: authHeaders(),
          body: JSON.stringify({ hours })
        });
        
        if (!res.ok) {
          const error = await res.json();
          throw new Error(error.message || '연장 실패');
        }
        
        showToast(`채널이 ${hours}시간 연장되었습니다`, 'success');
        
        // 필요시 채널 목록 재로드
        // await loadChannelList();
      } catch (error) {
        showToast(error.message || '연장 실패', 'error');
      }
    }
    
    // Export modal channel subtitles
    function exportModalChannelSubtitles() {
      if (currentModalChannel) {
        exportChannelSubtitles(currentModalChannel.code);
      }
    }
    
    // Export channel data
    async function exportChannelData() {
      if (!currentModalChannel) return;
      
      try {
        // TODO: 서버에서 전체 채널 데이터 가져오기
        // const response = await fetch(`${API_BASE_URL}/api/channel/${currentModalChannel.code}/full`, {
        //   headers: authHeaders()
        // });
        // const fullData = await response.json();
        
        const data = {
          channel: currentModalChannel.code,
          type: currentModalChannel.type,
          passkey: currentModalChannel.passkey,
          created: currentModalChannel.createdAt,
          event: currentModalChannel.eventName,
          autoClose: currentModalChannel.autoClose,
          // 실제 자막 데이터는 서버에서 가져와야 함
          // accumulatedText: fullData.accumulatedText
        };
        
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `channel_${currentModalChannel.code}_${Date.now()}.json`;
        a.click();
        
        showToast('데이터가 내보내졌습니다', 'success');
      } catch (error) {
        showToast('데이터 내보내기 실패', 'error');
      }
    }
    
    // Export all data
    function exportAllData() {
      const blob = new Blob([JSON.stringify(channels, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `all_channels_${Date.now()}.json`;
      a.click();
      
      showToast('전체 데이터가 내보내졌습니다', 'success');
    }
    
    // Delete channel
    async function deleteChannel(code) {
      if (confirm(`채널 ${code}를 삭제하시겠습니까?`)) {
        try {
          const response = await fetch(`${API_BASE_URL}/api/channel/${code}`, {
            method: 'DELETE',
            headers: authHeaders()
          });
          
          if (response.ok) {
            showToast('채널이 삭제되었습니다', 'success');
            await loadChannelList();
          } else {
            const result = await response.json();
            showToast(result.error || '삭제 실패', 'error');
          }
        } catch (error) {
          console.error('Error:', error);
          showToast('서버 연결 실패', 'error');
        }
      }
    }
    
    // Delete channel from modal
    function deleteChannelFromModal() {
      if (currentModalChannel) {
        deleteChannel(currentModalChannel.code);
        closeModal();
      }
    }
    
    // Search channels
    function searchChannels(query) {
      const rows = document.querySelectorAll('#channelTableBody tr');
      query = query.toLowerCase();
      
      rows.forEach(row => {
        const channelCodeElement = row.querySelector('.channel-code');
        if (channelCodeElement) {
          const text = row.textContent.toLowerCase();
          row.style.display = text.includes(query) ? '' : 'none';
        }
      });
    }
    
    // Show toast notification
    function showToast(message, type = 'info') {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.className = `toast ${type}`;
      toast.classList.add('show');
      
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000);
    }
    
    // Auto-format inputs
    document.getElementById('newChannelCode').addEventListener('input', function(e) {
      e.target.value = e.target.value.toUpperCase();
    });
    
    document.getElementById('newPasskey').addEventListener('input', function(e) {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });
    
    document.getElementById('modalNewPasskey').addEventListener('input', function(e) {
      e.target.value = e.target.value.replace(/[^0-9]/g, '');
    });
    
    // Initialize
    generatePasskey();
  </script>
</body>
</html>
